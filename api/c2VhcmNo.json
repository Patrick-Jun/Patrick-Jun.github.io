[{"title":"正则表达式","date":"2021-01-29T12:43:40.000Z","date_formatted":{"ll":"Jan 29, 2021","L":"01/29/2021","MM-DD":"01-29"},"updated":"2021-03-02T09:53:32.690Z","content":"正则表达式语法学习，常用正则表达式设计（视频讲解）\n\nPPT：https://cloud.189.cn/t/AnAR3uF3UJN3（访问码：ay78）\n视频回放地址：https://www.bilibili.com/video/BV1Ft4y1B768/\n\n \n\n\n以下内容为基本语法，详细请见PPT\n\n一、 界定符\n定义：表示一个正则表达式的开始和结束\n在JavaScript中，界定符以斜线（/）开始和结束：\n1const reg = /正则表达式/;\n可以这样理解：字符串是通过单引号或者双引号界定，那么正则的界定就好理解了吧。\n二、 原子\n定义：正则表达式中最小的匹配单位\n分为：可见原子、不可见原子（空格、换行符等）\n123const reg = /A/;const reg = /,/;const reg = / /;\n以上正则表达式中，均只有一个原子。\n可以这样理解：一篇文章的最小单位是一个文字或者一个单词，他们组合在一起就是一篇文章，正则表达式也是有原子组合而来的。\n三、 元字符\n定义：一系列原子的集合\n作用：定义原子的筛选方式；对某一类原子归类缩写；\n有三种筛选方式：\n123原子|原子    // 表示：或（匹配其中一个原子即可）[原子原子...]  // 表示：任一（匹配括号里的任一一个原子即可，原子之间不用竖线）[^原子原子...] // 表示：除此之外（和前一种情况相反）\n中括号中，如果原子是连续的（ASCII码），那么可以用横线（-）表示连续：\n12[0123456789] = [0-9][abcdefghijklmn] = [a-n]\n内置原子集合：\n\n\n元字符\n解释\n等价于\n\n\n\n\n.\n除换行符之外任意一个字符\n\n\n\n\\d\n匹配任意一个十进制数\n[0-9]\n\n\n\\D\n匹配任意一个非十进制数\n[^0-9]\n\n\n\\s\n匹配一个不可见原子\n[\\f\\n\\r\\t\\v]\n\n\n\\S\n匹配一个可见原子\n[^\\f\\n\\r\\t\\v]\n\n\n\\w\n匹配任意一个数字、字母、下划线\n[0-9a-zA-Z_]\n\n\n\\W\n匹配任意一个非数字、字母、下划线\n[^0-9a-zA-Z_]\n\n\n可以这样理解：单词可以组成一句话，文章是由很多句话组成。元字符也是对一类原子组成的一小段，最终这些元字符汇聚就可以组成正则表达式。\n四、 量词\n定义：描述原子连续出现的次数\n用法：\n123原子&#123;n&#125;      // 表示要前面紧邻的这个原子要匹配n次原子&#123;n,&#125;     // 表示要前面紧邻的这个原子要匹配大于等于n次：半开半闭区间 [n, +无穷)原子&#123;n,m&#125;    // 表示要前面紧邻的这个原子要匹配大于等于n次，小于等于m次：[n, m]\n特殊量词：\n\n\n特殊量词\n解释\n等价于\n\n\n\n\n*\n匹配&gt;=0次之前的原子（可存在）\n{0,}\n\n\n+\n匹配1次或多次之前的原子（存在）\n{1,}\n\n\n?\n匹配0次或1次之前的原子（可有可无）\n{0,1}\n\n\n示例：\n12/ES\\d&#123;4&#125;/     // 可以匹配到：ES000 ES2015 ES2020等/go&#123;2,&#125;gle/   // 可以匹配到：google gooooooogle等\n五 边界控制\n定义：对目标位置的控制，以^表示开始，以$表示结束。\n用法：\n1234/go&#123;2,&#125;gle/   // &quot;This is google website!&quot;  可以匹配/^go&#123;2,&#125;gle/  // &quot;This is google website!&quot;  匹配失败              // &quot;google&quot;  可以匹配\n此外边界控制还有模式单元()，小括号的作用可以将整体作为一个原子。\n12[Dd]  // 2个原子(D|d) // 1个原子\n六 修正模式\n定义：给正则表达式的匹配过程设定一种模式\n\n\n修正表达式\n解释\n\n\n\n\ni\n忽略字母大小写\n\n\ng\n执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）\n\n\nm\n执行多行匹配。\n\n\n用法：\n1/正则表达式/i\n七 贪婪模式和懒惰模式\n定义：\n贪婪模式：在条件允许的范围内，利益最大化（得寸进尺）\n懒惰模式：达到最低标准即可（不思进取）\n用法：量词后面加？表示懒惰模式\n12tasssssk   /s+/  匹配结果：sssss  (贪婪模式，可以匹配1个以上的s，那就全匹配)tasssssk   /s+?/ 匹配结果：s      (懒惰模式，可以匹配1个以上的s，那最低标准1个s)\n\n\n贪婪模式\n懒惰模式\n解释\n\n\n\n\n?\n??\n匹配0个或1个\n\n\n+\n+?\n匹配1个或多个\n\n\n*\n*？\n匹配0个或多个\n\n\n{n}\n{n}?\n匹配n个\n\n\n{n,m}\n{n,m}?\n匹配n个或者m个\n\n\n{n,}\n{n,}?\n匹配n个或者多个\n\n\n八 神奇的问号?\n正向断言：(?=原子) 表示后面必须接正向断言的原子，且匹配结果不包括该原子\n负向断言：(?!原子)表示后面不能接正向断言的原子，匹配结果不包括该原子\n12/string(?=s)/   可以匹配：strings (匹配结果：stirng)  不可以匹配：stringS stringa/string(?!s)/   可以匹配：stringS (匹配结果：string)  不可以匹配：strings\n?:产生无编号分组：\n12正则：/(ab)c(ba)/   /(?:ab)c(ba)/  /((a)(b))(c)/编号：   1    2               1         1    2\n","thumbnail":"http://img.cdn.1zdz.cn/blog/20210129-cover.png","plink":"https://www.zzboy.cn/Learning/e08f36f1337d/"},{"title":"函数式编程范式","date":"2020-10-13T02:16:47.000Z","date_formatted":{"ll":"Oct 13, 2020","L":"10/13/2020","MM-DD":"10-13"},"updated":"2021-03-02T09:29:55.533Z","content":"函数式编程是一种编程范式\n\n讲解视频：https://www.bilibili.com/video/BV1vV411a7kH/\n\n \n\n一、函数式编程概念\n1.1 定义\n函数式编程（Functional Programming: FP）是一种编程范式（指计算机中编程中的典范模式或方法，就是一种思维方式），属于结构化编程，用于描述数据（函数）之间的映射关系。\n特别需要注意的是，函数式编程中的函数不是指程序中的函数（方法），而是数学中的函数（映射关系），如：y = f(x)，指x和y之间的关系。\n常见的编程范式有：过程化（命令式）编程、面向对象编程、声明式编程等。\n\n过程化编程：最原始的传统编程，将问题抽象为一系列步骤，然后通过编程方式将这些步骤转换为程序指令集，这些指令集按照一定顺序排列。人们把支持过程化编程范式的编程语言称为过程化编程语言，常见的有机器语言、汇编语言、BASIC、C、FORTRAN等。过程化语言特别适合解决线性（或者说按部就班）的算法问题。\n\n\n面向对象编程：将待解决问题抽象为面向对象的程序中的对象，利用封装使每个对象都拥有个体的身份。程序就是成堆的对象，彼此通过信息的传递，请求其它对象进行工作。面向对象包括三个基本概念：封装性、继承性、多态性。常见的面向对象语言有Java、C、C++、JavaScript。\n\n\n声明式编程：以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。SQL 语句就是最明显的一种声明式编程的例子，我们只需要定义好该如何处理数据，不需要指定具体实现，就可以查询到我们需要的数据。\n\n现代编程语言的发展趋势是支持多种范式，如C#、Java 8+、Kotlin、ES6+。\n编程范式和设计模式的区别：\n\n编程范式：是指从事软件工程的一类典型的编程风格（此概念好比“战略”），体现编写程序的人如何看待程序设计的“哲学观”；\n程序设计模式：设计模式是软件设计中常见问题的典型解决方案（此概念好比“战术”），是解决一系列实际问题的“方法学”。\n\n1.2 特性\n\n\n代码简洁：函数式编程使用了大量的函数，减少了代码的重复；\n\n\n接近自然语言，易于理解：\n123let result = （1 + 2）* 3 - 4; // 普通表达式let result = subtract(multiply(add(1, 2), 3), 4); // 函数式编程\n\n\n函数是“第一等公民”：函数与其他数据类型一样，处于平等地位，可以赋值给其它变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值；\n\n\n闭包和高阶函数：函数式编程会使用较多的闭包和高阶函数；\n\n\n没有“副作用”，方便与代码管理和单元测试：副作用 指函数内部与外部互动(最典型的情况，就是修改全局变量量的 值)，产⽣运算以外的其他结果。函数式编程强调没有&quot;副作用&quot;，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他⾏为，尤其是不得修改外部变量的值；\n\n\n引用透明：函数的运行不依赖于外部变量或&quot;状态&quot;，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的。\n\n\n1.3 基本概念\n①函数式编程的思维方式：\n把现实世界的事物和事物之间的联系（映射关系）抽象到程序世界（对运算过程进行抽象）\n12// 比如买单价为0.5元的白菜，买了两斤，需要支付多少块钱（白菜与货币的联系）let money = multiply(0.5, 2); // 即两斤白菜 -&gt; 1元（money）\n②程序的本质：\n根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数。\n③函数y = f(x)：\nx → f(映射) → y\n图1 从x到y的函数关系\n\n图2 从x到y不是函数关系\n\n④纯函数：相同的输入始终要得到相同的输出\n⑤函数式编程是用来描述数据（函数）之间的映射\n1.4 学习指南\n函数式编程范式只是一种对程序编程思维的一种概论，而具体的实现则通过柯里化（第5章）、函数组合（第6章）、函子等来实现。\n在学习如何实现前，需要先了解三个小知识点：头等函数（第2章），闭包（第3章），纯函数（第4章）。\n二、头等函数\n2.1 函数是一等公民\n函数是一等公民？通俗来讲在某些编程语言中，函数是不能够：\n\n函数可以存储在变量中\n函数可以作为参数（2.2.1）\n函数可以作为返回值（2.2.2）\n\nJavaScript对待不同的数据结构具有同等级别的支持，函数可以享受以上几种待遇，所以在JavaScript中，函数是一等公民。\n函数可以存储在变量中：\n1234567891011121314151617181920// 把函数赋值给变量const fn = () =&gt; &#123;  console.log(&#x27;2.1 函数可以存储在变量中&#x27;);&#125;;fn();// 属性赋值示例const objController = &#123;  getKeys(obj) &#123; // ES6属性简写，等同于getKeys: getKeys(obj)    return Object.keys(obj);  &#125;,&#125;;// 优化：上面代码中getKeys方法和内部调用Object.keys方法的参数和返回值一样，所以可以改写成下面const objController = &#123;  getKeys: Object.keys,&#125;;console.log(objController);const my = &#123; name: &#x27;Patrick Jun&#x27;, constellation: &#x27;Virgo&#x27; &#125;;console.log(objController.getKeys(my));\n2.2 高阶函数\n如果一个函数以下面任一方式使用，那么这个函数就可以称为高阶函数。\n\n参数是一个函数\n返回值是一个函数\n\n\nPatrick Jun：可以操作函数的函数就是高阶函数。这就跟高数里的求导（二阶及以上的求导称之为高阶求导）一样，可以对已导函数的求导就是高阶求导。\n\n2.2.1 函数作为参数\n将函数作为参数最常见的就是咱们经常用的回调函数。\n12345678910111213141516171819202122232425// 遍历（模拟数组的forEach方法）function forEach(arr, fn) &#123;  for (let i = 0; i &lt; arr.length; i++) &#123;    fn(arr[i], i); // 将每一项传入回调fn处理  &#125;&#125;// 筛选，返回符合条件的元素组成的新数组function filter(arr, fn) &#123;  const results = [];  for (const item of arr) &#123;    if (fn(item)) &#123;      results.push(item);    &#125;  &#125;  return results;&#125;const colors = [&#x27;#FF0000&#x27;, &#x27;#00FF00&#x27;, &#x27;blue&#x27;];forEach(colors, (item, index) =&gt; &#123;  console.log(index + 1, item);&#125;);console.log(  filter(colors, (item) =&gt; item.length === 7),);\n2.2.2 函数作为返回值\n1234567891011121314151617181920212223242526function makeFn() &#123;  const msg = &#x27;hello function&#x27;;  return function () &#123;    console.log(msg);  &#125;;&#125;const fn = makeFn(); // makeFn()执行后返回一个匿名函数，赋值给fnfn();// makeFn()()// 模拟lodash中的once函数 对一个函数只执行一次的函数(例如支付,不管用户点击多少次按钮，都只执行一次)function once(func) &#123;  let done = false; // 定义一个状态done，判断是否已执行支付  return function () &#123;    if (!done) &#123;      done = true; // 更改闭包作用域中的done为已支付      func.apply(this, arguments);    &#125;  &#125;;&#125;const pay = once((money) =&gt; &#123;  // 传入一个函数，通过输出模拟支付过程和结果  console.log(`支付$&#123;money&#125;元`);&#125;);pay(20);  // 支付20元pay(30);pay(40);\n2.2.3 使用高阶函数意义\n\n\n抽象可以帮我们屏蔽细节，只需要关注我们的目标\n比如前面的例子：不用在乎如何遍历，只需要关注我们怎么出处理数据。不用在乎用户会不会多次点击，只需要关注如何处理支付后的流程。\n\n\n高阶函数用来抽象通用的问题\n比如前面抽象遍历问题\n\n\n2.2.4 常用高阶函数模拟\n\nmap 通过指定函数处理数组的每个元素，并返回处理后的数组。\n\n1234567891011function map(arr, fn) &#123;  const res = [];  for (const val of arr) &#123;    res.push(fn(val)); // 将回调fn()处理好的元素存入新数组  &#125;  return res;&#125;let arr = [1, 2, 3, 4, 5];arr = map(arr, (item) =&gt; item * item);console.log(arr); //[ 1, 4, 9, 16, 25 ]\n\nevery 用于检测数组所有元素是否都符合指定条件\n\n123456789101112131415161718function every(arr, fn) &#123;  let res = true; // 定义一个flag  for (const val of arr) &#123;    res = fn(val); // fn判断    if (!res) &#123; // 只要有一个元素不满足，就结束循环      break;    &#125;  &#125;  return res;&#125;const arr1 = [1, 2, 3, 4, 5];const arr2 = [4, 5, 6, 7];const res1 = every(arr1, (item) =&gt; item &gt; 3);console.log(res1);  // falseconst res2 = every(arr2, (item) =&gt; item &gt; 3);console.log(res2);  // true\n\nsome 判断数组中是否至少有一个元素满足条件\n\n123456789101112131415161718function some(arr, fn) &#123;  let res = false; // 定义一个flag  for (const val of arr) &#123;    res = fn(val); // fn判断    if (res) &#123; // 只要有一个元素满足，就结束循环      break;    &#125;  &#125;  return res;&#125;const arr1 = [1, 2, 3, 4, 5];const arr2 = [1, 3, 5, 7];const res1 = some(arr1, (item) =&gt; item % 2 === 0);console.log(res1);  // trueconst res2 = some(arr2, (item) =&gt; item % 2 === 0);console.log(res2);  // false\n\nfind 返回数组中满足提供的测试函数的第一个元素的值，如果未找到，则返回undefined\n\n123456789101112131415function find(arr, fn) &#123;  for (const item of arr) &#123;    if (fn(item)) &#123; // 找到满足条件的第一个元素      return item;    &#125;  &#125;  return undefined; // 未找到返回undefined&#125;const arr1 = [1, 2, 3, 4, 5];const res1 = find(arr1, (item) =&gt; item % 2 === 0);console.log(res1);  // 2const res2 = find(arr1, (item) =&gt; item === 8);console.log(res2);  // undefined\n\nfindIndex 找到满足条件的第一个元素，返回其位置，如果未找到，则返回-1\n\n123456789101112131415function findIndex(arr, fn) &#123;  for (let i = 0; i &lt; arr.length; i++) &#123;    if (fn(arr[i])) &#123; // 找到满足条件的第一个元素位置      return i;    &#125;  &#125;  return -1; // 未找到返回-1&#125;const arr1 = [1, 2, 3, 4, 5];const res1 = findIndex(arr1, (item) =&gt; item % 2 === 0);console.log(res1);  // 1const res2 = findIndex(arr1, (item) =&gt; item === 8);console.log(res2);  // -1\n三、闭包\n3.1 定义\n函数和其周围的状态的引用捆绑在一起形成的闭包。\n\n可以在另一个作用域中调用一个函数内部的函数并访问到该函数的作用域中的成员；\n闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕后会从执行栈上删除，但是堆上作用域成员因为被外部引用而不能被释放，因此内部函数依然可以访问到作用域的成员；\n\n特性：\n\n\n函数嵌套函数（高阶函数）\n\n\n函数内部可以引用函数外部的参数和变量\n\n\n参数和变量不会被垃圾回收机制回收\n\n\n3.2 案例\n12345678910111213141516171819202122232425262728function makePower(power) &#123;  return function (number) &#123;    return number ** power;  // number为底数，power为指数  &#125;;&#125;// 平方：number**2const power2 = makePower(2);// 立方：number**3const power3 = makePower(3);console.log(power2(5));console.log(power2(2));console.log(power3(4));function makeSalary(base) &#123;  return function (performance) &#123;    return base + performance;  &#125;;&#125;// 底层打工人const level1 = makeSalary(1000);// 高级打工人const level2 = makeSalary(10000);console.log(level1(100));  // 1100console.log(level1(120));  // 1120console.log(level2(30000));  // 40000\n打开Chrome开发者工具 &gt; Sources ：\n\nCall Stack(函数调用栈)\nScope(作用域) ： Global(var 全局) 、 Local(局部) 、 Closure(闭包) 、 Script(let 作用域)\n\n\n仅看一看演示一下，具体细节之后专门分享 ^_^\n\n12345678910111213// 查看函数栈和闭包作用域成员的访问function makeSalary() &#123;  let base = 1000;  return function (performance) &#123;    // debugger;    base += 1;    return base + performance;  &#125;;&#125;const sallary = makeSalary();console.log(sallary(100));console.log(sallary(200));\n四、纯函数\n4.1 概念\n相同的输入永远会等到相同的输出，没有任何可观察的副作用\n\nslice 和 splice 分别：纯函数和不纯函数\nslice 返回数组中的指定部分，不会改变原数组\nsplice 对数组进行操作返回该数组，会改变原数组\n\n12345678910111213141516171819// 纯函数 slice(start, end)const numbers = [1, 2, 3, 4, 5];console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.slice(0, 3)); // [ 1, 2, 3 ]// 不纯函数 splice(index, howmany, ...items)console.log(numbers.splice(0, 3)); // [ 1, 2, 3 ]console.log(numbers.splice(0, 3)); // [ 4, 5 ]console.log(numbers.splice(0, 3)); // []// 最简单的纯函数示例function getSum(a, b) &#123;  return a + b;&#125;console.log(getSum(1, 2)); // 3console.log(getSum(1, 2)); // 3console.log(getSum(1, 2)); // 3\n4.2 lodash\n官网：lodash\nlodash是一个纯函数的功能库，提供了对数组、数字、对象、字符串、函数等操作的一些方法。\n123456789101112131415const _ = require(&#x27;lodash&#x27;);const arr = [&#x27;Tom&#x27;, &#x27;Jon&#x27;, &#x27;Kate&#x27;];console.log(_.first(arr));console.log(_.last(arr));console.log(_.toUpper(_.last(arr)));console.log(_.reverse(arr));console.log(_.first(arr));_.each(arr, (item, index) =&gt; &#123;  console.log(item, index);&#125;);const value = [];_.isEmpty(value); // 判断一个value 是否是empty(null,[],&#123;&#125;....)\n4.3 纯函数的好处\n\n可缓存：因为纯函数相同的输入永远会等到相同的输出，所以可以把纯函数结果缓存\n\n1234567891011121314151617181920212223242526272829// 记忆函数const _ = require(&#x27;lodash&#x27;);function getArea(r) &#123;  console.log(`执行getArea计算，r = $&#123;r&#125;`);  return Math.PI * r * r;&#125;// 这里使用lodash中的记忆函数const getAreaWithMemory = _.memoize(getArea);console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(4)); // 不会再次计算console.log(getAreaWithMemory(5));// js模拟 memoize 方法的实现function memoize(f) &#123;  const cache = &#123;&#125;;  return function () &#123;    const key = JSON.stringify(arguments);    cache[key] = cache[key] || f.apply(f, arguments);    return cache[key];  &#125;;&#125;const getAreaWithMemory = memoize(getArea);console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(4));console.log(getAreaWithMemory(5));\n\n可测试：纯函数让测试更加方便，对单元化测试很友好\n并行处理：在多线程环境下并行操作共享的内存数据很可能会出现意外情况，纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker）\n\n4.4 副作用\n纯函数：指相同的输入永远会得到相同的输出，而且没有可观察的副作用，而副作用让一个函数变的不纯，纯函数根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用。\n1234567891011// 不纯的函数let min = 18;function checkAge(age) &#123;  return age &gt;= min; // 依赖外部的min状态&#125;// 纯函数function checkAge2(age) &#123;  let min = 18; // 硬编码，可通过闭包或者柯里化解决  return age &gt;= min;&#125;\n副作用的来源：\n\n\n配置文件\n\n\n数据库\n\n\n获取用户的输入：\n所有的外部交互都有可能带来副作用，副作用也会使方法通用性下降、不适合扩展，同时副作用会给程序中带来安全隐患给程序员带来不确定性，但是副作用不可能完全禁止，尽可能控制他们在可控范围内发生。\n12345678910111213141516171819// 有副作用let result = 0;function sum() &#123;  const a = $(&#x27;.input-1&#x27;).val();  const b = $(&#x27;.input-2&#x27;).val();  result = a + b;&#125;// &lt;button onclick=&quot;sum()&quot;&gt;求和&lt;/button&gt;// 避免副作用function sum(a, b) &#123;    return a + b;&#125;$(&#x27;button&#x27;).bind(&quot;click&quot;, () =&gt; &#123;   const a = $(&#x27;.input-1&#x27;).val();  const b = $(&#x27;.input-2&#x27;).val();  result = sum(a, b);&#125;);// &lt;button&gt;求和&lt;/button&gt;\n\n\n五、柯里化\n柯里化（curry：咖喱）可以把多元函数转化成一元函数\n\n当一个函数有多个参数的时候，先传递一部分参数调用它（这部分参数以后永远不变）\n然后返回一个新的函数接受剩余的参数，直达参数接收完毕才返回结果\n\n5.1 柯里化示例(问题回顾)\n解决上面硬编码问题：\n1234567// 普通纯函数的方式解决function checkAge(age, min) &#123;  return age &gt;= min;&#125;console.log(checkAge(20, 18));  // trueconsole.log(checkAge(17, 18));  // falseconsole.log(checkAge(24, 22));  // true\n上面代码可以发现当基准值时18时，18是重复的 使用之前所学的闭包处理\n1234567891011121314// 闭包的方式解决（简单的柯里化）function checkAge(min) &#123;  return function (age) &#123;    return age &gt;= min;  &#125;;&#125;const checkAge18 = checkAge(18);const checkAge22 = checkAge(22);console.log(checkAge18(17)); // falseconsole.log(checkAge18(20)); // trueconsole.log(checkAge22(20)); // falseconsole.log(checkAge22(30)); // true\n使用ES6改造上面checkAge函数：\n1let checkAge = min =&gt; age =&gt; age &gt;= min;\n5.2 lodash.curry(fn)\n\n_.curry(fn)\n\n文档：https://www.lodashjs.com/docs/lodash.curry\n功能：创建一个函数，该函数接受fn的参数。如果fn所需的参数都被提供则执行fn并返回结果，否则继续返回该函数并等待接收剩余的参数。\n\n\n\n\n需要注意：传参先后顺序不能变\n\n1234567891011const _ = require(&#x27;lodash&#x27;)function getSum(a, b, c) &#123;    return a + b + c&#125;const curried = _.curry(getSum);console.log(curried(2, 3, 4));  // 9console.log(curried(2)(3)(4));  // 9console.log(curried(2)(3, 4));  // 9console.log(curried(2, 3)(4));  // 9\n\n案例\n\n1234567891011121314151617181920212223242526const _ = require(&#x27;lodash&#x27;);const match = _.curry((reg, str) =&gt; &#123;  return str.match(reg);&#125;);// 匹配所有数字const hasSpace = match(/\\s+/g);// 匹配所有空白字符const hasNumber = match(/\\d+/g);console.log(hasSpace(&#x27;helloword&#x27;)); // nullconsole.log(hasNumber(&#x27;123213 123&#x27;)); // [&quot;123213&quot;, &quot;123&quot;]console.log(hasNumber(&#x27;helloword&#x27;)); // null// 再扩展：筛选数组中指定条件的元素const filter = _.curry((func, array) =&gt; &#123;  return array.filter(func);&#125;);console.log(filter(hasSpace, [&#x27;Patrick Jun&#x27;, &#x27;Patrick_Jun&#x27;])); // [&quot;Patrick Jun&quot;]// 分步使用 = filter(hasSpace)([&#x27;Patrick Jun&#x27;, &#x27;Patrick_Jun&#x27;])const findSpace = filter(hasSpace);console.log(findSpace([&#x27;Patrick Jun&#x27;, &#x27;Patrick_Jun&#x27;])); // [&quot;Patrick Jun&quot;]\n\n\n模拟lodash中的curry方法\n小知识点：fn = (a, b, c, d, e) =&gt; &#123;&#125;;，那么fn.length = 5;\n\n\n1234567891011121314151617181920function curry(func) &#123;  return function curriedFn(...args) &#123;    // 判断形参和实参的个数    if (args.length &lt; func.length) &#123;      return function () &#123;        // 将...args与...arguments拼接传递给curriedFn        return curriedFn(...args, ...arguments);      &#125;;    &#125;    return func(...args);  &#125;;&#125;function getSum(a, b, c) &#123;  return a + b + c;&#125;const curried = curry(getSum);console.log(curried(2, 3)(4)); // 9console.log(curried(2)(3, 4)); // 9\n图解步骤：\n\n5.3 总结\n\n柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数\n这是一种对函数参数的“缓存”（闭包）\n让函数变的更灵活，让函数的粒度更小\n可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能\n\n六、函数组合\n6.1 概念\n函数组合(compose)：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数。\n\n函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果\n函数组合默认是从右到左执行\n函数组合后只接受一个参数\n\n123456789101112131415161718// 函数组合演示function reverse(array) &#123;  return array.reverse();&#125;function first(array) &#123;  return array[0];&#125;function compose(f, g) &#123;  return function (value) &#123;    return f(g(value));  &#125;;&#125;const last = compose(first, reverse);console.log(last([1, 2, 3, 4])); // 4\n6.2 lodash组合函数\n6.2 lodash组合函数\nlodash中组合函数flow()或者flowRight()，他们都可以组合多个函数\nflow和flowRight会创建一个函数，返回结果是调用提供函数的结果。提供函数会连续调用，每个提供函数传入的参数都是前一个函数返回的结果。\n\nflow()是从左到右运行\nflowRight()是从右到左运行，使用的更多一些\n\n123456789const _ = require(&#x27;lodash&#x27;);const reverse = (arr) =&gt; arr.reverse();const first = (arr) =&gt; arr[0];const toUpper = (s) =&gt; s.toUpperCase();const f = _.flowRight(toUpper, first, reverse);console.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]));  // ???\n模拟lodash中的flowRight()方法：\n\n数组中的reduce() ：对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。\n\n12345678910function compose(...args) &#123;  return function (val) &#123;    return args.reverse().reduce((acc, fn) =&gt; &#123;      return fn(acc);    &#125;, val);  &#125;;&#125;// ES6// const compose = (...args) =&gt; (val) =&gt; args.reverse().reduce((acc, fn) =&gt; fn(acc), val);\n图解步骤：\n\n6.3 结合律\n函数的组合要满足结合律。\n例如compose(f,g,h)，我们既可以先把f和g组合在一起，还可以先把g和h组合：\n123456789101112console.log(compose(compose(f, g), h) == compose(f, compose(g, h))); //trueconsole.log(compose(f, g, h) == compose(f, compose(g, h))); //trueconst _ = require(&#x27;lodash&#x27;)// 下面三种写法结果运行一样const f = _.flowRight(_.flowRight(_.toUpper, _.first), _.reverse); // 前两个组合const f1 = _.flowRight(_.toUpper, _.flowRight(_.first, _.reverse)); // 后两个组合const f2 = _.flowRight(_.toUpper, _.first, _.reverse); // 不组合console.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]) === f1([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])); // trueconsole.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]) === f2([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])); // trueconsole.log(f1([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]) === f2([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])); // true\n6.4 实战\n题目：将NEVER SAY DIE 转换为 never-say-die;\n思路：小写，分割，join\n'NEVER SAY DIE'.toLowerCase().split(' ').join('-');\n分析：\n12345678910111213141516171819202122232425262728293031323334const _ = require(&#x27;lodash&#x27;);// 第一步：_.toLower()// 第二步：_.split()// 因为我们需要传入str变量，所以str放在最后面传入，以下同理const split = _.curry((symbol, str) =&gt; _.split(str, symbol));// 第三步：._joinconst join = _.curry((symbol, array) =&gt; _.join(array, symbol));// log用来检测数据管道中，哪部分值有错误const log = (v) =&gt; &#123;  console.log(v);  // 继续返回值给下一个fn  return v;&#125;;const f = _.flowRight(join(&#x27;-&#x27;), log, split(&#x27; &#x27;), log, _.toLower);console.log(f(&#x27;NEVER SAY DIE&#x27;)); // never-say-die// // 考虑到数据管道很长的情况，如果多次log，打印的数据不够直观，于是改造log// const _ = require(&#x27;lodash&#x27;);// const trace = _.curry((tag, v) =&gt; &#123;//   console.log(tag, v);//   return v;// &#125;);// const split = _.curry((symbol, str) =&gt; _.split(str, symbol));// const join = _.curry((symbol, arr) =&gt; _.join(arr, symbol));// const f = _.flowRight(join(&#x27;-&#x27;), trace(&#x27;after split：&#x27;), split(&#x27; &#x27;), trace(&#x27;after toLower：&#x27;), _.toLower);// console.log(f(&#x27;NEVER SAY DIE&#x27;));\n6.5 lodash/fp\nlodash/fp\nThe lodash/fp module promotes a more functional programming (FP) friendly style by exporting an instance of lodash with its methods wrapped to produce immutable auto-curried iteratee-first data-last methods.\n\n\nlodash中的fp模块提供了实用的对函数式编程友好的方法\n\n\n提供了不可变auto-curried(自动柯里化) iteratee-first data-last的方法\n\n\n12345678910111213// lodash 模块  数据优先 函数滞后const _ = require(&#x27;lodash&#x27;);_.map([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;], _.toUpper); // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]_.map([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]); // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]_.split(&#x27;Hello World&#x27;, &#x27; &#x27;); // [&quot;Hello&quot;, &quot;World&quot;]const fp = require(&#x27;lodash/fp&#x27;);fp.map(fp.toUpper, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]); // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]fp.map(fp.toUpper)([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]); // [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]fp.split(&#x27; &#x27;, &#x27;Hello World&#x27;); // [&quot;Hello&quot;, &quot;World&quot;]fp.split(&#x27; &#x27;)(&#x27;Hello World&#x27;); // [&quot;Hello&quot;, &quot;World&quot;]\n上面代码可以看出，lodash方法数据优先 函数滞后 ，而lodash/fp模块方法 函数优先 数据滞后 使用lodash/fp改造之前写的代码\n1234const fp = require(&#x27;lodash/fp&#x27;);const f = fp.flowRight(fp.join(&#x27;-&#x27;), fp.map(fp.toLower), fp.split(&#x27; &#x27;));console.log(f(&#x27;NEVER SAY DIE&#x27;));\nmap方法的区别：\n\nlodash中的map函数返回3个参数给callback函数\nlodash/fp中的map函数只返回1个参数给callback函数\n\n1234567const _ = require(&#x27;lodash&#x27;);const fp = require(&#x27;lodash/fp&#x27;);// (value, index|key, collection)_.map([&#x27;6&#x27;, &#x27;8&#x27;, &#x27;10&#x27;], parseInt); // [6, NaN, 2]// (value)fp.map(parseInt)([&#x27;6&#x27;, &#x27;8&#x27;, &#x27;10&#x27;]); // [6, 8, 10]\n6.6 Point Free\n我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要简单的把运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数\n\n不需要指明处理的数据\n只需要合成运算过程\n需要定义一些辅助的基本运算函数\n\n非 Point Free 模式\n1234// function f(word) &#123;  return word.toLowerCase().replace(/\\s+/g, &#x27;_&#x27;);&#125;\nPoint Free 模式\n1234const fp = require(&#x27;lodash/fp&#x27;);const f = fp.flowRight(fp.replace(/\\s+/g, &#x27;-&#x27;), fp.toLower);console.log(f(&#x27;HELLO   WORD&#x27;)); // hello-word\n案例：\n把一个字符串的首字母提取并转换成大写，使用.作为分隔符\n1234567// &#x27;word wild web  =&gt; W.W.W// const f = fp.flowRight(fp.join(&#x27;.&#x27;), fp.map(fp.first), fp.map(fp.toUpper), fp.split(&#x27; &#x27;))const fp = require(&#x27;lodash/fp&#x27;);// 解决了上面两次mapconst f = fp.flowRight(fp.join(&#x27;.&#x27;), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(&#x27; &#x27;));console.log(f(&#x27;word wild web&#x27;)); // W.W.W\n6.7 Functor(函子)\n6.7.1 函子概念\n为什么要学函子？\n到目前为止已经已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。\n什么是函子？\n作用：控制函数式编程的副作用，异常处理，异步操作等。\n\n容器：包含值和值的变形关系(这个变形关系就是函数)\n函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理(变形关系)\n\n1234567891011121314// 函子class Container &#123;  constructor(value) &#123;    this._value = value;  &#125;  map(fn) &#123;    return new Container(fn(this._value));  &#125;&#125;const r = new Container(5)  .map((x) =&gt; x + 1)  .map((x) =&gt; x * x);console.log(r); // Container &#123; _value: 36 &#125;\n函数式编程思想，避免出现new关键字：\n12345678910111213141516171819202122class Container &#123;  static of(value) &#123;    return new Container(value);  &#125;  constructor(value) &#123;    this._value = value;  &#125;  map(fn) &#123;    return Container.of(fn(this._value));  &#125;&#125;const r = Container.of(5)  .map((x) =&gt; x + 1)  .map((x) =&gt; x * x);console.log(r);// Container &#123; _value: 36 &#125;// 演示 null undefined 的问题// 副作用，因为没有返回值，所以null使fn函数变得不纯Container.of(null)  .map((x) =&gt; x.toUpperCase());\n总结：\n\n函数式编程的运算不直接操作值，而是由函子完成\n函子就是一个实现了 map 契约的对象\n我们可以把函子想象成一个盒子，这个盒子里封装了一个值\n想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理\n最终 map 方法返回一个包含新值的盒子（函子）\n\n6.7.2 Maybe函子\n\n我们在编程的过程中可能会遇到很多错误，需要对这些错误做相应的处理\nMayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）\n\n12345678910111213141516171819202122232425// Maybe函子class Maybe &#123;  static of(value) &#123;    return new Maybe(value);  &#125;  constructor(value) &#123;    this._value = value;  &#125;  map(fn) &#123;    return this.isNothing() ? Maybe.of(null) : Maybe.of(fn(this._value));  &#125;  isNothing() &#123;    return this._value === null || this._value === undefined;  &#125;&#125;// let r = Maybe.of(&#x27;hello word&#x27;)//     .map(x =&gt; x.toUpperCase())// console.log(r)//Maybe &#123; _value: &#x27;HELLO WORD&#x27; &#125;const r = Maybe.of(null)  .map((x) =&gt; x.toUpperCase());console.log(r); // Maybe &#123; _value: null &#125;\nMaybe函子虽然解决了空值问题，不会出现异常。但当多次调用map时，不能确定哪次出现了空值\n1234const r = Maybe.of(&#x27;hello word&#x27;)  .map((x) =&gt; null)  .map((x) =&gt; x.toUpperCase());console.log(r); // Maybe &#123; _value: null &#125;  不确定哪出现了null\n6.7.3 Either函子\n\nEither 两者中的任何一个，类似于 if…else…的处理\n异常会让函数变的不纯，Either 函子可以用来做异常处理\n\n12345678910111213141516171819202122232425262728293031// Either 函子class Left &#123;  static of(val) &#123;    return new Left(val);  &#125;  constructor(value) &#123;    this._value = value;  &#125;  map(fn) &#123;    return this;  &#125;&#125;class Right &#123;  static of(val) &#123;    return new Right(val);  &#125;  constructor(value) &#123;    this._value = value;  &#125;  map(fn) &#123;    return Right.of(fn(this._value));  &#125;&#125;const r1 = Left.of(12).map((x) =&gt; x + 2);const r2 = Right.of(12).map((x) =&gt; x + 2);console.log(r1, r2); // Left &#123; _value: 12 &#125; Right &#123; _value: 14 &#125;\nLeft函子可以记录错误信息处理异常，Right函子对参数处理\n1234567891011121314function parseJSON(str) &#123;  try &#123;    return Right.of(JSON.parse(str));  &#125; catch (e) &#123;    return Left.of(&#123;      error: e.message,    &#125;);  &#125;&#125;const r = parseJSON(&#x27;&#123;&quot;name&quot;:&quot;tom&quot;&#x27;);console.log(r); // Left &#123; _value: &#123; error: &#x27;Unexpected end of JSON input&#x27; &#125; &#125;const r3 = parseJSON(&#x27;&#123;&quot;name&quot;:&quot;tom&quot;&#125;&#x27;)  .map((x) =&gt; x.name.toUpperCase());console.log(r3); // Right &#123; _value: &#x27;TOM&#x27; &#125;\n6.7.4 IO函子\n\nIO函子中的 _value 是一个函数，这里是把函数作为值来处理\nIO函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作（惰性执行），包装当前的纯操作\n把不纯的操作交给调用者来处理\n\n1234567891011121314151617181920212223242526// IO 函子const fp = require(&#x27;lodash/fp&#x27;);class IO &#123;  static of(value) &#123;    return new IO((() =&gt; value));  &#125;  constructor(fn) &#123;    this._value = fn;  &#125;  map(fn) &#123;    return new IO(fp.flowRight(fn, this._value));  &#125;&#125;// 调用// 这里的p就是proccess// 返回了一个新的IO，并将p.execPath的返回存储为r._valuelet r = IO.of(process).map((p) =&gt; p.execPath);// 为了更好的理解： fp.upperCase(str01) 的值作为p，传入fp.reverse(p),然后将fp.reverse(p)的值传入r._valuer = IO.of(fp.upperCase(&#x27;patrick jun&#x27;)).map((p) =&gt; fp.reverse(p));// console.log(r)console.log(r._value());\nIO函子控制了副作用在可控范围内发生\n1234567891011121314151617181920212223242526272829303132333435// IO 函子的问题const fs = require(&#x27;fs&#x27;); // node.js require(&#x27;fs&#x27;)const fp = require(&#x27;lodash/fp&#x27;);console.log(fs);class IO &#123;  static of(value) &#123;    return new IO((() =&gt; value));  &#125;  constructor(fn) &#123;    this._value = fn;  &#125;  map(fn) &#123;    return new IO(fp.flowRight(fn, this._value));  &#125;&#125;const readFile = function (filename) &#123;  return new IO((() =&gt; fs.readFileSync(filename, &#x27;utf-8&#x27;)));&#125;;const print = function (x) &#123;  return new IO((() =&gt; &#123;    console.log(x);    return x;  &#125;));&#125;;const cat = fp.flowRight(print, readFile);// IO(IO(x))// 第一个_value是printd的执行结果readFile，第二个才是我们想要的最终结果const r = cat(&#x27;../../package.json&#x27;)._value()._value();console.log(r);\n6.7.5 Task异步执行\n\n\n异步任务的实现过于复杂，我们使用 folktale 中的 Task 来演示\n\n\nfolktale 一个标准的函数式编程库\n\n\n\n和 lodash、ramda 不同的是，他没有提供很多功能函数\n只提供了一些函数式处理的操作，例如：compose、curry 等，一些函子 Task、Either、MayBe 等\n\n\n\n123456789101112131415const &#123;    compose,    curry&#125; = require(&#x27;folktale/core/lambda&#x27;)const &#123;    toUpper,    first&#125; = require(&#x27;lodash/fp&#x27;)let f = curry(2,(x,y)=&gt;x+y)console.log(f(1,2))//3console.log(f(1)(2))//3let f1 = compose(toUpper, first)console.log(f1([&#x27;one&#x27;, &#x27;tow&#x27;]))//ONE\n使用folktale中的Task函子执行异步任务\n1234567891011121314151617181920212223242526const fs = require(&#x27;fs&#x27;)const &#123;    task&#125; = require(&#x27;folktale/concurrency/task&#x27;)function readFile(filePath) &#123;    return task(resolver =&gt; &#123;        fs.readFile(filePath, &#x27;utf-8&#x27;, (err, data) =&gt; &#123;            if (err) &#123;                resolver.reject(err)            &#125;            resolver.resolve(data)        &#125;)    &#125;)&#125;readFile(&#x27;../package.json&#x27;)    .map(data =&gt; JSON.parse(data))    .map(data =&gt; data.version)    .run().listen(&#123;        onRejected: err =&gt; &#123;            console.log(err)        &#125;,        onResolved: data =&gt; &#123;            console.log(data)        &#125;    &#125;)\n6.7.6 Pointed函子\n\nPointed 函子是实现了 of 静态方法的函子\nof 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文Context（把值放到容器中，使用 map 来处理值）\n\n1234567891011121314class Container &#123;    static of (value) &#123;        return new Container(value)    &#125;    constructor(value) &#123;        this._value = value    &#125;    map(fn) &#123;        return new Container(fn(this._value))    &#125;&#125;let r =Container.of(2)        .map(x =&gt; x + 5)console.log(r)//Container &#123; _value: 7 &#125;\n6.7.7 Monad函子\n\nMonad 函子是可以变扁的 Pointed 函子，IO（IO（x））\n一个函子如果具有 join 和 of 两个方法并遵守一些定律就是一个Monad\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// IO Monadconst fs = require(&#x27;fs&#x27;)const fp = require(&#x27;lodash/fp&#x27;)class IO &#123;  static of (value) &#123;    return new IO(function () &#123;      return value    &#125;)  &#125;  constructor (fn) &#123;    this._value = fn  &#125;  map (fn) &#123;    return new IO(fp.flowRight(fn, this._value))  &#125;  join () &#123;    return this._value()  &#125;  flatMap (fn) &#123;    return this.map(fn).join()  &#125;&#125;let readFile = function (filename) &#123;  return new IO(function () &#123;    return fs.readFileSync(filename, &#x27;utf-8&#x27;)  &#125;)&#125;let print = function (x) &#123;  return new IO(function () &#123;    console.log(x)    return x  &#125;)&#125;//为解决IO函子的问题，这样更符合函数式编程！let r = readFile(&#x27;package.json&#x27;)          // .map(x =&gt; x.toUpperCase())          .map(fp.toUpper)          //因为readFile返回一个IO函子，所以调用flatMap          .flatMap(print)          //因为flatMap返回一个函子，所以调用join，返回_value          .join()console.log(r)\n七、总结\n\n函数式编程是一种强调以函数使用为主的软件开发风格；\n纯函数指没有副作用的函数，相同的输入有相同的输出；\n在函数式编程里面，将多个不同函数组合是一个非常非常非常重要的思想；\n函数式编程将函数视为积木，通过一些高阶函数来提高代码的模块化和可重用性。\n\n\n理解：柯里化是”因式分解“，将参数分解开；函数组合是”结合律“，函数可以组合使用。\n\n参考文章：\n\n概念定义特点：https://juejin.im/post/6858129115598635015\n\n\n函数式编程讲解：https://juejin.im/post/6844903743117361165\n\n\n函数式编程讲解：https://juejin.im/post/6844903655397654535\n\n\n拉勾教育大前端训练营笔记： https://zhuanlan.zhihu.com/p/162839608\n\n\nwhat are “first class objects”：https://stackoverflow.com/questions/245192/what-are-first-class-objects\n\n","thumbnail":"http://img.cdn.1zdz.cn/blog/209z8ua0sd8da0s9.jpg","plink":"https://www.zzboy.cn/Learning/86cd6788d8fb/"},{"title":"JavaScript新特性","date":"2020-08-07T13:49:12.000Z","date_formatted":{"ll":"Aug 7, 2020","L":"08/07/2020","MM-DD":"08-07"},"updated":"2021-03-02T09:54:22.556Z","content":"一、前言\n我这里总结了一下ES6+中，一些比较实用的新特性。我们日常开发应该尽快使用这些新特性，能极大地提高我们的开发效率。\n我刚开始实习的时候，对ES6都不太怎么了解，工作后学习并渐渐运用起来，越用越爽，两个字：简洁方便高效。\n提一句：只要用了babel，所有的新特性请放心大胆地用。\n二、你得尽快用上的“新特性”\n\n为什么加引号，因为现在这些都不是多新的特性了，ES6是2015年就出了，到现在已经5年了。\n\n2.1 模板字符串\n模版字符串：用 `（反引号）标识，用 ${} 将变量括起来\nold：\n场景：通常我们在自定义一些echarts或者地图上添加东西时，我们常会拼接一些html代码\n1var html = &#x27;&lt;div style=&quot;color: &#x27; + color + &#x27;;&quot;&gt;&#x27; + str + &#x27;&lt;div&gt;&#x27;\n传统做法需要使用大量的“”（引号）和 + 来拼接才能得到我们需要的模版\nnew：\n1let html = `&lt;div style=&quot;color: $&#123;color&#125; ;&quot;&gt; $&#123;str&#125; &lt;div&gt;`\n$&#123;&#125; 里可以放任意的JavaScript表达式，也可以调用函数：\n123456789const count = 8, price = 10;console.log(`加购一个后数量：$&#123;++count&#125;, 总价：$&#123;count*price&#125;`);   // 加购一个后数量：9, 总价：90console.log(`输出个字符串：$&#123;&#x27;cool&#x27;&#125;`); // 输出个字符串：coolfunction myLove() &#123;    return &quot;as you love!&quot;;&#125;console.log(`I love $&#123;myLove()&#125;`);   // I love as you love!\n需要注意的几个问题：\n\n\n当需要在字符串里使用反引号的时候，需要转义；\n1console.log(`模版字符串：用 \\`（反引号）标识`);\n\n\n如果$&#123;&#125;中的变量不是字符串类型，那么会按照一般的规则转化为字符串；\n12const obj = &#123;a:1, b:2&#125;;console.log(`a = $&#123;obj&#125;`);   // a = [object Object]\n\n\n模板字符串会保留所有的空格、缩进和换行；\n12345let str = `I know   \t, you know!`;console.log(str);//  I know   //\t , you know!\n解决方案：使用\\解决换行符；使用+换行拼接；使用正则替换；使用变量替换；\n1234567891011121314151617let str = `I know   \\\t, you know!`;console.log(str);  // I know   \t, you know!str = `I know   `\t+ `, you know!`;console.log(str); // I know   , you know!str = (`I know\t, you know!`).replace(/\\s+/gm, &#x27; &#x27;);console.log(str); // I know , you know!const N = &#x27;&#x27;;str = (`I know$&#123;\t\tN&#125;, you know$&#123;\t\tN&#125;, all we know!`);console.log(str); // I know, you know, all we know!\n\n\n扩展了解：\n实现原理（未验证）：通过正则匹配，替换原字符串中的变量。包括常见的{{}}, &lt;%=xx%&gt;等\n12345function replace(str)&#123;    return str.replace(/\\$\\&#123;([^&#125;])\\&#125;/g,function(matched,key)&#123;          return eval(key)    &#125;)&#125;\n2.2 属性简写\nold：\n一个属性名对应一个值\n12345const pageIndex = 0, pageSize = 10;const params = &#123;    pageNum: pageIndex,    pageSize: pageSize&#125;\nnew：\n属性名和变量名保持一致，变量名尽量迎合属性名；\n12345678910const pageNum = 0, pageSize = 10, password = &#x27;123123&#x27;;const params = &#123;    pageNum,    pageSize,    password: encrypt(password)  // 属性简写和键值对可以混写&#125;// const params = &#123;//     pageNum: pageNum,//     pageSize: pageSize// &#125;\nquestion：\n\n\n如果我们的需要的值不是一个单独变量，而是从某个对象取出属性\n123456const pageNum = 0, pageSize = 10, user = &#123;uid: 100000, password: &#x27;123123&#x27;&#125;;const params = &#123;    pageNum,    pageSize,    user.password  ????&#125;\n答案：见第四章\n\n\n2.3 方法属性\nold：\n一个属性名对应一个值\n12345let math = &#123;  add: function(a,b) &#123; return a + b; &#125;,  sub: function(a,b) &#123; return a - b; &#125;,   multiply: function(a,b) &#123; return a * b; &#125;&#125;\nnew：\n自动识别方法名称作为属性名\n12345let math = &#123;  add(a,b) &#123; return a + b; &#125;,  sub(a,b) &#123; return a - b; &#125;,  multiply(a,b) &#123; return a * b; &#125;&#125;\n取函数名为属性名称\n微信小程序page结构：\n1234567891011121314151617Page(&#123;    data: &#123;        isShowloading: true    &#125;,    onLoad(options) &#123;            &#125;,    onReady () &#123;    &#125;,        handleTap(event) &#123;            &#125;&#125;)// 给page传入一个对象，这个对象的所有函数都可以进行属性名简写\nquestion:\n下面两个表达式都正确吗？\n1234567let obj1 = &#123;    fn1()&#123;&#125;.bind() &#125;let obj2 = &#123;    fn2: function()&#123;&#125;.bind() &#125;\n2.4 箭头函数\n箭头函数表达方式：=&gt;，因为像个箭头，所以叫箭头函数。\nold：\n123var f = function (v) &#123;  return v;&#125;;\nnew：\n12345// 写法let f = v =&gt; v;// 完整写法let f = (v) =&gt; &#123; return v; &#125;;\n如上，当函数只有一个形参时，=&gt;左侧可以省略()；\n当函数返回值可以用一句简单表达式表示时，=&gt;右侧可以省略&#123;&#125;和return；\n1234567let f = () =&gt; 5;   // ()不可省略let sum = (num1, num2) =&gt; num1 + num2;//var sun = function(num1, num2)&#123;return num1 + num2;&#125;;this.httpUtil.get(&#x27;xxxxxx.vm&#x27;, params, true, res =&gt; &#123;  console.log(res)&#125;);\nquestion:\n以下会输出什么？\n12let getTempItem = () =&gt; &#123; id: &#x27;s8309a82n&#x27;, name: &quot;Temp&quot; &#125;;getTempItem();\n2.5 “你懂的”运算符\nSpread operator，这个中文名称有好几种说法（扩展运算符、延展操作符、展开运算符等等），而我给它起的名字就叫你懂的运算符。它表示方法前面见过了...，作用是可以将数组、字符串、对象等在语法层面上展开。\n秘诀：给我“解压”到这里\n\n\n“解压”数组\n12345678const rgb = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];const colors = [...rgb]; // 巴啦啦魔仙变，给我把rgb解压到这个数组里// 结果： [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]const colorList = [&#x27;yellow&#x27;, ...rgb]; // [&#x27;yellow&#x27;, &#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]console.log([...colors, ...colorList]);  // ????\n\n\n“解压”对象\n123456789let you = &#123;    name: &#x27;DJ&#x27;,    age: 16&#125;you = &#123;    ...you,    school: &#x27;DLPU&#x27;&#125;// &#123;name: &quot;DJ&quot;, age: 16, school: &quot;DLPU&quot;&#125;\n\n\n“解压”字符串\n1234567let myCountry = &#x27;China&#x27;;console.log([...myCountry]);  // [&quot;C&quot;, &quot;h&quot;, &quot;i&quot;, &quot;n&quot;, &quot;a&quot;]// 等同于：console.log(myCountry.split(&#x27;&#x27;))cosnt resStr = &#123;...myCountry&#125;;console.log(resStr);  // &#123;0: &quot;C&quot;, 1: &quot;h&quot;, 2: &quot;i&quot;, 3: &quot;n&quot;, 4: &quot;a&quot;&#125;// 问题：怎么取值呢？  resStr[0]\n\n\nquestion:\n以下分别会输出什么？\n123456789let obj = &#123;a: 1, b: 2&#125;;console.log(&#123;a: 0, ...obj&#125;); ????let arr = [2,3,4];console.log(&#123;...arr&#125;)????console.log([...obj]);????\n扩展了解：见下一章\n2.6 解构赋值\nold:\n获取对象中的值\n123456789// res = &#123;status: 200, data: &#123;uid: &#x27;ed9fa0&#x27;, name: &#x27;DJ&#x27;, time: &#x27;1596808152&#x27;&#125;&#125;this.thsService.getLog().then(res=&gt;&#123;    const status = res.status;    const data = res.data;    const name = res.data.name;    const time = res.data.time;        console.log(status, data, name, time);&#125;)\nnew:\n123456789101112this.thsService.getLog().then(res=&gt;&#123;    const &#123; status, data &#125; = res;        const &#123; status, data, data: &#123; name, time &#125; &#125; = res;        // console.log(status, data, name, time);&#125;)// 还可以这样写this.thsService.getLog().then(&#123; status, data &#125;=&gt;&#123;    console.log(status, data);&#125;)\n数组：\n123let arr = [1, 2, 3, 4];let [a, b, c] = arr;     // a=1, b=2, c=3let [a, b, , d] = arr;\t // a=1, b=2, d=4\n默认值：\n12const &#123; status = 500, data = null &#125; = res;let [a=0, b=0, c=0, d=0, e=0] = arr;\n扩展了解：\n剩余运算符（ES2018）\n秘诀：“剩下的”都是我的\n\n\n“剩下的”属性\n1234let obj = &#123;a: 1, b: 2, c: _ =&gt; _&#125;;let &#123;b, ...rest&#125; = obj;  // rest说：b属性你拿走吧，剩下的全是我的b   \t\t// 2rest\t\t// &#123;a: 1, c: ƒ&#125;\n\n\n“剩下的”参数\n12345let restParam = (p1, p2, ...p3) =&gt; &#123;  // p3说：前两个参数你们拿走，剩下的都是我的了    console.log(p1, p2, p3);&#125;;restParam(1,2,3,4,5);   // p1 = 1, p2 = 2, p3 = [3, 4, 5]\n\n\n2.7 数组新方法\n\nfind(): any：返回找到满足条件的第一项，否则返回undefined\nfindIndex(): number：找到满足条件的一项的索引\nincludes(): boolean：是否包含一个值\n\n在ES6之前，要判断一个数组中是否包含一个元素，是通过indexOf()返回不等于-1\nES6之后，相继扩充一些方法：\nfind( fn(item, [index], [arr]) ):\n1234let arr = [&#123; id: 1, checked: true &#125;, &#123; id: 2 &#125;, &#123; id: 2 &#125;, 3, 4, NaN];arr.find( item =&gt; item.id === 1 );  // &#123; id: 1, checked: true &#125;arr.find( item =&gt; Object.is(NaN, item) );  // NaN\nfind会将每一个元素挨个去运行回调函数，找到了第一项之后就不会再执行了；\nfindIndex( fn(item, [index], [arr]) ):\n12arr.findIndex( item =&gt; item.id === 1 );  // 0arr.findIndex( item =&gt; Object.is(NaN, item) );  // 5\nincludes(value, fromIdx):\n12345678arr.includes(3);         // truearr.includes(NaN);       // truearr.includes(&#123; id: 2 &#125;)  // falselet a1 = &#123;id: 2&#125;, a2 = &#123;id: 2&#125;;a1 == a2;          // falselet a = [a1, a2];  // [&#123;id: 2&#125;, &#123;id: 2&#125;]a.includes(a2);    // true\n字符串同样存在includes方法：'Made in China'.includes('o'), false\nsome( fn(item, [index], [arr]) )：是否存在满足条件的一项，和includes是同样的作用。\n区别（优缺点）：some传入的是回调函数，具有更强大的可操性；includes传入参数是具体的值，书写简便。\nquestion:\nfind()只能取出满足条件的一项，那如何取出数组中满足条件的所有项呢？\n12let arr = [&#123; id: 1, checked: true &#125;, &#123; id: 2 &#125;, &#123; id: 2 &#125;, 3, 4, NaN];// ???? \n扩展：数组所有方法参考手册\n2.8 Promise、async/await\n\n\n回调地狱：“无限”（大量）地使用嵌套回调函数，好像掉进了18层地狱\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 一个动画的回调地狱例子animate(ball1, 100, function () &#123;  animate(ball2, 200, function () &#123;    animate(ball3, 300, function () &#123;      animate(ball1, 200, function () &#123;        animate(ball3, 200, function () &#123;          animate(ball2, 180, function () &#123;            animate(ball2, 220, function () &#123;              animate(ball2, 200, function () &#123;                console.log(&quot;over&quot;);              &#125;)            &#125;)          &#125;)        &#125;)      &#125;)    &#125;)   &#125;)&#125;);// promise优化后promiseAnimate(ball1, 500)    .then(function () &#123;      return promiseAnimate(ball2, 200);    &#125;)    .then(function () &#123;      return promiseAnimate(ball3, 300);    &#125;)    .then(function () &#123;      return promiseAnimate(ball1, 200);    &#125;)    .then(function () &#123;      return promiseAnimate(ball3, 200);    &#125;)    .then(function () &#123;      return promiseAnimate(ball2, 180);    &#125;)    .then(function () &#123;      return promiseAnimate(ball2, 220);    &#125;)    .then(function () &#123;      return promiseAnimate(ball2, 200);    &#125;)// async/await优化后async play() &#123;    await animate(ball1, 500);    await animate(ball2, 200);    await animate(ball3, 300);    await animate(ball1, 200);    await animate(ball4, 200);    await animate(ball2, 180);    await animate(ball2, 220);    await animate(ball2, 200);&#125;\n\n\nPromise:\n基本用法：\n12345678910111213141516171819202122232425262728293031function getUserData() &#123;    return new Promise((resolved, rejected) =&gt; &#123;        $.ajax(&#123;            type : &quot;get&quot;,            url : &quot;api.com&quot;,            success : res =&gt; &#123;                if(res.isSuccess) &#123;                    resolved(res.data);                &#125;else &#123;                    rejected(&#123;msg: &#x27;服务器错误&#x27;, info: res.errmsg&#125;);                &#125;            &#125;,            error: err =&gt; &#123;                rejected(&#123;msg: &#x27;网络错误&#x27;, info: err&#125;);            &#125;        &#125;);    &#125;)&#125;getUserData().then(data =&gt; &#123;    console.log(&#x27;success:&#x27;, data);&#125;).catch(err =&gt; &#123;    console.log(err.msg, err.info);&#125;)// 此外介绍一个方法，并行跑promise es2020有个新方法Promise.allSettledPromise.all([promise1, promise2, ...]).then(res =&gt; &#123;    console.log(res); // 由promise1,promise2正确执行结果组成的数组&#125;).catch(err =&gt; &#123; \tconsole.log(err);&#125;)\nasync/await：\n是对Promise的优化，为Promise服务。一句话：用同步的风格写异步代码。\n基础用法：https://www.zzboy.cn/post/1589841597\n需要注意：\n\nasync/await 就是一对“海尔兄弟”，缺一不可。async声明一个函数（函数返回会处理成一个Promise），函数里面必须要有await，await标识一个需要等一会（异步）的操作。函数内部使用了await，那么该函数就必须用async声明。\nawait、return和return await的陷阱：https://jakearchibald.com/2017/await-vs-return-vs-return-await/\n\n2.9 Modules\n模块化是ES6比较重要的特性，在此之前JS是不支持原生的模块化的，需要通过第三方库实现如RequireJS。\n\n了解更多模块化：JavaScript模块化\n\n模块化由export 和  import 组成，ES6视一个文件为一个模块，文件内通过export对外暴露接口，其他文件通过import引入使用。\nexport：可导出变量、常量和函数\n12345678910111213141516171819// utils/test.js// 单个导出export let name = &#x27;Patrick Jun&#x27;;export const pi = Math.PI;export function whoIAm() &#123;    console.log(&quot;I&#x27;m a FE coder!&quot;);&#125;// 等同于（会将export作为一个对象导出）let name = &#x27;Patrick Jun&#x27;;const pi = Math.PI;const whoIAm = () =&gt; console.log(&quot;I&#x27;m a FE coder!&quot;);export &#123; name, pi, whoIAm &#125;;// this is an object, so.export &#123; name: name, PI: pi, iAm: whoIAm &#125;;\nimport：导入\n123456// home.jsimport &#123; name, pi, whoIAm &#125; from &#x27;./utils/test.js&#x27;;console.log(name, pi);whoIAm();// Patrick Jun 3.141592653589793      main.js:2 // I&#x27;m a FE coder!                    test.js:11  \n\nnode无法直接运行module：https://nodejs.org/dist/latest-v10.x/docs/api/esm.html\n\ndefault：只能有一个\n123456789// math.jsexport function add(a,b) &#123; return a + b; &#125;export function sub(a,b) &#123; return a - b; &#125;export default (a,b) =&gt; a * b;// main.jsimport mult, &#123; add, sub &#125; from &#x27;./math&#x27;;\n三、你可以尝试的新特性\n3.1 对象新方法\n\n\nObject.values(obj): 返回由对象zhogn suozhi 组成的数组；\n\n\nObject.entries(obj): 返回对象的每个属性建和值组成的数组：[[key, value],[key, value]]\n\n\n之前通过Object.keys()，可以获取到对象的所有的key，而要获得value值的时候：\n123456let obj = &#123;id: 1, value: &#x27;123&#x27;, data: &#123;code: &#x27;EC109&#x27;&#125;&#125;;Object.keys(obj); // [&quot;id&quot;, &quot;value&quot;, &quot;data&quot;]Object.keys(obj).forEach((key) =&gt;&#123;    console.log(obj[key]); // [1, &quot;123&quot;, &#123;code: &#x27;EC109&#x27;&#125;]&#125;);\nObject.values()：无需先获取键名，直接可以拿到所有值\n1Object.values(obj); // [1, &quot;123&quot;, &#123;code: &#x27;EC109&#x27;&#125;]\nObject.entries():\n12345Object.entries(obj).forEach(([key, value]) =&gt;&#123;      console.log(key + &quot;: &quot; + value);&#125;)// id: 1// value: 123\n3.2 **\n指数操作符：类似数学的书写方式进行指数计算，可以看做是Math.pow()的简写\n1let a = 7 ** 3;   // a = 343，等同于 a = Math.pow(7, 3)\n3.3  ??\n当我们查询某个属性时，经常会给没有该属性就设置一个默认的值，比如下面两种方式：\n12let c = a ? a : b // 方式1let c = a || b // 方式2\n这两种方式有个明显的弊端，它都会覆盖所有的假值，如(0, ‘’, false)，这些值可能是在某些情况下有效的输入。\n空位合并操作符，用 ?? 表示。如果表达式在??的左侧运算符求值为 undefined 或 null，就返回其右侧默认值。\n12let c = a ?? b;// 等价于let c = a !== undefined &amp;&amp; a !== null ? a : b;\n3.4 padStart/padEnd\n用于在字符串开头或结尾添加填充字符串（ES2017）\n\npadStart(maxLength, [fillString])：从前面补充字符\npadEnd(maxLength, [fillString])：从后面补充字符\n\n1234567891011&#x27;es8&#x27;.padStart(2);          // &#x27;es8&#x27;&#x27;es8&#x27;.padStart(5);          // &#x27;  es8&#x27;&#x27;es8&#x27;.padStart(6, &#x27;woof&#x27;);  // &#x27;wooes8&#x27;&#x27;es8&#x27;.padStart(14, &#x27;wow&#x27;);  // &#x27;wowwowwowwoes8&#x27;&#x27;es8&#x27;.padStart(7, &#x27;0&#x27;);     // &#x27;0000es8&#x27;&#x27;es8&#x27;.padEnd(2);          // &#x27;es8&#x27;&#x27;es8&#x27;.padEnd(5);          // &#x27;es8  &#x27;&#x27;es8&#x27;.padEnd(6, &#x27;woof&#x27;);  // &#x27;es8woo&#x27;&#x27;es8&#x27;.padEnd(14, &#x27;wow&#x27;);  // &#x27;es8wowwowwowwo&#x27;&#x27;es8&#x27;.padEnd(7, &#x27;6&#x27;);     // &#x27;es86666&#x27;\n应用场景：\n1234567891011const dt = new Date();console.log(    `$&#123;dt.getFullYear()+&#x27;&#x27;&#125;-`    +`$&#123;(dt.getMonth()+1+&#x27;&#x27;).padStart(2, &#x27;0&#x27;)&#125;-`    +`$&#123;(dt.getDate()+&#x27;&#x27;).padStart(2, &#x27;0&#x27;)&#125;`);// 2020-08-07let timestamp = &#x27;1596808152&#x27;;timestamp = +String(timestamp).padEnd(13, &#x27;0&#x27;);// 1596808152000\n四、答案\n2.2 question:\n1234567const pageNum = 0, pageSize = 10, user = &#123;uid: 100000, password: &#x27;123123&#x27;&#125;;const params = &#123;    pageNum,    pageSize,    ...user&#125;// &#123;pageNum: 0, pageSize: 10, uid: 100000, password: &quot;123123&quot;&#125;\n2.3 question:  obj1错误，obj2正确。简写方法的属性名总是变量本身作为字符串使用，bind函数本身返回一个函数，从解析器角度来说，这个返回的函数叫什么名字并没有办法确定，而第二种写法，是确定好了fn2\n2.4 question:\n123Uncaught SyntaxError: Unexpected token &#x27;:&#x27;let getTempItem = id =&gt; (&#123; id, name: &quot;Temp&quot; &#125;);\n2.5 question:\n123456&#123;a: 1, b: 2&#125;&#123;0: 2, 1: 3, 2: 4&#125;   // result.0 ????VM37:1 Uncaught TypeError: obj is not iterable    at &lt;anonymous&gt;:1:17\n2.7 question:\n1arr.filter( item =&gt; item.id === 2 );  // [&#123;id: 2&#125;, &#123;id: 2&#125;]\n五、参考资料\n\n\nModern JavaScript, 10 things you should be using, starting today - DEV\n\n\n\n\n盘点ES7、ES8、ES9、ES10新特性\n\n\n\n\nES6，ES7，ES8，ES9，ES10新特性一览\n\n\n\n\nES2020新特性\n\n\n\n\n种草 ES2020 新特性\n\n\n\n\n异步Promise及Async/Await可能最完整入门攻略\n\n\n刘哥金句：给别人讲述知识时可以发现自己掌握的是否牢固透彻，写的过程不断发现自己的不足，然后通过一些方式来解决问题，这也是一种学习过程；当然，给别人分享，也要从学习者的角度出发，考虑他们想要从你的分享中获得什么，还有就是你想表达些什么给他们。\n","thumbnail":"http://img.cdn.1zdz.cn/blog/20200807-cover.jpg","plink":"https://www.zzboy.cn/Learning/75dfaa707e38/"},{"title":"机器学习-数据分析","date":"2020-07-23T08:51:07.000Z","date_formatted":{"ll":"Jul 23, 2020","L":"07/23/2020","MM-DD":"07-23"},"updated":"2021-02-27T13:50:58.759Z","content":"数据分析章节笔记\n\n一、数据分析过程\n\n提出问题\n\n提出的问题与数据保持较高的相关性，让问题更加有趣，并且可以引导出有价值的结论。\n\n数据处理\n\n数据搜集、数据评估、数据清洗（异常值、缺失值、重复值等）\n\n收集数据：UCI, Kaggle, KDDcup, mldata, 银监会, 证监会, 统计局等\n\n\n探索数据\n\n数据可视化等。\n\n得出结论\n\n算法建模、推断统计、数据预测。\n\n结果报告\n\n传达结果的方法有多种：报告、幻灯片、博客帖子、电子邮件、演示文稿等。\n数据分析函数库\nNumpy：是Python语言的一个扩充程序库。支持高级大量的维度数组与矩阵运算。此外也针对数组运算提供大量的数学函数库。运算效率高，是大量机器学习框架的基础库。\nPandas：Python的一个数据分析包。Pandas纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具以及能使我们快速便捷地处理数据的函数和方法。\nMatplotlib：Python的2D绘图库，以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形。通过Matplotlib，开发者可以仅需要几行代码，便可以生成绘图、直方图、功率谱、条形图、错误图、散点图等。\n二、Numpy及Pandas基础\n为什么要使用Numpy和Pandas?\nNumpy（Numerical Python）\n2. 高性能科学计算和数据分析的基础包（由C语言实现）\n3. 提供多维数组对象，具有矢量运算能力\nPandas\n\n基于Numpy，提供高性能的矩阵运算\n具有更多方便矩阵计算中使用的方法\n\n在jupyter中，可以在每段代码前加一句，可以统计该段代码的执行时间：\n1%%timeit\n2.1 Numpy一维数组\n一维数组\nPandas：Series\nNumpy：ndarray\nndarray与Python List的相似处\n通过位置访问元素\n1l[0]、l[2:5]、l[:3]、l[2:]\n循环\n12for item in l:      xxx\nndarray与Python List的不同\n\nPython List元素可以任意类型组合、ndarray元素类型必须相同（不相同时Numpy会自动做类型转换）\nndarray有mean()、std()等更多的跟数学计算相关的内置函数\nndarray可以更方便的对多维度数组进行运算\n\n2.2 向量与标量计算\n向量：用一个ndarray表示向量\n计算规则：标量会“扩散”到向量中，与向量的每个元素进行计算。\n2.3 向量运算\n对应位置上的元素进行相应操作\n支持运算：\n\n\n+, -, *, /, **(求幂)\n\n\n&amp;, | , ~：\n当boolean时，直接与或非；\n当为整数时，是按位做与或非操作（~3 = ~000...11 = 111...00）；\n\n\n&lt;, &lt;=, &gt;, &gt;=, !=, ==：操作后形成的向量，有boolean组成\n\n\n2.4 Numpy索引数组\n定义\n123a = np.array([1, 2, 3])b = np.array([True, True, False])a[b]\n结果是[1, 2]，b即为索引数组。\n2.5 ndarray += 操作\n+= 原地操作\n+ 非原地操作\n1234567891011a = np.array([1, 2, 3])b = a# += 原地操作  b = [2, 3, 4]   ab同时指向原地址a += np.array([1,1,1])print(b) # + 非原地操作 b = [1, 2, 3]   a产生新的地址a = a + np.array([1,1,1])print(b)    \n切片操作时\n\n\n对于Numpy array切片的修改，是原地操作，会影响原有array。\n\n\n对于Python List切片的修改，是非原地操作，不会影响原有List。\n\n\n12345a = np.array([1, 2, 3, 4])b = a[:2]b[0] = -10print(a)# [-10, 2, 3, 4]\n2.6 Numpy中的随机数\n文档\nhttps://docs.scipy.org/doc/numpy/reference/routines.random.html​\nrandom.rand()\n根据给定维度生成[0,1)之间的数据\nrandom.randn()\n根据给定维度（不给维度时为单个数），产生符合标准正态分布的随机数\nrandom.normal()\n产生可定义均值和标准差的正态分布随机数\nrandom.randint()\n返回给定维度的随机整数\nrandom.random()、random.random_sample()\n返回给定维度的[0, 1)之间的随机数\nrandom.choice()\n从给定的一维数组中生成随机数\nrandom.seed()\n当设置相同的seed，每次生成的随机数相同。如果不设置seed，则每次会生成不同的随机数\n2.7 Pandas Series\nPandas Series相对于Numpy ndarray\n\n\n更多的函数\ndescribe()…\n\n\n相似\n下标方式访问：s[10]、s[3:10]…\nfor循环：for item in s\n向量计算：+、-、*、/、…\n科学函数：mean、sum、max …\n比Python List快\n\n\n2.8 Series索引\niloc 通过位置访问Series元素\nloc 通过索引访问Series元素\nidxmax 获取Series中最大元素的索引\n2.9 Series向量计算\n计算操作按照索引进行对应计算，如果两方都没有共同索引，计算结果时NaN\n2.10 Series apply\na.apply(fn)；传入指定函数，series会将每一元素传入函数fn并返回，如果没有返回则结果是NaN\n2.11 缺失值填充\ndropna\n将NaN元素去除。\n1(s1+s2).dropna(0)\nfillna\n将NaN元素替换\n1(s1+s2).fillna(0)\nadd以及fill_value\n使用自定义填充值填充最终结果。\n1s1.add(s2, fill_value=0)  #s2中不存在的索引用0替代\n2.12 Pandas绘图\n1234import pandas as pdimport numpy as nps = pd.Series([1,2,3,4], index=[&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;], name=&#x27;test&#x27;)# s = pd.Series(np.random.randn(20), name=&#x27;np&#x27;)\n12s.plot(kind=&#x27;line&#x27;)  #折线图s.plot(kind=&#x27;bar&#x27;)   #柱形图\n柱形图：bar\n1s.plot.bar()\n直方图：hist\n1s.plot.hist()\n箱线图：box\n1s.plot.box()\n密度图：kde\n1s.plot.kde()\n区域图：area\n1s.plot.area()\n饼图：pie\n1s.plot.pie(figsize=(6,6))\n2.13 Numpy二维数组\n二维数组的表示方法\nPython原生：列表的列表\nNumpy：ndarray\nPandas：DataFrame\n二维ndarray与Python List\n\nndarray性能更好\nndarray有mean()、std()、sum()等更多的跟数学计算相关的内置函数，作用于整个数组\n访问语法差别：a[1,2]（Numpy ndarray）、a[1][2]（Python List）\n\n12a[0,:] #第0行全部a[0, 0:2] #第0行0,1列\nNumpy轴\naxis\n0：按列计算\n1：按行计算\n1a.mean(axis=1)  #计算每一行的平均数\n2.14 Pandas二维数组 DataFrame\nndarray当加入行列标识时，会导致数据无法计算。\n创建方法\n123df_1 = pd.DataFrame(&#123;&#x27;A&#x27;: [0, 1, 2], &#x27;B&#x27;: [3, 4, 5]&#125;)df_2 = pd.DataFrame([[0, 1, 2], [3, 4, 5]], \t\t\t\t                     columns=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;], index=[1, 2])\n函数\nmean([axis])、sum、max、min …\nstd(ddof=0)\nDataFrame的std方法中，ddof默认值为1，计算的是考虑了贝塞尔校正之后的标准差。\n取某行\nloc[index]：根据设置的索引、iloc[]：根据序号\n取某列\n[xxx]\n取行和列的结果就是一个series类型\n转换成Numpy array\nvalues\n2.15 CSV到DataFrame\ndf = pd.read_csv(‘path’)\n将csv文件加载为DataFrame。\n读取行loc，读取列[]\ndf.describe()\n获取DataFrame中数据的描述信息，比如均值、最大最小值等。\n2.16 Pandas的轴\n在使用DataFrame的计算方法时，可以传入参数按轴计算\n按列计算\naxis=0 或 ‘index’\n按行计算\naxis=1 或 ‘columns’\ndf.mean(axis = 1)\n2.17 DataFrame向量计算\n计算操作按照索引进行对应计算，如果两方都没有共同索引，计算结果时NaN\n默认按照相同key对应计算，如果没有指定index索引，数据挨个对应计算，指定了则按照指定index计算\n行整体移动\ndf.shift(1)  整体向后移动一位\n2.18 DataFrame的applymap\n将DataFrame的每个元素经过函数运算之后转换成新的元素。\n使用方法和Series的apply相同\n可以直接在applymap写入匿名函数lamda\n2.19 DataFrame的apply\n","plink":"https://www.zzboy.cn/Learning/9868fdc85e89/"},{"title":"机器学习-数学知识","date":"2020-07-10T14:32:52.000Z","date_formatted":{"ll":"Jul 10, 2020","L":"07/10/2020","MM-DD":"07-10"},"updated":"2021-02-27T13:50:55.143Z","content":"统计学基础、线代基础、高数基础复习\n\n一、统计\n\n\n概率、频率\n\n\n均值、中位数、众数\n\n\n正太分布（均值=中位数=众数）\n右偏分布（右侧拖尾：众数&lt;中位数&lt;均值）\n左偏分布（左侧拖尾：均值&lt;中位数&lt;众数）\n\n四分数、四分位距、箱线图\n\n(n+1)/4    2(n+1)/4    3(n+1)/4\n四分位距（四分差）：IQR = Q3 - Q1\n异常值（箱线图内限）：OUTLIER &lt; Q1 - 1.5IQR    OUTLIER &gt; Q3 + 1.5IQR\n箱线图外限：Q1 - 3IQR       Q1 + 3IQR  在内限和外限之间的值称：温和异常值\n在外限之外的值称：极端异常值\n\n离均差、绝对偏差、平均偏差、平均绝对偏差、平方偏差、方差、标准差\n\n离均差Deviation：个体对群体平均值的距离\n平均偏差Average Deviation：离均差求平均 约等于 0\n绝对偏差Absolute Deviation：离均差的绝对值\n平均绝对偏差Average Absolute Deviation：绝对偏差之和除以样本数量\n平方偏差：离均差的平方\n方差Variance：样本平方偏差之后除以样本数量\n标准差Standard Deviation：方差开根号\n正太分布中：众数中位数平均数都位于分布中心，数列中68%的数据与均值的偏差不超过一个标准差，95.44%的数据与均值不超过两个标准差，99%数据与均值不超过3个标准差\n\n期望 E\n\nE(a+b) = E(a) + E(b)\n方差：Var(x) = E[(x - E(x))2] = E(x2) - E2(x)\nVar(ax + b) = a2Var(x)\n\n样本方差与贝塞尔校正\n\n样本方差小于整体方差\n样本方差：平均偏差和 除以 样本数量减一\n贝塞尔校正：求样本方差时，平方偏差和除以样本数量减1，而不是除以样本数量，称为贝塞尔校正。\n\n条件概率与贝叶斯定理\n\n（蒙提霍尔悖论Monty Hall：Let’s make a deal）\n条件概率：值事件A在另外一个事件B已经发生条件下的发生概率\n\n\n离散分布、连续分布\n\n离散分布：比努力分布、二项分布、泊松分布\n连续分布：\n\n标准正太分布\n大数定律、中心极限定律\n\n大数定律：在试验不变的条件下，重复试验多次，随机事件的频率近似于它的概率。（切比雪夫大数定律，伯努利大数定律、辛钦大数定律）\n中心极限定律：随机变量序列部分和分布渐近于正态分布。\n\n点估计与区间估计\n\n点估计：用样本统计量来估计总体参数。\n区间估计：在点估计的基础上，给出总体参数估计的一个区间范围，该区间通常由样本统计量加减估计误差得到。\n置信区间、置信水平、显著性水平\n\n假设检验\n\n数理统计学中根据一定假设条件由样本推断总体的一种方法。\n具体作法是：根据问题的需要对所研究的总体作某种假设，记作H0；选取合适的统计量，这个统计量的选取要使得在假设H0成立时，其分布为已知；由实测的样本，计算出统计量的值，并根据预先给定的显著性水平进行检验，作出拒绝或接受假设H0的判断。\n常用的假设检验方法有u—检验法、t检验法、χ2检验法(卡方检验)、F—检验法，秩和检验等。\n二、线性代数\n\n向量、标量\n向量的基本运算\n\n向量加减法：直角坐标系中向量的加减就是对应坐标分量的加减。\n向量的数乘：直角坐标系中向量的数乘就是向量坐标的分量分别乘该数。\n\n单位向量、零向量\n\n单位向量：模长为1的向量\n零向量：模长为0，方向是任意的\n\n向量内积、向量垂直\n\n向量内积：两个向量的内积为向量的模长的乘积再乘两个向量夹角的余弦值\n向量垂直：两个向量内积为0，则两个向量是相互垂直的\n\n向量投影\n\n设两个非零向量a与b的夹角为θ，则将|b|·cosθ 叫做向量b在向量a方向上的投影或称标投影\n\nL-P Norm\n\nL-1 Norm：\nL-2 Norm：\nL-p Norm：\n\n曼哈顿距离和欧式距离\n\n曼哈顿距离：两点在南北方向上的距离加在东西方向上的距离。在坐标系中即为横轴和纵轴方向落差之和。也即L-1 Norm\n欧式距离：在m维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。在二维和三维空间中的欧氏距离就是两点之间的实际距离。使用坐标表示，即为横轴和纵轴方向落差的平方和再开平方根。也即L-2 Norm\n\nL-0 Norm和L-infinity Norm\n\nL-0 Norm：向量中非0元素的个数。\nL-infinity Norm：等于向量中最大元素的绝对值。\n\n矩阵\n\n矩阵：按照长方阵列排列的复数或实数集合。\n（1）行矩阵：只有一行的矩阵。\n（2）列矩阵：只有一列的矩阵。\n（3）方阵：行数和列数分别相等的矩阵。\n（4）单位矩阵：对角线上的元素为1，其它元素为0的矩阵。\n（5）对角矩阵：对角线上的元素不为0，其它元素为0的矩阵。\n（6）同型矩阵：两个矩阵行数列数分别相等。\n矩阵加法：相同&quot;形状&quot;的矩阵对应元素做加减法\n矩阵的数乘：一个数乘一个矩阵，只需要将矩阵的所有元素与这个数相乘\n矩阵的乘法：\n\n第一个矩阵的列数等于第二个矩阵的行数，两个矩阵才可以相乘。矩阵的乘法不满足交换律。\n\n矩阵的转置\n\n矩阵中的行列互换。\n矩阵转置的转置还为矩阵本身。\n矩阵相加的转置等于矩阵分别转置之后再相加。\n标量乘矩阵的转置等于矩阵先转置后乘标量。\n两个矩阵相乘的转置等于第二个矩阵的转置左乘第一个矩阵的转置。\n\n逆矩阵\n\n矩阵的逆：设A是数域上的一个n阶方阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E（E是单位矩阵），则称B是A的逆矩阵，而A则被称为可逆矩阵。\n三、数学\n\n函数\n\n函数：给定一个数集A，假设其中的元素为x，现对A中的元素x施加对应的法则f，记作 f(x)，得到另一个数集B。假设B中的元素为y，则y与x之间的等量关系可以用 y=f(x)表示。我们把这个关系式就叫做函数关系式，简称函数\n常数函数：\n值不发生改变（常数）的函数\n幂函数：\n形如 y = x^a 的函数，即以底数为自变量，幂为因变量，指数为常数的函数称为幂函数，图像必经过(0，0），（1，1）点。当x&gt;1时，指数大的图像总在指数小的图像上方\n指数函数：\n形如 y=a^x 的函数，a为常数，且 a&gt;0 , a不等于1。图像必经过（0，1) 点。a&gt;1为增函数，0&lt;a&lt;1 为减函数\n对数函数：\n形如 y = logax 的函数，a&gt;0 ，且a不等于1。以真数作为自变量，指数部分作为因变量的函数。对数函数必经过（1，0）点。a&gt;1为增函数，0&lt;a&lt;1为减函数\n三角函数：\n以角度或弧度为自变量，角度对应任意角终边与单位圆交点坐标或其比值为因变量的函数。常见的三角函数有：正弦函数、余弦函数、正切函数、余切函数、正割函数、余割函数。满足六边形法则\n反三角函数：\n反正弦arcsinx，反余弦arccosx，反正切arctanx，反余切arccotx，反正割arcsecx，反余割arccscx等函数的统称，各自表示其对应的角度\n损失函数：\n在统计学、统计决策理论和经济学中，损失函数是指一种将一个事件（在一个样本空间中的元素）映射到一个表达与其事件相关的经济成本或机会成本的实数上的一种函数。例如0-1损失函数，绝对损失函数等\n\n导数\n\n等价无穷小、求导（定义法）、导数的四则运算\n(u+v)‘=u’+v’\n(u-v)‘=u’-v’\n(uv)‘=u’v+uv’ （前导后不导 + 后导前不导）\n(u/v)‘=(u’v-uv’)/v^2\n复合函数求导：外导内不导 * 内导\n\n函数的凹凸性\n罗尔微分中值定理\n\n如果函数 f(x) 满足以下条件：\n（1）在闭区间 [a,b] 上连续；\n（2）在开区间 (a,b) 内可导；\n（3）f(a)=f(b)，\n则至少存在一个 ξ∈(a,b)，使得 f’(ξ)=0。\n\n拉格朗日微分中值定理\n\n如果函数 f(x) 满足：\n（1）在闭区间[a,b]上连续；\n（2）在开区间(a,b)内可导；\n那么在开区间(a,b)内至少有一点ξ使等式 f(b) - f(a) = f’(ξ) (b-a) 成立。\n推论1：f(x)在闭区间[a,b]连续，开区间(a,b)可导， 若f’(x)=0，则f(x)=c 是常函数\n推论2：f(x)、g(x)在闭区间[a,b]连续，开区间(a,b)可导，若f’(x)=g’(x)，则f(x)=g(x)+c  c是常函数\n\n柯西微分中值定理\n\n设函数 f(x) 满足：\n（1）在闭区间[a,b]上连续；\n（2）在开区间(a,b)内可导；\n（3）g(x)不等于0；\n那么在开区间(a,b)内至少有一点ξ使等式 [f(b)-f(a)] / [g(b) - g(a)] = f’(ξ) / g’(ξ) 成立。\n\n泰勒公式（重要）\n\n若函数 f(x) 在包含x0的某个闭区间[a,b]上具有n阶导数，且在开区间(a,b)上具有(n+1)阶导数，则对闭区间[a,b]上任意一点x，下式成立：\nf(x) = f(x0) / 0! + f’(x0) / 1! * (x-x0) + f’'(x0) / 2! * (x-x0)^2 + … + f^(n)(x0) / n! * (x-x0)^n + Rn(x)\n其中，f^(n)表示f(x)的n阶导数，等号后的多项式称为函数f(x)在x0处的泰勒展开式，剩余的Rn(x)是泰勒公式的余项，是(x-x0)n的高阶无穷小。\n","plink":"https://www.zzboy.cn/Learning/1cff8a542631/"},{"title":"机器学习-Python基础","date":"2020-07-09T10:11:49.000Z","date_formatted":{"ll":"Jul 9, 2020","L":"07/09/2020","MM-DD":"07-09"},"updated":"2021-02-27T13:50:52.011Z","content":"此篇文章是我在学完一章节后再回顾之前的课程进行的总结笔记\n\n一、环境及基础语法\n1.1 环境准备\n\nAnaconda\n\nhttps://www.continuum.io/downloads\n包含大量专门针对数据科学的库和软件分发版本\n\nNumpy、Pandas、Matplotlib…\n\n\n可设置不同环境，在不同的Python版本中切换\n自带数据工作者常用的spyder以及jupyter等工具\n\n\n其他\n\nPython下载页：https://www.python.org/downloads/\nIDE：pycharm https://www.jetbrains.com/pycharm/\nEditor: Atom https://atom.io/\n\n\n\n安装Anaconda\nAnaconda 可用于 Windows、Mac OS X 和 Linux。安装程序链接： https://www.anaconda.com/download/ 。\n如果计算机上已经安装了 Python，这不会有任何影响。Anaconda使用自己附带的Python。\n选择 Python 3.6 版本（你也可以根据具体的需要选择 Python 2 的版本）。如果是 64 位操作系统，则选择 64 位安装程序，否则选择 32 位安装程序。\n完成安装后，打开Anaconda Prompt，可以进入Anaconda命令行模式。在其中执行 conda list，可以看到随Anaconda安装的包及其版本。\n安装完成之后的主要应用程序：\nAnaconda Navigator：用于管理环境和包的 GUI\nAnaconda Prompt 终端：管理环境和包的命令行工具\nSpyder：面向科学开发的 IDE\n在安装完成之后，可以通过如下命令对包进行更新：\n1conda upgrade --all\n管理包\nAnaconda安装完成之后，可以通过命令conda install安装所需要的包。比如：\n1conda install numpy\n当需要安装多个包时，可以执行类似这样的命令：\n1conda install numpy pandas\nPython的不同包之间可能存在依赖关系，通过conda安装过程中，它会为我们解决所有依赖问题，将要安装的包所依赖的其它包也一并进行下载和安装。\n如果需要指定安装某个特定版本的包，可以执行类似如下命令：\n1conda install numpy=1.10\n可以使用命令conda remove &lt;package_name&gt;方式删除指定的包。\nAnaconda虚拟环境\nAnaconda可以通过虚拟环境来隔离不同项目对于包版本的不同需求。可以通过命令conda create -n env_name packages 来创建虚拟环境。比如如下命令创建了一个名为env1的虚拟环境，并在其中安装numpy：\n1conda create -n env1 numpy\n创建环境时，可以指定环境中使用特定版本的Python，比如，如下命令创建了一个使用Python2的名为py2的虚拟环境：\n1conda create -n py2 python=2\n列出和进入环境\n可用通过conda env list 命令列出当前机器上已经创建的虚拟环境：\n\n在MacOS/Linux上，执行source activate env_name命令，即可进入名为env_name的虚拟环境中。在Windows上，需要执行的命令是activate env_name。当需要离开虚拟环境时，MacOS/Linux中执行source deactivate，在Windows上，执行deactivate。\n当我们在虚拟环境当中，同样也可以使用conda install命令来安装虚拟环境中所需要的软件包。\n删除环境\n使用以下命令，删除名为env_name的虚拟环境：\n1conda env remove -n env_name\nJupyter notebook\nJupyter notebook 是一种 Web 应用，能让用户将说明文本、数学方程、代码和可视化内容全部组合到一个易于共享的文档中。\nJupyter notebook 已迅速成为数据分析、机器学习等领域的工作人员在进行数据清理和探索时所需的必备工具。notebook 能将文档及代码等一切相关资料集中到一处，让用户一目了然。\nJupyter notebook 源自 IPython，是一种交互式 shell，与普通的 Python shell 相似。最初，notebook 的工作方式是，将来自 Web 应用（你在浏览器中看到的 notebook）的消息发送给 IPython 内核（在后台运行的 IPython 应用程序）。内核执行代码，然后将结果发送回 notebook。IPython经过技术演进之后，将内核分离，成为现在的架构模式：\n\n架构的核心是 notebook server。用户通过浏览器连接到该服务器。用户在 Web 应用中编写的代码通过浏览器发送给notebook server之后，notebook server将代码发送给内核，内核运行并将结果发送回notebook server。最后，输出返回给浏览器并展示给用户。\n保存 notebook 时，所有内容将生成一个 JSON 文件（文件扩展名为 .ipynb）写入到notebook server中。\n在 conda 环境中，执行如下命令即可安装jupyter notebook：\n1conda install jupyter notebook\n在Anaconda字符终端输入jupyter notebook，即可启动notebook server。服务器会在此命令被执行的目录中启动，任何 notebook 文件都会保存在该目录下。\n运行此命令时（请自己试一下！），服务器主页会在浏览器中打开。默认情况下，notebook server的访问地址是http://localhost:8888，通过当前机器上所带的浏览器访问该地址就可以看到Server的主页面。\n如果同时启动了另一个 notebook server，新服务器会尝试使用端口8888，但由于此端口已被占用，新Server会在端口8889上运行。这样，可以通过http://localhost:8889连接到新服务器。\nJupyter主页面类似以下所示：\n\n在右侧，可以点击“New”，创建新的 notebook、文本文件、文件夹或终端。“Notebooks”下的列表显示了已安装的内核，这里可能是Python2/3或者是其他如Scala这样的语言。\n顶部的选项卡是 Files、Running和 Cluster。Files显示当前目录中的所有文件和文件夹。点击 Running选项卡会列出所有正在运行的 notebook。可以在该选项卡中管理这些 notebook。\nClusters选项卡用处不多，我们可以先不理会。\n通过在服务器主页上选中 notebook 旁边的复选框，然后点击“Shutdown”，就可以关闭各个 notebook。\n\n通过在终端中按 Ctrl + C（Mac及Linux上是按两次Ctrl + C），可以关闭整个服务器。这会立即关闭所有运行中的 notebook，所有未保存的内容会丢失。\n1.2 基础语法\n缩进\n规则\n\nPython使用缩进来标识代码块。\n缩进空格数可变，同一代码块的语句必须包含相同缩进。\n使用反斜杠连接多行。\n\n习惯\n\n在功能相差较大的代码块之间通常用空行分割。\n并不影响代码执行。\n\n注释\n单行注释\n以#开头，只注释#开头的一行。\n多行注释\n‘’’ 注释内容’‘’ 或者&quot;““注释内容””&quot;，可以对多行内容整体进行注释。\n变量\n变量的定义\n在Python中，变量指向各种类型值的名字，当用到这个类型的值时，直接使用变量即可，不需要再写具体的值。\n格式：变量名 = 数值\nage = 23\nmoney = 13\nsum = age + money\ngreed = “Hello”\nprint(greed)\n变量的类型不需要显示指定，python解释器会自动判断数据类型，可以 把任意数据类型赋值给变量。\n变量名称命名简洁明了，见名知意\n使用type(变量)查看变量类型\n标识符\n在Python程序开发过程中，自定义的一些符号、名称\n\n由字母、数字、下划线（_）组成，不能以数字开头\n标识符区分大小写\n\n命名规则\n\n\n见名知意，如：name\n\n\n驼峰命名法，如：类名（UserInfo）、异常名（ValueError）等\n\n\n小写字符+下划线，如：变量名（user_name）、函数名(get_name)\n\n\n不能够使用关键字\n\n\n关键字\n\n在Python内部具有特殊功能的标识符\n通过keyword模块的kwlist函数查看\n\n运算符\n主要运算符\n\n运算符的优先级\n\n输入输出\n输入\n\n读取键盘输入\n\n12str = input(&quot;请输入：&quot;) print (&quot;你输入的内容是: &quot;, str) \n\n文件输入\n\n12345f = open(&quot;/tmp/foo.txt&quot;, &quot;r&quot;) str = f.read()  #或按行读取str = f.readline() print(str) # 关闭打开的文件 f.close() \n\nwith操作\n在代码块中包含对于文件的操作，而省掉显示调用close等资源处理的收尾工作。\n\n12345with open(&quot;/tmp/filename&quot;, &quot;r&quot;) as f:\tstr = f.read()    print(str)    # 关闭打开的文件    f.close()\n输出\n\n格式化输出\n\n123import math print(&#x27;常量 PI 的值近似为：%5.3f。&#x27; % math.pi) print(&#x27;it is %5.3f %5.4f&#x27; %(math.pi,math.pi)) \n\n\n常用格式化符号\n示例：print(“你输入的名字是：%s”%name)\n\n\n\n写文件\n\n\n1234567# 打开一个文件 f = open(&quot;/tmp/foo.txt&quot;, &quot;w&quot;) num = f.write( &quot;这是我写的第一行。\\n第二行内容\\n&quot; ) print(num) # 关闭打开的文件 f.close()\n二、控制流\n三、基本数据类型和数据结构\nPython数据类型\n\n类型转换\nPython数据可以通过 类型名(变量名) 的方式进行变量类型的转换操作，主要的转换操作包括：\n\n3.1 字符串\n\n字符串变量定义\n\n1s = &quot;hello&quot; 或者&#x27;hello&#x27;\n\n组合字符串的方式\n“+”号 格式化符号\n通过下标获取指定位置字符\n\n1string_name[index]\n\n切片\n\n1string_name[起始:结束:步长]\n\n字符串方法文档\nhttps://docs.python.org/3/library/stdtypes.html#string-methods\n\n3.2 列表 []\n列表定义\n1name_list &#x3D; [&quot;zhangsan&quot;,&quot;lisi&quot;,&quot;wangwu&quot;]\n顺序存储，可通过下标获取内部元素\n12name_list[0]name_list[1] \n内容可变，可通过下标修改元素值\n1name_list[0] &#x3D; &quot;xiaobai&quot;\nfor方式遍历\n12for item in name_list:\tprint(item)\n列表修改\n\n\n添加元素\nappend()/insert()\n\n\n\n\n\n组合两个列表生成新的列表\n\n\nextend​\n向调用它的列表中添加另外一个列表的元素\n\n\n删除元素\ndel()/pop()/remove()\n\n\napend、+、extend的区别\n\n\nappend：在列表的末尾添加元素，如果使用append添加一个列表，则会把列表整体作为一个元素添加到列表末尾。\n\n\nextend：向调用它的列表中追加另外一个列表中的元素，调用的列表内容会发生变化。\n\n\n+：将两个列表中的元素组合，生成一个新的列表，原来的两个列表内容不变。\n\n\n\n\n切片和排序\n\n切片\n格式：[start:end:step]\n结果中包含start而不包含end\n使用in/not in判断元素在列表中是否存在\n列表内元素重排序\nsort()\n列表内容倒置\nreverse()\n统计列表内指定元素个数\ncount()\n\n3.3 元组 ()\n3.4 集合 set() {,}\n3.5 字典 {}\n3.6 函数\n四、Python高级知识\n五、数据可视化\n六、一些常用函数\n","plink":"https://www.zzboy.cn/Learning/6a8dabb915d1/"},{"title":"毕业设计-“跑鸭”微信小程序","date":"2020-06-17T01:13:40.000Z","date_formatted":{"ll":"Jun 17, 2020","L":"06/17/2020","MM-DD":"06-17"},"updated":"2021-02-27T13:50:49.011Z","content":"这是我的毕业设计：一款基于校园运动的社交小程序\n功能：跑步 + “仿朋友圈” + 在线活动\n技术栈：前端 JS / Less / Vant-Weapp / Iview-Weapp、后端 PHP7 / Laravel / MySQL\n\n一、写前BB\n毕业设计我有两个想法，另外一个是人生经验树想法，难点在于UI的设计，通过技术调研发现echarts是无法实现的，只能通过D3，我对于交互美化这块在指定时间内能完成心里没有个底，所以放弃了那个想法。下面是这个想法的具体内容：\n\n点击查看我另一个想法\n人一生会经历很多选择，不同人选择走不同的路因此有了不同的人生。\n我想做一个大家可以共同参与编辑的一个颗人生经验树，以某个时间点为根，按照自己选择的方向建立分支；\n在支点填下自己选择的理由，在枝丫上记录之后的学习经验或者失败经验；\n之后在下一次新的选择时，就在这个枝丫上建立分支，依次细分下去；\n这样可以为以后有做出同样选择的人参考，看看部分成功人士的每一次选择以及做法，也可以记录自己的成长，导出自传。\n程序分三大块：世界经验树、个人经历时间轴、个人中心\n（1）世界经验树(类似地图设计)：\n一棵大树，展现部分枝丫，枝丫尖展现点赞和评论较多的人名。可以放大查看，即展现视区点赞较高的人；\n个人快速定位，可进行编辑分支；\n顶部关键词搜索，查看想看的人的人生轨迹；\n（2）个人经历时间轴：供自己参考个人历史，让自己时常反思\n（3）个人中心：设置\n难点：UI交互、数据库设计\n\n最终选择的这个想法是在我大二的时候就有的了，就是做一款跑步程序，难点在于任务量太多（事实证明，工作量确实大，大概花了3个月实现，期间还有一个小姐姐帮我分担了两个页面）。\n二、功能设计\n”跑鸭“微信小程序的核心功能就是：跑步+社交+活动，详细划分如下：\n（1）跑步（首屏）：当前位置地图、排行榜（周榜、月榜）、运动路径、实时数据（里程、配速）、随机一言。\n（2）动态圈子：打卡分享、发布分享、热门推荐、点赞评论、消息通知。\n（3）活动广场：线上活动（报名、完赛条件、奖励）、跑步教程。\n（4）个人中心：运动管理、动态管理、设置（通用设置、隐私设置）、勋章墙、等级称号、个人主页、资料编辑。\n三、数据库设计\n根据功能分析，一共规划出11个实体，形成E-R图：\n\n由E-R图，共转换成16张表（每张表均含有创建时间和更新时间，以下没有列出）：\n\n展开查看详细列表\n（1）用户表（r_users）：（编号（主键）,微信openid，昵称，校区，性别，头像，职业，个人签名）；\n（2）运动记录表（r_runs）：（编号（主键），用户编号（外键），里程，卡路里，最高配速，最低配速，平均配速，开始时间，结束时间，运动时间，起点维度，起点经度，终点经度，终点维度，分享）；\n（3）称号表（r_honors）：（编号（主键），称号描述，称号名称）；\n（4）勋章表（r_medals）：（编号（主键），标识符，类型，名称，简介，图标）；\n（5）动态表（r_moments）：（编号（主键），用户编号（外键），动态内容，动态类型，动态位置，位置经度，位置维度）；\n（6）活动表（r_activitys）：（编号（主键），勋章编号（外键），封面图编号（外键），标题，简述，活动内容，达成条件，截止时间）；\n（7）教程表（r_courses）：（编号（主键），标题，内容）；\n（8）隐私设置表（r_settings）：（用户编号（外键），职业设置，校区设置，运动设置）；\n（9）系统信息表（r_notices）：（编号（主键），发出者编号（外键），接收者编号（外键），类型，已读，内容）；\n（10）图片表（images）：（编号（主键），标识符，标识编号，原名称，存储名称，后缀，图片格式，大小，宽，高，压缩宽，压缩高，原图地址，压缩图地址，压缩错误码）；\n（11）称号获得表（link_u_hs）：（用户编号（外键），称号编号（外键））；\n（12）勋章获得表（link_u_ms）：（编号（主键），用户编号（外键），勋章编号（外键））；\n（13）点赞表（link_u_like_ms）：（动态编号（外键），用户编号（外键））；\n（14）评论表（comments）：（编号（主键），用户编号（外键），动态编号（外键），评论内容）；\n（15）活动参加表（link_u_as）：（用户编号（外键），活动编号（外键），完成）；\n（16）每日一言（hitokotos）：（一言编号（主键），类型，来源，作者）；\n\n数据模型图：\n\n四、开发前的准备\n4.1 技术调研\n前端：\n没商量，使用微信小程序开发（因为我要为我的其他项目去深入学习小程序开发），但是UI框架上从Vant、Wux和iView中最终选择了Vant为主（因为它比较规范）。\n\n但是可能最开始没有说清楚，那个小姐姐最开始使用的iView开发，为了减少任务量，使用的iView那块继续保持着，没有替换成Vant\n\n后端：\n后端我考虑了node+MongoDB、Java+MySQL、PHP+MySQL三种。\n我首先考虑的是node开发，先去考察了node的框架：express、koa、koa2、egg，最终选择了koa2学习。\n我首先看了一遍廖雪峰老师写的node文章，然后简单编写了一个请求的demo并成功部署到服务器，发现它的编写需要导入很多库，而且我不太清楚有哪些库，为了加一个token验证的库，我去koa的github上找了半天，也没有实现，所以放弃了。\n然后想了想Java，其实之前会的，但是我刚开始配置Java环境和配置Spring时就直接放弃了，配置太难搞了！！\n最后还是选择PHP吧，几乎不需要配置，然后框架使用的是大二一直没有学会的Laravel，我按照Laravel官网的方法，直接安装了composer，使用最新的Laravel版本，学习是看的视频，视频讲了个大概，更多的还是看的官网的文档（看不懂的时候才用的翻译）。\nAPI管理：\nAPI管理是我在拓尔思实习的时候了解到一个YApi平台，公司那时还没有正式全面使用，前端这边就提了一下，但是我却下来认真研究了一下，并自己部署了一个，已经投入到自己的项目管理，给学弟托管大创接口。\n产品原型：\n产品原型就相当于是开发前“打草稿”，我使用的是墨刀，主要是开发前期，对程序页面进行了大致绘制，防止在开发过程中太过随意发挥了。\n开发手册：\n开发手册其实就是打算用来记录一些前公用方法、公共组件等，我使用的是语雀，其实就是一个在线协作文档。（期间也就最开始记录了一下公共组件、js模块，后来就没怎么记录了，主要是没时间，其实那些公共的方法模块一时还能记住）\n4.2 规范制定\n前端：\n（1）凡是能多次使用的方法均需放在app.js里，或者整理成模块放在utils目录下；\n（2）每个方法必须要有注释；\n（3）凡是能重复的使用的页面模块，均需写成组件，保存在components目录下，组件目录命名xxx-xxx，组件文件命名为index；\n（4）git提交：完成某个功能点，或者修复某个问题需要commit一次；\n后端：\n（1）接口路由按模块分组，api/run/a， api/run/b；\n（2）git提交：完成一个接口提交一次，调整某些功能提交一次；\n（3）接口返回格式json：\n12345&#123;  &#x27;isSuccess&#x27;: true,  &#x27;msg&#x27;: &#x27;操作成功&#x27;,  &#x27;data&#x27;: &#123;&#125;&#125;\n（4）接口tag设置：\n\n未设置：还在开发中\n已部署：已同步至开发环境，前端可用\n已上线：同步至正式环境，测试和演示可用（前端也可用）\n暂不实现：因种种原因，暂不实现或后期实现\n\n4.3 工具和环境\n环境：\nPHP7.2，MySQL-8.0.19\n前端：\n\n\n微信开发者工具：用于运行和调试程序\n\n\nVS code：小程序编码\n\n安装EasyLess插件，编写less，导出后缀设置为.wxss\n安装wechat-snippet插件，微信小程序代码快捷插入\n\n\n\n后端：\n\n\nVS code：PHP编码\n\n安装laravel-goto-controller，快速跳转到控制器\n安装Laravel Snippets，语法提示\n安装Laravel Artisan，运行artisan命令\n\n\n\nNavicat Premium 15：数据库可视化管理，数据模型，激活\n\n\n绘图：\n\nVisio 2016：绘制E-R图，流程图\nXmind8：功能梳理\n\n论文：\n\nWord 2016\n\n五、项目代码介绍\n5.1 前端\n5.1.1 仓库地址\nhttps://github.com/Patrick-Jun/PopRun\n5.1.2 目录结构\n1234567891011121314151617181920212223242526├─.vscode           #VS Code配置，含&#x27;EasyLess&#x27;插件配置├─components        #自定义公共组件├─dist              #iVew-Weapp库├─imgs              #图标、默认图片├─pages│  ├─run            #跑步（首页）│  │  └─sharePage        #分享到动态圈子页│  ├─moments        #动态圈子│  │  ├─messages         #消息盒子│  │  └─newMoment        #新建动态│  ├─pub            #活动广场│  │  ├─blockDetail      #教程详细│  │  ├─blockMore        #教程列表│  │  ├─listDetail       #活动详细│  │  └─listMore         #活动列表│  └─user           #个人中心│      ├─edit            #个人资料编辑│      ├─modals          #勋章墙│      ├─myMoments       #我的动态│      ├─myRuns          #我的运动│      ├─privacy         #隐私设置│      ├─setting         #通用设置│      └─userPage        #个人主页├─theme             #主题定制├─utils             #公共模块└─voice             #音频文件\n5.1.3 部分核心代码\ntabbar红点数字提示：\n1234567891011121314151617181920/**   * 设置tabbar状态   * index: 第几个tab，0~3   * value: &#123; dot:boolean, number:number &#125;   */setTabbar: function(index, value)&#123;    if(!value.number)&#123;        wx.removeTabBarBadge(&#123; index &#125;)        if(value.dot)&#123;            wx.showTabBarRedDot(&#123; index &#125;)        &#125;else&#123;            wx.hideTabBarRedDot(&#123; index &#125;)        &#125;    &#125;else&#123;  //设置数字        wx.setTabBarBadge(&#123;            index,            text: value.number+&#x27;&#x27;,        &#125;)    &#125;&#125;\n动态单多图处理：\n1234567891011121314151617attached: function() &#123;    this.setData(&#123;        data: that.properties.moment,        user: user    &#125;);    this._initData(that.data.data.imgs.thumbnail,that)&#125;,methods: &#123;    _initData: (d,e)=&gt;&#123;        if(d.length == 1)&#123;            e.setData(&#123;                imageWidth: Math.floor(d[0].width*420/d[0].height),                imageHeight: 420            &#125;)        &#125;    &#125;&#125;\n1234567891011121314151617181920212223242526&lt;view class=&quot;content-img&quot;&gt;    &lt;!-- 多图 --&gt;    &lt;view           wx:if=&quot;&#123;&#123;data.imgs.thumbnail.length &gt; 1&#125;&#125;&quot;          class=&quot;image-wrap&quot;           wx:for=&quot;&#123;&#123;data.imgs.thumbnail&#125;&#125;&quot;          wx:for-item=&quot;item&quot;          wx:for-index=&quot;index&quot;          wx:key=&quot;item&quot;          style=&quot;width: calc(calc(100% / &#123;&#123;data.imgs.thumbnail.length &gt; 3 ? 3 : data.imgs.thumbnail.length&#125;&#125;) - 20rpx);&quot;&gt;        &lt;view               class=&quot;image&quot;              catchtap=&quot;showBigimg&quot;              data-url=&quot;&#123;&#123;data.imgs.original[index].url&#125;&#125;&quot;              style=&quot;background-image:url(&#123;&#123;item.url&#125;&#125;);&quot;&gt;        &lt;/view&gt;    &lt;/view&gt;    &lt;!-- 单图 --&gt;    &lt;view           wx:if=&quot;&#123;&#123;data.imgs.thumbnail.length == 1&#125;&#125;&quot;          class=&quot;image-wrap-single&quot;           catchtap=&quot;showBigimg&quot;          data-url=&quot;&#123;&#123;data.imgs.original[0].url&#125;&#125;&quot;          style=&quot;width:&#123;&#123;imageWidth&#125;&#125;rpx;height:&#123;&#123;imageHeight&#125;&#125;rpx;background-image:url(&#123;&#123;data.imgs.thumbnail[0].url&#125;&#125;);&quot;&gt;    &lt;/view&gt;&lt;/view&gt;\n分享图绘制：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546/**  * 绘制分享图 ：动态圈子&amp;右上角 500*400  朋友圈 500*600（加了200显示小程序码） * nodeID: canvas id * run: 运动数据   *      自定义背景：run.bg=Image或者run.color=&#123;from, to, direction:0-7左上角顺时针（）&#125; * iswx: 是否分享到朋友圈[可选]，默认false * user: 用户数据[可选](分享到朋友圈时需要)：小程序码 user.ercode=Image */draw(nodeID, run, iswx, user) &#123;    if(!run)&#123;        Dialog.alert(&#123;            message: &#x27;数据异常&#x27;        &#125;)        return;    &#125;    return new Promise((resolved, rejected)=&gt;&#123;        //画图        Share.getCanvasWX6B(nodeID, this).then(canvas=&gt;&#123;            //分享背景图            let bg = canvas.createImage();            bg.src = &#x27;../../imgs/default/sharebg.png&#x27;;            run.bg = bg;            if(iswx)&#123;                //小程序码                let ercode = canvas.createImage();                ercode.src = &#x27;../../imgs/ercode.jpg&#x27;;                user.ercode = ercode;            &#125;            Share.makeShareImg(canvas, run, iswx, user);            setTimeout(()=&gt;&#123;                if(iswx) &#123;                    Share.getFileWX6B(monID, this, iswx).then(imgurl=&gt;&#123;                        this.setData(&#123; monImg: imgurl &#125;);                    &#125;)                &#125;else &#123;                    Share.getFileWX6B(nonID, this, iswx).then(imgurl=&gt;&#123;                        this.setData(&#123; nonImg: imgurl &#125;);                    &#125;)                &#125;            &#125;,300) //延迟防止绘制未完成            resolved(canvas);        &#125;).catch(err=&gt;&#123;            rejected(err);        &#125;)    &#125;)&#125;\n5.2 后端\n5.2.1 仓库地址\nhttps://github.com/Patrick-Jun/PopRun-b\n5.2.2 目录结构\n123456789101112131415161718192021222324252627282930├─.vscode               #VS Code配置├─app                   #app目录│  ├─Console                #【核心】控制台：定时任务│  │  └─Commands                #命令：定时任务要执行的操作│  ├─Exceptions         #异常抛出类│  ├─Http               #Http控制│  │  ├─Controllers         #【核心】控制器│  │  │  └─Auth                 #控制器里进行分类：认证│  │  └─Middleware      #中间件：过滤请求和响应│  ├─Lib                #公共方法：主要写了一个返回参数格式化│  └─Providers\t\t\t├─config                #配置文件：主要改了数据库编码配置，支持emoji├─database              #数据库│  ├─factories│  ├─migrations             #【核心】数据库迭代生成│  └─seeds├─public                #公共资源│  ├─css│  ├─js│  ├─layui                  #layui引入│  └─resources              #资源│      ├─images                 #图片│      │  ├─2020-01-31              #图片按上传日期分目录管理│      ├─medals                 #勋章图片│      └─userImgs               #用户头像├─resources├─routes                #【核心】路由├─storage├─tests└─vendor                #Laravel依赖\n5.2.3 部分核心代码\n排行榜：\n123456789101112131415161718192021222324252627282930313233343536373839/**  * 获取排行榜：周榜，月榜合并接口 type:0周榜 1月榜 */public function getRanking(Request $request)&#123;    if($request-&gt;has(&#x27;team&#x27;))&#123;        //默认月榜        $timeStart = date(&quot;Y-m-01&quot;).&quot; 00:00:00&quot;;        $timeEnd = date(&#x27;Y-m-d&#x27;, strtotime(&quot;$timeStart +1 month -1 day&quot;)).&quot; 23:59:59&quot;;        if($request-&gt;has(&#x27;type&#x27;) &amp;&amp; $request-&gt;type == 0)&#123;  //0周榜            $timeStart = date(&#x27;Y-m-d&#x27;, strtotime(&quot;this week&quot;)).&quot; 00:00:00&quot;;            $timeEnd = date(&#x27;Y-m-d&#x27;, strtotime(&quot;+1 week -1 day&quot;, strtotime(&quot;this week&quot;))).&quot; 23:59:59&quot;;        &#125;        try &#123;            $top100 = RRuns::join(&#x27;r_users&#x27;, &#x27;r_users.rid&#x27;, &#x27;=&#x27;, &#x27;r_runs.rid&#x27;)                -&gt;where(&#x27;r_users.team&#x27;, $request-&gt;team)                -&gt;where(&#x27;r_runs.distance&#x27;, &#x27;&lt;&gt;&#x27;, null) //排除未完成运动                -&gt;whereBetween(&#x27;r_runs.created_at&#x27;, [$timeStart, $timeEnd])                -&gt;select(                DB::raw(                    &#x27;r_users.rid,                     r_users.nickname,                     r_users.img,                     r_users.team,                     cast(sum(r_runs.distance) as decimal(15,2)) as sumD,                    sum(r_runs.time_run) as sumT,                     cast(avg(r_runs.speed) as decimal(15,2)) as avgS&#x27;                ))                -&gt;groupBy(&#x27;r_runs.rid&#x27;)                -&gt;orderBy(&#x27;sumD&#x27;, &#x27;desc&#x27;)                -&gt;limit(100)                -&gt;get();            return returnData(true, &quot;操作成功&quot;, $top100-&gt;toArray());        &#125; catch (\\Throwable $th) &#123;            return returnData(false, $th);        &#125;    &#125;else&#123;        return returnData(false, &#x27;缺少team校区&#x27;);    &#125;&#125;\n单次里程成就和活动成就检测：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 单次里程成就：5km, 10km, 15km, 20km, 半马(21.0975=21.09), 全马(42.195=42.19), 50km, 100km * 活动成就：r_activitys.distance */private function checkMedals($rid, $distance)&#123;    // 单次里程成就    $distances = [5, 10, 15, 20, 21.09, 42.19, 50, 100];    $medalkeys = [&#x27;star_1_act&#x27;,&#x27;star_2_act&#x27;,&#x27;star_3_act&#x27;,&#x27;star_4_act&#x27;,&#x27;star_5_act&#x27;,&#x27;star_6_act&#x27;,&#x27;star_7_act&#x27;,&#x27;star_8_act&#x27;];    if($distance&gt;=5)&#123;        $index = 0;  //        for($i=0; $i&lt;count($distances); $i++)&#123;            if($distance&gt;=$distances[$i]) $index = $i;            else break;        &#125;        $medal = RMedals::where(&#x27;mkey&#x27;, $medalkeys[$index])-&gt;first();        $isAchieved = LinkUMs::where(&#x27;rid&#x27;, $rid)-&gt;where(&#x27;meid&#x27;, $medal-&gt;meid)-&gt;get();        if(count($isAchieved)==0)&#123;  //未获取过，可以进行授予            $me = new LinkUMs();            $me-&gt;fill([                &#x27;rid&#x27; =&gt; $rid,                &#x27;meid&#x27; =&gt; $medal-&gt;meid            ]);            $me-&gt;save();            System::systemNotice([                &#x27;to&#x27; =&gt; $rid,                 &#x27;msg&#x27; =&gt; &quot;你新获得一枚勋章&lt;&quot;.$medal-&gt;name.&quot;&gt;&quot;            ]);        &#125;    &#125;        // 活动成就    $timeNow = date(&#x27;Y-m-d H:i:s&#x27;);    $theLastestFinished = LinkUAs::join(&#x27;r_activitys&#x27;, &#x27;link_u_as.acid&#x27;, &#x27;=&#x27;, &#x27;r_activitys.acid&#x27;)        -&gt;select(&#x27;link_u_as.rid&#x27;, &#x27;link_u_as.acid&#x27;, &#x27;link_u_as.isfinished&#x27;, &#x27;r_activitys.title&#x27;, &#x27;r_activitys.distance&#x27;, &#x27;r_activitys.period&#x27;, &#x27;r_activitys.meid&#x27;)        -&gt;where(&#x27;r_activitys.period&#x27;, &#x27;&gt;&#x27;, $timeNow)  //有效期内的活动        -&gt;where(&#x27;link_u_as.rid&#x27;, $rid)  //已报名的活动        -&gt;where(&#x27;link_u_as.isfinished&#x27;, 0) //未完成的活动        -&gt;where(&#x27;r_activitys.distance&#x27;, &#x27;&lt;=&#x27;, $distance)  //达到挑战条件        -&gt;orderBy(&#x27;r_activitys.period&#x27;, &#x27;asc&#x27;)  //升序        -&gt;first();  //获取最近将要过期的    if($theLastestFinished)&#123;        $medal = RMedals::where(&#x27;meid&#x27;, $theLastestFinished-&gt;meid)-&gt;first();        try &#123;            DB::beginTransaction();            // 更新记录为已完成            LinkUAs::where(&#x27;rid&#x27;, $theLastestFinished-&gt;rid)                -&gt;where(&#x27;acid&#x27;, $theLastestFinished-&gt;acid)                -&gt;update([&#x27;isfinished&#x27;=&gt;1]);            // 勋章授予            $me = new LinkUMs();            $me-&gt;fill([                &#x27;rid&#x27; =&gt; $theLastestFinished-&gt;rid,                &#x27;meid&#x27; =&gt; $theLastestFinished-&gt;meid            ]);            $me-&gt;save();            DB::commit();            System::systemNotice([                &#x27;to&#x27; =&gt; $theLastestFinished-&gt;rid,                &#x27;msg&#x27; =&gt; &quot;恭喜您挑战完成活动《&quot;.$theLastestFinished-&gt;title.&quot;》，获得一枚勋章&lt;&quot;.$medal-&gt;name.&quot;&gt;&quot;            ]);        &#125; catch (\\Throwable $th) &#123;            DB::rollback();        &#125;    &#125;&#125;\n称号等级：\n123456789101112131415161718192021222324252627282930313233343536373839404142// 初始数据-等级称号protected $honors = [&#x27;赤脚&#x27;, &#x27;草鞋&#x27;, &#x27;棉鞋&#x27;, &#x27;布鞋&#x27;, &#x27;板鞋&#x27;, &#x27;高跟鞋&#x27;, &#x27;球鞋&#x27;, &#x27;运动鞋&#x27;, &#x27;跑鞋&#x27;];/** * Execute the console command. * @return mixed */public function handle()&#123;    //统计每个用户的运动次数    $userRuns = RUsers::join(&#x27;r_runs&#x27;, &#x27;r_users.rid&#x27;, &#x27;=&#x27;, &#x27;r_runs.rid&#x27;)        -&gt;where(&#x27;r_runs.distance&#x27;, &#x27;&lt;&gt;&#x27;, null) //排除未完成运动        -&gt;select(        DB::raw(            &#x27;r_users.rid, count(r_runs.ruid) as count&#x27;        )    )        -&gt;groupBy(&#x27;r_runs.rid&#x27;)        -&gt;get();    foreach($userRuns as $user)&#123;        $hoid = 1;        if($user-&gt;count &lt;= 1) $hoid = 1;        else if($user-&gt;count &lt; 10) $hoid = 2;        else if($user-&gt;count &lt; 50) $hoid = 3;        else if($user-&gt;count &lt; 100) $hoid = 4;        else if($user-&gt;count &lt; 200) $hoid = 5;        else if($user-&gt;count &lt; 400) $hoid = 6;        else if($user-&gt;count &lt; 800) $hoid = 7;        else if($user-&gt;count &lt; 1000) $hoid = 8;        else $hoid = 9;        //先查询是否已存在相同等级的称号        $linkHonors = LinkUHs::where(&#x27;rid&#x27;, $user-&gt;rid)-&gt;where(&#x27;hoid&#x27;, &#x27;=&#x27;, $hoid)-&gt;first();        if(!$linkHonors)&#123; //如果不存在，则可以进行称号进阶授予            LinkUHs::where(&#x27;rid&#x27;, $user-&gt;rid)                -&gt;update([&#x27;hoid&#x27; =&gt; $hoid ]);            System::systemNotice([                &#x27;to&#x27; =&gt; $user-&gt;rid,                &#x27;msg&#x27; =&gt; &quot;你已累计运动 $user-&gt;count 次，授予您新的的称号: lv&quot;.($hoid-1).&#x27; &#x27;.$this-&gt;honors[$hoid-1]            ]);        &#125;    &#125;&#125;\n六、结束\n总结：其实写到后面我不知道怎么写了，我的目的就是想给学弟学妹们做毕设时可以参考我的过程。\n就大概写这些吧，\n烂尾了，\n差评！🤪\n","plink":"https://www.zzboy.cn/Learning/3029bde5b8fc/"},{"title":"【日常】Osu!mania 我双手竟不敌一只猫爪","date":"2020-06-12T10:45:19.000Z","date_formatted":{"ll":"Jun 12, 2020","L":"06/12/2020","MM-DD":"06-12"},"updated":"2021-02-27T13:51:18.057Z","content":"因为毕设答辩，我今天了请假一天在家，上午完事，下午本来想录一个我玩游戏的视频，可是，被我的“二嘎子”无情打断我的千连击不说，还让我GameOver了，就因为它最后一只爪子一直按着我的键盘，可气又可笑！\n\n这是我从高中开始接触，业余玩玩练习手速的游戏：OSU！\n可以从2:14开始看，我的猫是如何欺负我的，真是一脸欠揍的猫，还盯着我！\n要看到最后，片尾有彩蛋！\n\n \n","plink":"https://www.zzboy.cn/Life/98dfa8b999c5/"},{"title":"我踩到了微信小程序里canvas的三个大臭坑","date":"2020-06-06T15:13:31.000Z","date_formatted":{"ll":"Jun 6, 2020","L":"06/06/2020","MM-DD":"06-06"},"updated":"2021-02-27T13:50:45.410Z","content":"这里简要总结一下我在做毕业设计过程中，遇到的canvas（新版2d）的三个大坑：\n\n微信小程序canvas不支持真机调试\n组件内canvas节点的获取\n真机上canvas的hidden属性问题\n\n\n其中最后一个问题困扰了一个多月（可怜巴巴的抱怨一下），直奔主题，不再多bb了\n微信小程序canvas不支持真机调试\n\n官方回答如下：\n\n\n目前只能使用真机预览，为了有一定的调试效果，可以在关键地方加console.log\n手机打开预览的微信小程序时，进入小程序设置，打开debug弹框，通过debug弹窗里的控制台输出记录来观察。\n组件内canvas节点的获取\n这也是一个大坑，直接看官方文档：https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html\n使用下面的例子：\n123456789101112// canvas.jsPage(&#123;  onReady() &#123;    const query = wx.createSelectorQuery()    query.select(&#x27;#myCanvas&#x27;)      .fields(&#123; node: true, size: true &#125;)      .exec((res) =&gt; &#123;        const canvas = res[0].node        //省略      &#125;)  &#125;&#125;)\n我们这时就可以能直接复用这个例子了\n比如我开始写的这样：\n12345678910111213141516/** * 获取canvas节点 * nodeID: canvas选择符，如 &#x27;#myCanvas&#x27; */const getCanvas = nodeID =&gt; &#123;    return new Promise((resolved, rejected)=&gt;&#123;        const query = wx.createSelectorQuery();        query.select(nodeID).node(function(res)&#123;            if(res)&#123;                resolved(res.node)            &#125;else&#123;                rejected(res)            &#125;        &#125;).exec();    &#125;)&#125;\n结果一涉及到组件就出问题了：无法获取到节点\n然后到API文档里看看：\n先看这个文档：\nhttps://developers.weixin.qq.com/miniprogram/dev/api/wxml/wx.createSelectorQuery.html\n\nSelectorQuery wx.createSelectorQuery()\n返回一个 SelectorQuery 对象实例。在自定义组件或包含自定义组件的页面中，应使用 this.createSelectorQuery() 来代替。\n\n应使用 this.createSelectorQuery() 来代替\n因此我改了一下方法，这下就可以获取到节点了：\n12345678910111213141516/** * 获取在组件内或包含自定义组件的页面中的canvas节点 * nodeID: canvas选择符，如 &#x27;#myCanvas&#x27; */const getCanvasWX6B = (nodeID, that) =&gt; &#123;    return new Promise((resolved, rejected)=&gt;&#123;        const query = that.createSelectorQuery()        query.select(nodeID).node(res =&gt; &#123;            if(res)&#123;                resolved(res.node)            &#125;else&#123;                rejected(res)            &#125;        &#125;).exec();    &#125;)&#125;\n之后有看到这样一个文档\nhttps://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.html：\n\nSelectorQuery SelectorQuery.in(Component component)\n将选择器的选取范围更改为自定义组件 component 内。（初始时，选择器仅选取页面范围的节点，不会选取任何自定义组件中的节点）。\n\n因此，还可以写成如下方式：\n1const query = wx.createSelectorQuery().in(this)\n真机上canvas的hidden属性问题\n这个问题就是那个困扰我长达一个月的问题，我翻遍了官方文档、开发社区，（期间还误反馈了一个问题： 地图和canvas同时使用时无法获取canvas ）\n我先讲讲我的业务需求：我需要在跑步结束后，用户点击右上角或者其他分享，可以直接拿到一张在运动结束时就已经绘制好的图片，这个绘制过程以及绘制完成，用户是不可见的。\n根据我的需求，我必须的隐藏canvas进行绘制分享图，其中官方有个API是OffscreenCanvas 2d，但是这都2200年了：\n\n因此，我的代码是这样写的：\n12&lt;!-- wxml --&gt;&lt;canvas type=&quot;2d&quot; hidden=&quot;&#123;&#123;true&#125;&#125;&quot; id=&quot;shareMon&quot;&gt;&lt;/canvas&gt;\n1234//jsShare.getCanvasWX6B(&#x27;#shareMon&#x27;, this).then(canvas=&gt;&#123;    Share.makeShareImg(canvas, run);&#125;)\n这样写后，在开发工具内能正常绘制分享图，但是这个代码一到真机上就不行了。\n期间通过测试，发现是获取不到节点，因此一个月里，基本都是围绕着真机上无法获取节点问题原地转圈，缺万万没有想到是根本没有canvas节点问题。\n根本原因：加了hidden=&quot;&#123;&#123;true&#125;&#125;&quot;这个属性后，真机上canvas节点根本不会渲染，这和wx:if根本没任何区别，因此这是微信小程序页面渲染的bug。\n我们来看官方文档-条件渲染：https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html\n\nwx:if vs hidden\n因为 wx:if 之中的模板也可能包含数据绑定，所以当 wx:if 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。\n同时 wx:if 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。\n相比之下，hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。\n一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则 wx:if 较好。\n\n整体读下来的意思是：使用wx:if=&quot;&#123;&#123;false&#125;&#125;&quot;和hidden=&quot;&#123;&#123;true&#125;&#125;&quot;的视觉效果都是一样的，可以看不到元素。但如果页面初始情况下，前者节点是不会被渲染出来，只有当条件改变成true后才会被渲染，而后者是不管初始设置怎样的值，页面加载时，节点都会被渲染出来，只是进行显示隐藏。\n如果按照此官方文档介绍，那么我之前的代码是没有问题的，但真机上的渲染好像不是按照这样的进行的！\n毕竟规则是他们定的，他们是爸爸，然后我参考：https://github.com/abram-lin/acanvas-weapp\n于是有了三种解决方案：\n\n\ncanvas初始让其显示，绘制图形时，通过js对hidden属性进行控制。缺点：有较明显的闪烁。\n\n\n新建一个绘图组件，canvas不要hidden属性，在组件生命周期加载完成时进行绘图，绘图完成立即调用triggerEvent方法传递图片url，并摧毁该组件。缺点：有一定的性能消耗（同原理项目：https://github.com/kuckboy1994/mp_canvas_drawer）\n\n\n就在本页面进行绘图，去掉hidden属性，这时候如果绘制完成canvas元素肯定会显示出内容的，给它加上css，让它远离可视区域：position: fixed; left: -9999px;  缺点：暂未发现😂\n\n\n准备PPT迎接答辩\n全剧终！\n","plink":"https://www.zzboy.cn/Learning/131e81658517/"},{"title":"来成都你必须了解的“潜规则”","date":"2020-05-28T00:42:22.000Z","date_formatted":{"ll":"May 28, 2020","L":"05/28/2020","MM-DD":"05-28"},"updated":"2021-02-27T13:51:13.477Z","content":"以下内容均为本人自己观察总结，仅供参考\n和服务员确认眼神？上下电梯有超车道？\n\n一、衣\n暂无~\n二、食\n3.1 火锅\n3.1.1 清汤火锅\n在成都吃火锅，火锅通常都是吃红锅，鸳鸯锅就比较少。但是，如果你点清汤锅底，店员一定会和你二次确认（确认过眼神，你不是成都人），请你不要惊讶和疑惑，因为你本身就是一个疑惑。\n3.2 面条、米线、抄手\n3.2.1 一两、二两、三两\n在成都去面馆吃面条米线类，通常你会看到规格为一两、二两、三两，这些分别对应为小份、中份、大份。可能你会好奇，老板真会用秤给你称量吗？\n答案是不会的，如果食材不同，密度不同，同样是小份重量也会有所差别的。通常面条和米线，老板是靠经验下锅，抄手通常是按照个数下锅的。\n3.2.2 微麻、中麻、老麻（特麻）\n在有些餐馆有麻度的选择，麻是又花椒粉控制的，刚来成都的朋友，千万别直接尝试中麻，更别作死去吃老麻。记住四川的微麻中麻和其他地方的程度是要高些的，有不适应者可能当场“去世”（恶心呕吐）。当然一些热心老板，看你不是吃麻常客，会给予慎重提醒的。\n三、住\n暂无~\n四、行\n4.1 地铁\n4.1.1 上下电梯\n在成都，乘坐地铁上下电梯是有潜规则的，和高速公路规则类似：超“车”靠内侧（通常为左侧）。\n地铁作为成都人流量最大的交通，上班族进出地铁站走电梯时，通常不会“停”靠在电梯上，一般会在电梯上继续往前行走。\n规则：如果你要停留在电梯上，让电梯带你上去或者下去，请你靠右站（边侧）。\n请不要停留在左侧（内侧），通常左侧是大家公认的“超车道”，你如果停留在左侧会阻碍后面他人继续向前move，会影响电梯“交通”。\n4.1.2 过安检\n没有什么特别的\n4.1.3 公交卡充值机“套路”\n地铁站里一般是有那么一两台公交卡充值机，将你的公交卡放置上去，选择好金额后进行充值时，会出现一个公众号二维码让你关注，然后你拿出手机关注后，从公众号就会弹出一条充值链接，点击链接就可以付款充值了。\n\n上面的操作过程，可能会觉得很正常\n但是，当你充值过几次后，你会发现你关注了几个不同的奇奇怪怪的公众号，为什么呢？因为地铁站里充值机弹出的二维码基本上每个月就会换一个公众号让你关注，然后充值。而且这些公众号的文章也基本是本地广告。一一去取消关注也挺慢的。其实，公交卡充值机上出现的公众号是可以不用关注的，在充值页面弹出二维码的右下角，有一个残忍拒绝，直接支付 的选项。\n\n就可以直接扫描支付，不用再关注一些乱七八糟的公众号了。\n","plink":"https://www.zzboy.cn/Life/e14dde177628/"},{"title":"SVN","date":"2020-05-25T07:11:47.000Z","date_formatted":{"ll":"May 25, 2020","L":"05/25/2020","MM-DD":"05-25"},"updated":"2021-02-27T13:50:41.683Z","content":"因工作需要，今天简单记录一下新了解的SVN操作\n\n一、基本概念\n\n之前实验室有同学学习过SVN，通过和他交流，我之前大致总结出一个整体概念：SVN相当于一个共用U盘\n\n通过今天的学习了解，我对SVN整理的概念有了：它不是一个简单共用存储空间，它还有版本更改记录，可以随时回退单个文件或者整个项目到历史的某一个版本上。\n\n版本库：版本库就是一个项目，它会存储项目文件和修改历史\n检出checkout：从版本库建立一个工作副本，工作副本是个人开发空间，开发完成然后提交到版本库中\n更新update：从版本库获取最新代码\n复查变化：在提交代码前，检查变动是应该养成的良好习惯，有status、diff\n重置更改revert：当发现本次更改或者某个文件的更改不想要了，可以进行整个工作副本重置或者单个文件重置\n冲突：当多个开发者对同一处代码进行修改提交时，就会产生冲突，这时候需要人为介入\n提交更改commit：将工作副本的更改提交到版本库，提交操作是一个原子操作，要么全部提交成成功，要么失败，不会有只成功提交一部分的更改。\n\n二、基本操作\n创建版本库\n1svnadmin create /path/to/project01\n检出\n1svn checkout svn://192.168.0.1/project01 --username=xxx\n更新\n12svn update       #将本地代码更新到最新版本svn update r6    #将本地代码更新到指定版本\n提交\n1234svn update   #提交前获取最新代码，及时解决冲突svn status   #查看文件状态：?未添加到版本控制  A等待提交到版本库svn add xxx.file   #提交当前目录下所有更改 svn add *，多层目录 svn add */**/*svn commit -m &quot;版本备注&quot;\n冲突解决\n1234svn update   #获取更新，会让选择保留哪个更改Select: (p) postpone, (df) show diff, (e) edit file, (m) merge,        (mc) my side of conflict, (tc) their side of conflict,        (s) show all options: mc\n版本回退\n123svn revert xxx.file   #回退单个文件svn revert -R trunk   #回退整个目录svn merge -r 22:21 xxx.file  #将xxx.file当前22版本回退到21版本  \n其他命令\n\nsvn log：用来展示svn 的版本作者、日期、路径等等\nsvn diff：用来显示特定修改的行级详细信息\nsvn cat：将特定版本的某文件显示在当前屏幕\nsvn list：显示一个目录或某一版本存在的文件\n…还有一些，暂时应该用不上，就不列了，以后用到再整理\n\n","plink":"https://www.zzboy.cn/Learning/d7bd3d54eb4f/"},{"title":"爱了爱了async/await","date":"2020-05-18T22:39:57.000Z","date_formatted":{"ll":"May 19, 2020","L":"05/19/2020","MM-DD":"05-19"},"updated":"2021-02-27T13:50:38.498Z","content":"日常啰嗦\n这是昨天的一道面试题：promise和async/await的区别是什么？\n当时我没答上来，贼尴尬，我一般只使用的promise，async只是有看到过，但从来没用过。下来我就好好研究了一下async/await，它太好了，解决了promise的好几个毛病，真的是让我爱上了它。\nasync/await的使用方法\n假定现在有一个异步请求：getJSON();\n1234567891011121314getJSON() &#123;    return new Promise((resolved, rejected)=&gt;&#123;        $.ajax(&#123;            type: &quot;GET&quot;,            url: &quot;xxxxxxxx&quot;,            success: data =&gt; &#123;\t\t\t\tresolved(data)            &#125;,            error: res =&gt; &#123;                rejected(res)            &#125;        &#125;);    &#125;)&#125;\n按照以往promise的写法，接下来应该使用then进行处理异步了：\n12345getJSON.then(data=&gt;&#123;    //处理成功结果&#125;).catch(err=&gt;&#123;    //处理错误&#125;)\n使用async/await，是这样写的：\n123456789const makeRequest = async () =&gt;&#123;    try &#123;        const data =  await getJSON();        return data;  //return await getJSON;    &#125; catch (err) &#123;        //处理错误    &#125;&#125;makeRequest();\n语法上，await只能用在async定义的函数里，async会隐式地返回一个promise，该promise的reosolve值就是函数return的值。整体上async/await更像是同步写法了。\nasync/await优点\n\n\n首选毋庸置疑的是async/await代码更加简洁了，不需要很多.then写匿名回调\n\n\n错误处理：async/await是利用try/catch处理错误，可以同时处理同步和异步的错误。\n12345678910111213141516171819202122232425//promiseconst makeRequest = () =&gt; &#123;    try &#123;        getJSON().then(data =&gt; &#123;            data = JSON.parse(data); // JSON.parse可能会出错        &#125;)        // 处理异步代码的错误        .catch((err) =&gt; &#123;           console.log(err)        &#125;)        console.log(abc); //同步错误：未声明变量    &#125; catch (err) &#123;        console.log(err) //无法处理.then内部的错误，只能处理同步错误    &#125;&#125;//async/awaitconst makeRequest = async () =&gt; &#123;    try &#123;        const data = JSON.parse(await getJSON()) // JSON.parse可能会出错        console.log(abc); //同步错误：未声明变量    &#125; catch (err) &#123;        console.log(err)  //能同时处理try内部和getJSON的异步错误    &#125;&#125;\n\n\n中间值：有时候下一个异步函数需要上一个异步返回值，promise就可能陷入嵌套回调，使用async/await会更加简洁：\n12345const makeRequest = async () =&gt; &#123;    const value1 = await promise1()    const value2 = await promise2(value1)    return [value1, value2]&#125;\n\n\n调试：当在promise.then中设置断点，step over不会进入下一个.then，会直接跳过本次异步代码。而async/await，完全可以把它当成同步代码。\n\n\n小提一下缺点：经过编译后的代码比较臃肿，async/await是ES2017的内容，可能有些浏览器不支持，就需要用babel进行编译，问题是本来只写了几行的代码，编译后就是几倍的代码量。\n","plink":"https://www.zzboy.cn/Learning/99cbf84d67b5/"},{"title":"JSHint的使用和配置","date":"2020-05-06T07:09:26.000Z","date_formatted":{"ll":"May 6, 2020","L":"05/06/2020","MM-DD":"05-06"},"updated":"2021-02-27T13:50:34.831Z","content":"一、前言\n为什么要代码质量检测？\n对于前端开发人员来说，使用最多的肯定就是JavaScript，起初JavaScript被开发出来的目的只是用于一些web的简单交互，但随着互联网的发展，网站内容变得丰富，交互变得更加复杂，再加上JavaScript本身设计上有很多缺陷，代码不够严谨就很可能导致一些莫名其妙的错误。有了代码检测工具，可以提示开发者检测代码中潜在的问题，帮助开发者开发出高稳健性的程序。\n目前有很多代码质量检测工具，比如JSHint、JSLint、ESLint等等，其中大部分是以lint结尾的。Lint最初是贝尔实验室开发的一款C语言静态代码分析工具，主要作用是检测C程序中的潜在错误，这也就是大部分代码质量检测工具的命名由来。Hint的中文意思是暗示，也许这就是JSHint的命名由来。\n二、 JSHint简介\nJSHint是JavaScript语法和风格的检查工具，是基于JSLint开发的，它可检测到错误和潜在风险告知给开发者。\n2.1 JSLint、JSHint、ESLint区别\n发展历程：\n\nJSLint是第一款JavaScript代码检测工具，但是它最大的问题是几乎不可配置，几乎所有的代码风格和规则都是内置的，很多会导致程序无法继续运行下去；\nJSHint是基于JSLint开发的，它最大的特点就是可配置，对开发者比较友好，团队编码风格可以很好的体现出来；\nESLint的特点在于可扩展，它不仅可扩展规则，还能扩展解析器，其扩展特点让ESLint在ES5发布后得到蓬勃发展；\n\n优缺点：\n\n\n-\n-\n-\n\n\n\n\nJSLint\n优点：\n开箱即用，规则已经内置好了\n\n\n\n缺点：\n有限配置选项，很多规则不能禁用\n\n\n\n\n规范严格，凡是不符合JSLint认为的风格，皆会警告\n\n\n\n\n扩展性能差\n\n\n\n\n无法根据错误定位到对应规则\n\n\nJSHint\n优点：\n有较多参数可配置\n\n\n\n\n支持配置文件，易于在大型项目中使用\n\n\n\n\n支持一些常用框架和库\n\n\n\n\n支持基本的ES6\n\n\n\n缺点：\n不支持自定义规则\n\n\n\n\n无法根据错误定位到对应规则\n\n\nESLint\n优点：\n默认规则包含了JSLint和JSHint的规则，易于从JSLint和JSHint迁移过来\n\n\n\n\n支持插件扩展\n\n\n\n\n可以自定义规则\n\n\n\n\n可以根据错误定位到对应的规则\n\n\n\n\n支持ES6\n\n\n\n\n唯一一个支持JSX的工具\n\n\n\n缺点：\n运行慢\n\n\n\n\n需要进行一些自定义配置\n\n\n\n参考自：https://www.sitepoint.com/comparison-javascript-linting-tools/\n\n三、安装及其使用方式\n3.1 工程上使用（推荐）\n步骤：\n（1）安装开发依赖：（如果package.json中已存在，npm install即可）\n1npm install jshint --save-dev\n（2）项目根目录新建文件，命名为 .jshintrc（如果项目中已存在该文件，此步骤略过）\n以下是我给公司angularJS项目制定的规则：\n1234567891011121314151617181920&#123;    &quot;globals&quot;: &#123;  //全局变量声明：部分框架自带特殊关键词，jshint无法识别可能会报未定义等错误        &quot;$&quot;: true,         &quot;angular&quot;: true,        &quot;UE&quot;: true,        &quot;LazyLoad&quot;: true    &#125;,    &quot;asi&quot;: true,           //取消：无分号警告    &quot;bitwise&quot;: true,       //禁止使用位运算符&amp;，通常是&amp;&amp;错写成&amp;    &quot;browser&quot;: true,       //暴露浏览器属性全局定义，如window,document    &quot;curly&quot;: true,         //循环或者条件语句必须使用花括号括起来    &quot;esversion&quot;: 5,        //代码必须撰写的ESCMScript版本    &quot;freeze&quot;: true,        //禁止重写对象原型    &quot;moz&quot;: true,           //告知JSHint代码是兼容Mozilla的，而非专门为其设计    &quot;nonbsp&quot;: true,        //不换行的空格警告    &quot;strict&quot;: true,        //必须使用use strict    &quot;undef&quot;: true,         //变量未定义警告    &quot;unused&quot;: true,        //变量定义未使用警告    &quot;jquery&quot;: true         //暴露jQuery库&#125;\n注意：\n\n\nJSHint默认配置项有这些：https://github.com/jshint/jshint/blob/master/examples/.jshintrc\n\n\njshint模块会自动读取.jshintrc文件，如果没有生效，可以通过命令：jshint -c /path/to/.jshintrc设置\n\n\n通常情况下，作用于当前目录文件及其所有子目录文件，不会作用于父级目录\n\n\n需要参考项目上使用的框架进行配置，部分框架有jshint相关配置说明，如angular.js\n\n\n\n（3）使用方法：\n12jshint xxx/a/       #检测xxx目录下的a目录下所有js文件（注意检测目录必须以 / 结尾，否则会被当做文件处理）jshint xxx/a.js     #检测xxx目录下的a.js\n（4）给本地编辑器安装jshint相应插件（开发人员可选）\n完成前几步后，就可以使用jshint工具对项目代码进行检测了，为了更加方便，建议开发人员在本地编辑器安装jshint相应插件（编辑器自带就不用了），插件会帮助我们自动检测打开的文件，并在Problems生成报告\n\nVS Code插件：jshint\nSublime插件：\nWebStorm：\n\n3.2 本地自测\n步骤：\n（1）安装：\n1npm install -g jshint\n（2）使用：\n12jshint xxx/a/       #检测xxx目录下的a目录下所有js文件（注意检测目录必须以 / 结尾，否则会被当做文件处理）jshint xxx/a.js     #检测xxx目录下的a.js\n（3）配置：\n完成前面两步后，可以使用jshint的默认配置对项目进行检测了，如果需要自定义一些检测规则，可以在项目根目录下新建一个配置文件 .jshintrc，在里面写入自定义规则，自定义规则详细参见 3.1 (2)的推荐配置 和 第四章详细配置列表\n通常jshint模块会自动寻找项目中的.jshintrc文件，若是没有自定义规则文件未生效，可通过以下命令将自定义规则添加到jshint里\n注意：如果项目上不需要.jshintrc，且仅是本地自测，请一定要将该文件添加至.gitignore里，避免污染项目\n1jshint -c .jshintrc\n3.3 编辑器方式（适用于本地）\n这里以VS code为例说明\n（1）安装：\n\n\n插件市场搜索jshint并安装\n\n\n安装jshint模块：\n\n\n1npm install -g jshint\n（2）使用：\n安装完成后自动启用，会检测当前所有窗口打开的所有文件，在Problems里输出提示\n（3）配置：\n正常安装完成后检测规则为 jshint默认项\n以下是jshint在vs code编辑器中配置：setting.json\n\n提示：插件安装后，在setting.json里输入 js 会有自动提示键入\n\n123456789101112131415161718192021222324&#123;\t/**\t* 以上是其他配置，以下为jshint配置\t*/    &quot;jshint.enable&quot;: true,  //是否启用jshint插件\t&quot;jshint.config&quot;: null,  //包含jshint配置选项的文件路径，如果存在就会覆盖jshint.options和所有.jshintrc文件    &quot;jshint.options&quot;: &#123;     //jshint配置项\t\t&quot;globals&quot;: &#123;\t\t\t&quot;$&quot;: true,\t\t\t&quot;angular&quot;: true\t\t&#125;,\t\t&quot;asi&quot;: true,\t\t&quot;strict&quot;: true,\t\t&quot;jquery&quot;: true\t\t//此处省略一大堆\t&#125;,   \t&quot;jshint.exclude&quot;: &#123;&#125;,            //忽略匹配的文件和目录    &quot;jshint.excludePath&quot;: null,      //指定exclude文件路径，如果存在将覆盖jshint.exclude和所有.jshintignore文件\t&quot;jshint.html&quot;: false,            //是否检测嵌入html中的JavaScript脚本    &quot;jshint.nodePath&quot;: &quot;&quot;,           //插件默认会在当前目录或者全局包中查找jshint模块，如果在其他位置，这里需要指定    &quot;jshint.packageManager&quot;: &quot;npm&quot;,  //指定当前使用的包管理工具    &quot;jshint.reportWarningsAsErrors&quot;: false,   //将警告类型Warning报告显示为Error错误形式 【该设置不会影响程序正常运行，grunt任务正常】    &quot;jshint.trace.server&quot;: &quot;off&quot;     //检测VS code 和jshint linter服务之间的通信 【未了解】&#125;\n配置注意：如果项目里存在.hshintrc文件，该插件会自动读取，并且默认是.jshintrc文件优先，setting.json里设置的options在存在.jshintrc文件时无效。这里建议，本地检测所有配置都写在编辑器配置里，不要写.jshintrc配置文件\n（4）插件常见报错处理\n\n\nRequest initialize failed with message: missing ) after argument list\n参见：https://github.com/Microsoft/vscode-jshint/issues/63\n解决办法：\n\n\n先确认是否安装了jshint依赖模块，插件必须配合jshint模块才能正常使用，安装完成后，插件会自动查询jshint模块位置并配置；\n\n\n如果还有问题，请确认jshint模块的安装位置，并在setting.json中配置jshint.nodePath，手动指定jshint模块位置。\n\n\n\n\n3.4 打包工具检测（跟随项目）\n3.4.1 Grunt\n安装：\n1npm install grunt-contrib-jshint --save-dev\nGruntfile.js配置：\n123456789101112131415161718192021222324252627282930313233grunt.loadNpmTasks(&#x27;grunt-contrib-jshint&#x27;);    //加载jshintgrunt.initConfig(&#123;\t\t//...前面省去一大段其他任务代码        //初始化，定义任务        jshint: &#123;            options: &#123;            //配置项                globals: &#123;&#125;            &#125;,\t\t\tjshintrc: false,      //设置为true后，会自动在项目里搜索.jshintrc文件，并.jshintrc文件优先\t\t\ttaskA: &#123;              //需要检测的子任务，例如taskA任务，检测xxx/a/目录                src: [&#x27;xxx/a/&#x27;]            &#125;,\t\t\t//示例任务            editingCenter: &#123;                src: [&#x27;app/editingCenter/editingCenterRouter.js&#x27;]            &#125;,            websiteAll: &#123;                src: [&#x27;app/editingCenter/website/all/&#x27;]            &#125;        &#125;,\t\t//...后面省去一大段其他任务代码&#125;)//加入默认任务//注意：整体执行时，jshint任务最好排在最前面，避免不必要的等待，因为该任务失败会直接终止整个grunt任务grunt.registerTask(&#x27;default&#x27;, [ \t\t&#x27;jshint&#x27;, &#x27;copy&#x27;, &#x27;bower&#x27;, &#x27;lessTask&#x27;, &#x27;concat:js&#x27;, &#x27;ngAnnotate&#x27;, &#x27;concat:libjs&#x27;, &#x27;concat:libcss&#x27;, &#x27;replace&#x27;, &#x27;uglify&#x27;, &#x27;cssmin&#x27; /* &#x27;watch&#x27;*/]);//自定义任务组合    grunt.registerTask(&#x27;jshintTask&#x27;, [        &#x27;jshint:editingCenter&#x27;,  //示例：执行editingCenter子任务        &#x27;jshint:websiteAll&#x27;,     //示例：执行websiteAll子任务]);\n执行：\n123grunt jshint                #执行jshint的所有任务grunt jshintTask            #执行jshintTask中包含的任务grunt jshint:editingCenter  #示例：单独执行jshint中的一个子任务\n​\t示例执行结果：\n​\t\n​\t\n备注：该方式如果检测出有潜在问题会直接终止grunt\n3.4.2 Gulp【待补充】\n待补充\n3.4.3 Webpack【待补充】\n待补充\n四、配置选项详细列表\n本节有些说明项中写的代码示例，因为在markdown表格里无法友好的显示，可以下载查看文末的我的doc原稿\n内容参考自 JSHint Options ，可能部分转述不准确，欢迎纠正。\n以下严格类、宽松类、环境变量仅为将规则分组区分，在写入规则时均为同级，无差别\n其中部分即将被废弃的选项转移到了 JSCS 项目，该项目可以实现代码检测和自动规范成设定的风格。\n选项中 **加粗项 **表示常用项\n参数中 **加粗 **表示默认值  全部默认值：https://github.com/jshint/jshint/blob/master/examples/.jshintrc\n没有默认值的最好自行补充，官方文档不太同步，具体设置未知\n4.1 严格类（加限制）\n说明：以下选项通常设置true时表示启用，当false表示禁用，严格选项通俗讲就是添加更多更严苛的规则，给检测增加难度的，设置后会出现较多的警告\n\n\n选项\n参数\n说明\n\n\n\n\nbitwise\ntrue/false\n禁用位运算符（&amp;），在JS里不常使用&amp;，这里是防止把&amp;&amp;写成&amp;\n\n\ncamelcase\ntrue/false\n该选项即将被JSHint废除：强制变量名称为驼峰写法或者大写字母下划线写法（UPPER_CASE）\n\n\ncurly\ntrue/false\n循环或条件语句必须使用花括号括起来。循环或者条件语句省略花括号时是执行之后的一句，某些情况下可能会被误认为而导致问题\n\n\neqeqeq\ntrue/false\n禁止使用 == 和 !=，强制使用 === 和 !==\n\n\nesversion\n3/4/5/6/7/8/9/10\n代码必须遵循指定的ESCMScript版本  技巧：如果设置3，可以检测项目代码在IE 6/7/8/9等老浏览器版本环境上执行情况\n\n\nforin\ntrue/false\n要求for in循环必须过滤对象item属性，因为遍历一个对象所有属性名称会包含通过原型链继承过来的属性，通常如以下这么做  for (key in obj) { if (obj.hasOwnProperty(key)) &#123;  // 这样我们就能确定obj中key这个属性时属于obj的，而不是继承而来的 &#125;}`\n\n\nfreeze\ntrue/false\n禁止重写原生对象的原型，比如重写了Array、Date等可能会在未来导致一些不可预料的问题  // jshint freeze:trueArray.prototype.count = function (value) &#123; return 4; &#125;;// -&gt; Warning: Extending prototype of native object: ‘Array’.`\n\n\nfuturehostile\ntrue/fasle\n当使用了在未来JavaScript版本中定义的标识符号，会警告。虽然在当前版本中不会对程序造成影响，但是之后升级版本可能会产生问题\n\n\nglobals\n{}\n声明全局变量。这里主要是声明一些特有的全局变量，如angular这个词jshint是不会识别的，需要如下设置才不会警告andular is  undefined  “globals”: {  “angular”: true }  https://jshint.com/docs/#inline-configuration\n\n\nimmed\ntrue/false\n该选项即将被JSHint废除：需要直接调用的函数必须用括号包围 function(){}()\n\n\nindent\n数字\n该选项即将被JSHint废除：设置代码缩进长度\n\n\nlatedef\nture/false/“nofunc”\n禁止在定义之前使用变量。如果设置为&quot;nofunc&quot;，则表示在true时，可以允许函数可以在定义之前使用\n\n\nleanswitch\ntrue/false\n禁止在switch语句中使用不必要的判断\n\n\nmaxcomplexity\ntrue/false\n设置代码文件独立直线路径最大复杂度检测\n\n\nmaxdepth\n数字\n设置代码最大嵌套深度\n\n\nmaxerr\n数字\n设置JSHint最大警告数，默认50\n\n\nmaxlen\n数字\n该选项即将被JSHint废除：设置最大行数\n\n\nmaxparams\n数字\n允许函数形参的最大数量\n\n\nmaxstatements\n数字\n允许每个函数内最大的声明数，声明包括变量和函数声明\n\n\nnewcap\ntrue/false\n该选项即将被JSHint废除：要求所有的构造器使用 new F() 形式\n\n\nnoarg\ntrue/false\n禁止使用arguments.caller和arguments.callee，因为这两个方法将被弃用，在ES5严格模式下已经禁止了callee\n\n\nnocomma\ntrue/false\n禁止使用逗号操作符，因为如果使用不当，可能会模糊语句值而引起错误\n\n\nnoempty\ntrue/false\n该选项即将被JSHint废除：空代码块警告\n\n\nnonbsp\ntrue/false\n不换行的空格警告。在mac电脑上开发容易产生一些不间断空格字符而破坏非utf-8的网页\n\n\nnonew\ntrue/false\n禁止使用new构造器函数。有些人喜欢调用构造函数，但并没有赋值给任何边变量  new MyConstructor();``这是没有任何好处的去声明一个构造器函数而不使用`\n\n\nnoreturnawait\ntrue/false\n禁止异步函数在try/catch块外返回await表达式。https://jakearchibald.com/2017/await-vs-return-vs-return-await/  async function foo() {   try {   return await waitAndMaybeReject();   }   catch (e) {   return ‘caught’;   }   }\n\n\npredef\ntrue/false\n允许扩展隐式全局变量\n\n\nquotmark\ntrue/false/“single”/“double”\n该选项即将被JSHint废除：     ture：禁止单双引号混用（可用任何一种）   false：什么都不处理   “single”：只允许用单引号   “double”：只允许用双引号\n\n\nregexpu\ntrue/false\n对于不包含“u”标识的正则表达式进行警告，因为u标识扩展了对Unicode的支持，还启用了更加严格的解析规则。\n\n\nshadow\ntrue/false/“inner”/“outer”\n检查变量重复定义     true：允许变量覆盖   false/“inner”：只检查是否在相同的作用域重复定义   “outer”：检查外部作用域\n\n\nsingleGroups\ntrue/false\n禁止使用非必要的分组操作符  // jshint singleGroups: true``delete(obj.attr); // Warning: Unnecessary grouping operator. 使用 delete obj.attr即可，分组操作是不必要的`\n\n\nstrict\ntrue/false/“global”/“implied”\n要求代码以ES5严格模式运行     true：必须使用“use strict”，检测到函数级别   false：关闭严格模式下的警告   “global”：在全局层面必须有一个“use strict”   “implied”：在文件里面使用“use strict”\n\n\ntrailingcomma\ntrue/false\n在数组或者对象最后一项后没有逗号时警告。在ES5起，鼓励使用逗号结尾\n\n\nundef\ntrue/false\n变量未定义\n\n\nunused\ntrue/false\n变量定义了未使用\n\n\nvarstmt\ntrue/false\n禁止使用var声明变量，需使用let或者const代替\n\n\n4.2 宽松类（取消限制）\n说明：宽松选项设置（true）后会放松检测，取消某些检测，会减少警告量\n\n\n选项\n参数\n说明\n\n\n\n\nasi\ntrue/false\n禁止缺少分号警告\n\n\nboss\ntrue/false\n禁止比较表达式没有达到预期的警告  通常情况下 if (a=10){} 这样使用时错误的，但也有部分情况需要这样使用，如  for ( var i=0,person; person=people[i]; i++ )  取消这样的警告，可以这样处理：  for ( var i=0,person; (person=people[i]); i++ )\n\n\ndebug\ntrue/false\ntrue忽略debugger代码\n\n\nelision\ntrue/false\n告知JSHint代码使用ES3数组省略元素或者空元素（[1,4,8]）\n\n\neqnull\ntrue/false\n取消 ==null 比较  警告，通常这样的比较可以检查变量是否null或者undefined\n\n\nevil\ntrue/false\n取消 使用了eval的 警告。eval容易使代码受到各种注入攻击，并且是JS解析器很难进行某些优化\n\n\nexpr\ntrue/false\n取消 使用表达式 警告。一般函数调用，而非表达式，但是现在规范并没有明确禁止这样用。\n\n\nfuncscope\ntrue/false\n取消 结构内声明的变量在结构外使用的 警告。虽然var声明有变量提升，但是这样使用的不利于开发者调试程序的。  function test() { if (true) &#123;  var x = 0; &#125; x += 1; // Default: ‘x’ used out of scope.     // 当funcscope:true时，JSHint不会发出警告}`\n\n\niterator\ntrue/false\n取消 使用__iterator__属性的 警告。并不是所有浏览器都支持此属性，需要谨慎使用。\n\n\nlastsemic\ntrue/false\n取消 一行代码最后声明后面的分号遗漏 警告。\n\n\nlaxbreak\ntrue/false\n该选项即将被JSHint废除：取消 不安全的折行 警告。\n\n\nlaxcomma\ntrue/false\n该选项即将被JSHint废除：取消 检测逗号在代码行最前面的编程风格  var obj = {  name: 'Anton' , handle: ‘valueof’ , role: 'SW Engineer'};`\n\n\nloopfunc\ntrue/false\n取消 内部循环 警告。  var nums = [];for (var i = 0; i &lt; 10; i++) &#123; nums[i] = function (j) {  return i + j; };&#125;nums0; // 会输出12而非2这类问题使用立即函数进行定义就可以规避var nums = [];for (var i = 0; i &lt; 10; i++) &#123; (function (i) {  nums[i] = function (j) &#123;    return i + j;  &#125;; }(i));``}`\n\n\nmoz\ntrue/false\n告知JSHint代码是兼容Mozilla。如果专门为Firefox web浏览器开发则不需要此项\n\n\nmultistr\ntrue/false\n该选项即将被JSHint废除：取消 多行字符串 警告。多行字符串在JS里是错误的，如果加\\说明时，在后面多了空格也是会导致整个字符串错误的  // jshint multistr:true var text = &quot;Hello`World&quot;; // 这样没有问题`` ``text = &quot;Hello``World&quot;; // Warning, no escape character.`` ``text = &quot;Hello\\ ``World&quot;; // Warning, there is a space after \\\n\n\nnotypeof\ntrue/false\n取消 typeof比较不合理的typeof值 警告。  // typeof合理值应该是 ‘function’， if (typeof a == “fuction”) { // Invalid typeof value ‘fuction’ // ...}\n\n\nnoyield\ntrue/false\n取消 函数生成器没有yield声明 警告。\n\n\npulsplus\ntrue/false\n禁止使用 一元递增或递减运算符。有些人认为这个会降低编码样式的质量\n\n\nproto\ntrue/false\n取消 关于__proto__属性的 警告。\n\n\nscripturl\ntrue/false\n取消 使用了脚本定向的url 警告。如 javascirpt: …\n\n\nsub\ntrue/false\n该选项即将被JSHint废除：取消  检测属性使用 [] 的警告，可以用 . 替代。如 person[‘name’] = pserson.name\n\n\nsupernew\ntrue/false\n取消 检测怪异结构的 警告。如 new function(){ … }和new Object\n\n\nvalidthis\ntrue/false\n取消 在非构造函数中使用this的 警告。\n\n\nwithstmt\ntrue/false\n取消 检查with使用的声明。with声明语句可以引起全局变量定义之间的混乱。\n\n\n4.3 环境变量选项\n说明：这些选项可以告知JSHint一些预先定义好的全局变量\n\n\n选项\n参数\n说明\n\n\n\n\nbrowser\ntrue/false\n暴露浏览器属性的全局定义，如window,document\n\n\nbrowserify\ntrue/false\n全局定义，可用Browserify工具建立一个项目\n\n\ncouch\ntrue/false\n全局暴露CouchDb。CouchDB是一个面向文档的数据库，可以查询和索引MapReduce的方式使用JavaScript\n\n\ndevel\ntrue/false\n定义常用于日志调试的console,alert等变量\n\n\ndojo\ntrue/false\n全局暴露的Dojo  Toolkit\n\n\njasmine\ntrue/false\n全局暴露jasmine的单元测试框架\n\n\njquery\ntrue/false\n全局暴露的jQuery库\n\n\nmocha\ntrue/false\n全局暴露的“BDD”和“TDD”的ui mocha单元测试框架\n\n\nmodule\ntrue/false\n告诉JSHint,输入代码描述了一个ECMAScript 6模块。所有模块的代码解释为严格模式代码\n\n\nmootools\ntrue/false\n全局暴露的MooToolsJavaScript框架\n\n\nnode\ntrue/false\n告知你的代码运行在node环境\n\n\nnonstandard\ntrue/false\n告知非标准但广泛采用全局定义等 escape和 unescape\n\n\nphantom\ntrue/false\n告知你的代码运行在PhantomJS环境\n\n\nprototypejs\ntrue/false\n全局暴露的prototypejs框架\n\n\nqunit\ntrue/false\n全局暴露QUnit单元测试框架\n\n\nrhino\ntrue/false\n告知你的代码运行在rhino环境\n\n\nshelljs\ntrue/false\n全局暴露ShellJS库\n\n\ntyped\ntrue/false\n全局定义数组类型构造函数\n\n\nworker\ntrue/false\n全局可以当你的代码运行在web worker。web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能  注：除IE外，所有主流浏览器均支持web worker\n\n\nwsh\ntrue/false\n告知你的代码运行在Windows  Script Host环境\n\n\nyui\ntrue/false\n全局暴露的yui框架\n\n\n五、常见问题及处理方法\n我整理了一些常见的E和W的错误和警告编号，示例、以及处理建议，但是图片太多了，我就不搬进这篇文章了，可以直接下载doc原稿查看。\n链接：https://pan.baidu.com/s/1k9wKJEUKrJe_R9aNQUfcSQ\n提取码：vq3k\n","plink":"https://www.zzboy.cn/Learning/7737c2250f76/"},{"title":"TypeScript学习-数据类型","date":"2020-04-29T00:47:24.000Z","date_formatted":{"ll":"Apr 29, 2020","L":"04/29/2020","MM-DD":"04-29"},"updated":"2021-02-27T13:50:29.578Z","content":"1、\n","plink":"https://www.zzboy.cn/Learning/d4c7cbf3ff66/"},{"title":"YApi平台以及pm2管理","date":"2020-04-10T23:05:02.000Z","date_formatted":{"ll":"Apr 11, 2020","L":"04/11/2020","MM-DD":"04-11"},"updated":"2021-02-27T13:50:26.358Z","content":"这是我做毕业设计时，特意单独用的一台服务器使用YApi平台管理接口。原来一直担心误删库，我的接口文档就全没了嘛，何况服务器上还托管了其他项目的接口。\n发现服务器突然宕机了！！！平台访问不了。吓死人了，我赶紧登上服务器，将YApi重启了，万幸数据都在！\n \n一、YApi安装和使用\n暂时不写使用教程\n以下复制粘贴的官网安装教程\n环境要求\n\nnodejs（7.6+)\nmongodb（2.6+）\ngit\n\n安装\n使用我们提供的 yapi-cli 工具，部署 YApi 平台是非常容易的。执行 yapi server 启动可视化部署程序，输入相应的配置和点击开始部署，就能完成整个网站的部署。部署完成之后，可按照提示信息，执行 node/{网站路径/server/app.js} 启动服务器。在浏览器打开指定url, 点击登录输入您刚才设置的管理员邮箱，默认密码为 ymfe.org 登录系统（默认密码可在个人中心修改）。\n12npm install -g yapi-cli --registry https:&#x2F;&#x2F;registry.npm.taobao.orgyapi server \n服务管理\n利用pm2方便服务管理维护。\n123456npm install pm2 -g  &#x2F;&#x2F;安装pm2cd  &#123;项目目录&#125;pm2 start &quot;vendors&#x2F;server&#x2F;app.js&quot; --name yapi &#x2F;&#x2F;pm2管理yapi服务pm2 info yapi &#x2F;&#x2F;查看服务信息pm2 stop yapi &#x2F;&#x2F;停止服务pm2 restart yapi &#x2F;&#x2F;重启服务\n升级\n升级项目版本是非常容易的，并且不会影响已有的项目数据，只会同步 vendors 目录下的源码文件。\n1234cd  &#123;项目目录&#125;yapi ls &#x2F;&#x2F;查看版本号列表yapi update &#x2F;&#x2F;更新到最新版本yapi update -v &#123;Version&#125; &#x2F;&#x2F;更新到指定版本\n二、MongoDB数据库备份\n暂时未详细研究\n备份：mongodump\n1mongodump -h &lt;hostname&gt;&lt;:port&gt; -d dbname -o &lt;path&gt;\n\n-h：MongDB所在服务器地址，如：127.0.0.1:27017\n-d：需要备份的数据库实例，如：test\n-o：输出目录，例如：/home/mongodb.bat/(该目录需要提前建立)，在备份完成/home/mongodb.bat/test/\n\n恢复：mongorestore\n1mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt;\n\n\n-h：MongoDB所在服务器地址，默认为： localhost:27017\n\n\n-d：恢复数据库实例名称\n\n\n–drop：恢复的时候，先删除当前数据，然后恢复备份的数据\n\n\n：最后的一个参数，设置备份数据所在位置，例如：/home/mongodb.bat/test/\n\n–dir：指定备份的目录。你不能同时指定  和 --dir 选项。\n\n\n\n三、PM2对Node进程管理\n\n参考自：https://pm2.keymetrics.io/docs/usage/quick-start/\n\n安装：\n1npm install pm2@latest -g\n添加node应用：\n1pm2 start app.js --name &lt;app_name&gt; --watch\n\n例：pm2 start “vendors/server/app.js” --name yapi\n\n\n–name：给应用命名，可以不管\n–watch：相当于热更新，应用文件更新后会重启应用\n\n其他命令：\n123456pm2 [list|ls|status]  #查看所有应用pm2 info app_name         #查看服务信息pm2 restart app_name  #重启pm2 reload app_name   #重载pm2 stop app_name     #停止pm2 delete app_name   #从pm2移除\n\napp_name：可以用id代替，其中all表示所有进程\n\n","plink":"https://www.zzboy.cn/Learning/f360ef90efef/"},{"title":"微信小程序-页面跳转传值","date":"2020-04-07T07:18:28.000Z","date_formatted":{"ll":"Apr 7, 2020","L":"04/07/2020","MM-DD":"04-07"},"updated":"2021-02-27T13:50:20.060Z","content":"简单传值\n在微信小程序里，需要多个页面来完成业务逻辑时，通常用得最多的是wx.navigateTo进行跳转页面，该API跳转后，在左上角自然有个返回图标。\n\n传递参数（父页）\n\n1234567//跳转到用户编辑页面goToEdit: function()&#123;    let rid = this.data.user.rid;    wx.navigateTo(&#123;        url: &#x27;edit/edit?rid=&#x27;+rid    &#125;);&#125;\n\n接收参数（子页）\n\n1234567/** * 生命周期函数--监听页面加载*/onLoad: function (options) &#123;    // console.log(options)    let rid = options.rid&#125;\n复杂传值（对象传递）\n我原来是2018年10月份接触小程序的，那时只有通过url传参的方式，较大点的就存localStroage\n现在做毕业设计，发现有新的方法了，类似于Vue的emit方式\n父传子\n\n传递参数（父页）\n\n12345678910//跳转到用户编辑页面goToEdit: function()&#123;    let user = this.data.user;    wx.navigateTo(&#123;        url: &#x27;edit/edit&#x27;,        success: (res)=&gt;&#123;            res.eventChannel.emit(&#x27;getDataFromUserPage&#x27;, user)        &#125;    &#125;);&#125;\n\n接收参数（子页）\n\n12345678910/** * 生命周期函数--监听页面加载*/onLoad: function (options) &#123;    this.eventChannel = this.getOpenerEventChannel(); //将eventChannel绑定到this    //监听从上个页面传来的数据    this.eventChannel.on(&#x27;getDataFromUserPage&#x27;, function(data) &#123;        console.log(&#x27;父页面传来的&#x27;, data); //这里data就是父页传来的user对象    &#125;)&#125;\n子传父\n\n传递参数（子页）\n\n1234567//保存saveUser: function()&#123;    //本处省略其他操作（网络请求更新用户数据等操作），直接进行放传参代码    let newUser = this.data.user;    this.eventChannel.emit(&#x27;whenUpdated&#x27;, newUser);    wx.navigateBack();//返回父页面，默认返回1层&#125;\n\n\n接收参数（父页）\n还是在wx.navigateTo里，添加events\n\n\n12345678910111213141516171819202122//跳转到用户编辑页面goToEdit: function()&#123;    let user = this.data.user;    wx.navigateTo(&#123;        url: &#x27;edit/edit&#x27;,                        events: &#123;            // 获取从子页面传送到当前页面的数据            whenUpdated: function(data) &#123;                console.log(&#x27;子页面传来的newUser&#x27;,data)                this.setData(&#123; user: data &#125;)            &#125;,        &#125;,                                success: (res)=&gt;&#123;            res.eventChannel.emit(&#x27;getDataFromUserPage&#x27;, user)        &#125;    &#125;);&#125;","plink":"https://www.zzboy.cn/Learning/31d6d2ad70ad/"},{"title":"Laravel常用命令","date":"2020-04-07T06:28:19.000Z","date_formatted":{"ll":"Apr 7, 2020","L":"04/07/2020","MM-DD":"04-07"},"updated":"2021-02-27T13:50:22.986Z","content":"常用命令\n这些都是我在做毕业设计中，常用的命令，久了不用就忘，恼火\n我是一个小小的前端，这些个东西就不想记了，写下来，忘了就来复制粘贴\n\n安装依赖：composer install\n生成密钥：php artisan key:generate\n启动本地服务：php artisan serve\n创建\n\n创建数据表：php artisan make:migration r_users --create=r_users   -m可以一并创建模型\n创建模型：php artisan make:model RUsers\n创建控制器：php artisan make:controller RUsersController\n创建中间件：php artisan make:middleware filterTime\n\n\n生成数据表：php artisan migrate\n部署启动：php artisan up\n\n备注：\nlaravel中的数据表都使用复数形式（users）\n默认CRUD检索id字段为id，因此尽量不自定义id字段\n数据表范例\n12345678910111213public function up()&#123;    Schema::create(&#x27;r_xxs&#x27;, function (Blueprint $table) &#123;        $table-&gt;increments(&#x27;id&#x27;);        $table-&gt;integer(&#x27;calorie&#x27;, false, false)-&gt;nullable()-&gt;comment(&#x27;卡路里&#x27;);        $table-&gt;bigInteger(&#x27;rid&#x27;)-&gt;foreign(&#x27;rid&#x27;)-&gt;references(&#x27;rid&#x27;)-&gt;on(&#x27;r_users&#x27;);        $table-&gt;tinyInteger(&#x27;sex&#x27;)-&gt;nullable()-&gt;comment(&#x27;性别:0位置1男2女&#x27;);        $table-&gt;string(&#x27;openid&#x27;, 50)-&gt;unique()-&gt;comment(&#x27;openid&#x27;);        $table-&gt;timestamp(&#x27;time_start&#x27;)-&gt;nullable()-&gt;comment(&#x27;开始时间&#x27;);         $table-&gt;timestamps(); //自动添加created_at和updated_at字段        // $table-&gt;primary([&#x27;rid&#x27;]);    &#125;);&#125;\n中间件范例\n1234567public function handle($request, Closure $next)&#123;       // 过滤掉时间    $request-&gt;offsetUnset(&#x27;created_at&#x27;);    $request-&gt;offsetUnset(&#x27;updated_at&#x27;);    return $next($request);&#125;\n1234567891011121314//Kernel.php中注册protected $routeMiddleware = [    &#x27;auth&#x27; =&gt; \\App\\Http\\Middleware\\Authenticate::class,    &#x27;auth.basic&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\AuthenticateWithBasicAuth::class,    &#x27;bindings&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\SubstituteBindings::class,    &#x27;cache.headers&#x27; =&gt; \\Illuminate\\Http\\Middleware\\SetCacheHeaders::class,    &#x27;can&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\Authorize::class,    &#x27;guest&#x27; =&gt; \\App\\Http\\Middleware\\RedirectIfAuthenticated::class,    &#x27;signed&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\ValidateSignature::class,    &#x27;throttle&#x27; =&gt; \\Illuminate\\Routing\\Middleware\\ThrottleRequests::class,    &#x27;verified&#x27; =&gt; \\Illuminate\\Auth\\Middleware\\EnsureEmailIsVerified::class,    // 自定义中间件    &#x27;filterTime&#x27; =&gt; \\App\\Http\\Middleware\\filterTime::class];\n1234//路由中使用Route::prefix(&#x27;user&#x27;)-&gt;group(function () &#123;\tRoute::post(&#x27;/doUpdate&#x27;, &#x27;RUsersController@doUpdate&#x27;)-&gt;middleware(&#x27;filterTime&#x27;);&#125;);\n","plink":"https://www.zzboy.cn/Learning/05e70c5ba457/"},{"title":"给网络171班班会就业方面的分享","date":"2020-03-09T15:00:53.000Z","date_formatted":{"ll":"Mar 9, 2020","L":"03/09/2020","MM-DD":"03-09"},"updated":"2021-02-27T13:51:10.460Z","content":"一、先说说我自己吧\n我是网络162班的学长，职位学习委员，专业综测成绩排名1/68，在考研和就业的问题上我选择了就业。\n目前在拓尔思成都研发中心，做前端开发🍕\n我从大三的暑假开始参加实习的，也就是你们这个学期的暑假。我第一个实习工作是在我们学校校招找的，我去的是东华软件，暑假工作了两个月，第二学期就直接回成都租房，然后参加这边一些一本大学的校园双选会，最后经过几场笔试和面试，拿到了拓尔思的Offer后我就直接去拓尔思了，因为比较了已经笔试的几家公司的笔试题目，觉得拓尔思他家的笔试题难一些，就没有再去参加其他公司的笔试和面试。当然现在我看来是不太明智的，这个问题之后再说。我的求职经历也不是完美的，我也是第一次经历，因此我希望大家听过我的分享后，不要再踩我踩过的坑😛\n这里首先要强调一点：以下分享，仅是我个人的一些经历和观点，可能有些不太正确，大家结合自身情况，仅供参考，因为每个人的背景和理解角度是不同的。\n这篇稿子，我稍后会放在我的博客上，需要下来再了解的，可能上我博客查看，博客地址之后发群里。\n\n说明一点，我直接脱身回成都找工作，是因为我学分已经修够，没有挂科没有重修\n\n二、给大家的建议\n2.1 考研和就业的选择\n我这里就只讲就业和考研的选择，至于创业或者出国的，我也不是很了解。\n先给大家一句话：要为自己的选择负责到底！\n在选择上，我是选择的是就业，一半原因是因为家庭方面的，我是农村出身的，家里就爸爸和妈妈，还有一个上大二的妹妹，家庭经济能力也就是能基本解决温饱，老爸好赌博，而我身为长子，应当要早点承担家庭，所以实习后我就基本没问家里拿过生活费了。另一半原因是因为我感觉有点我学不下去了，比如政治，看那一篇篇文字，就头疼。我就特别佩服考研的人！\n在工作后，我也因为当初的选择有点遗憾，为什么呢？因为现在有些岗位，是明确要求硕士学历以上，比如我在的拓尔思的一些人工智能、大数据的岗位，虽然我自学了一些，但是毫无机会。我还把跟我一起实习的大兄弟给劝回去准备明年的考研了😂，不是那种真正的劝，只是上下班闲聊，然后他就真辞职考研去了。\n我的选择经历说完了，现在我给大家分析总结几点，大家结合自身参考一下\n\n选择就业：\n\n需要确保自己不降级不重修，最后两学期尽量少挂科，最好面试前过四级\n选择职业方向，进行知识补充学习（有必要的话，可以报名培训机构，费用基本在1万多）。职业方向这我插一句：尽量选择自己感兴趣的，否则之后工作很多年会很乏味的，换行也比较痛苦。\n参加现在我们这届的春招（2020届），以及下学期你们这届的秋招（2021届），以及跑到别的学校去参加宣讲会，到处去笔试面试。\n工作不满意，还可以准备你们这届的春招（2021届）\n\n\n选择考研：\n\n开始制定复习计划，筛选学校专业\n考研失败的话，需要在二战和参加春招（2021届）做选择\n参加春招，职位较少，要和同届参加过培训的同学、参加过实习但不满意的同学、以及上届二战失败的同学、还有下一届同学的竞争。\n\n\n\n2.2 就业准备\n就业准备上，前期准备我觉得需要注意以下三点：简历的准备、知识技能的补充学习、如何投递简历\n2.2.1 简历准备\n简历准备这部分，我记得我和实验室的另外一个小伙伴，都各自花了大概1周的时间，才写好第一份简历。\n简历的准备，我建议看一下B站视频分享。就我个人的简历准备上，我简要总结了以下几点：\n\n简历：简单描述自己的经历，一般我们实习生或者应届生，一页A4纸就可以了，不要整两三页的，还有要真实，可以稍微夸大点，因为面试官会看着你的简历，挨个问你的。\n求职意向：一定要写好自己想要应聘的职位\n个人信息：一定要放证件照，蓝底，尽量在照相馆专业修图，可以颜值不高，但一定要端庄整洁，不要歪歪扭扭邋邋遢遢的，给HR印象不好。也不要出现手机P图成带耳朵的那种（这句话只是举例，要正规）；个人信息要简要，明确。细节问题上：手机号尽量344分，邮箱尽量不要用QQ邮箱，使用谷歌邮箱、Outlook等国际知名的。地址最好写想要工作的地点。最后有个人博客或者github、gitee地址，可以放一个，这是个加分项。\n教育背景：写个大学就行了，专业（本科），如果绩点（GPA）在2.7以上，可以注明自己的GPA。\n技能（重点🏆）：注意了解、熟悉、掌握、精通等词的程度，当然我们实习生或者应届生，尽量不要写精通，自己给自己找麻烦；自己想要应聘的职位有关的技能一定要放前面，加分项和关联技术放后边。\n项目经历：尽量写几个自己有信心的项目，简要说明四点：项目简介、项目角色、我的工作、业绩成果。可能有些同学在大学参加的项目或者比赛比较少，也可以放自己跟着教程做的东西，如果不是面的技术岗，可以放一些自己组织的活动那些。我个人是做的技术岗，所以对这方面了解多点。非技术岗可以自己网上看看。\n荣誉，获奖情况：这部分是为了提现你自己的学习能力的，放奖学金、比赛获奖等。\n其他：像座右铭啊，自我评价啊等，可有可无，当前面的内容不够一页的话，可以用这些补充一下。\n\n另外，如果你面试的一家公司是外企，要准备英文简历，英文自我介绍，比如思科。\n2.2.2 知识储备\n对于知识储备这块，我首先想说的是，我们在学校学习的技能，和公司所要求的技能，比例大概是1:9，就是这么残忍。我的意思不是我们知识技能不够就不要去笔试面试，反而我们更应该多去参加面试，积累面试经验，发现自己的问题，所有我们要趁这段时间，好好补补，考研的忙着复习，而我们则要忙着不断面试，不断学习，累积知识，累积经验。\n（1）如何了解意向职位所需的知识技能？\n最快了解意向职位的知识技能，就是百度，搜某个职位的学习路线或者知识图谱。\n另外更实际的就是看招聘需求，公司要什么，我就学什么。多去看看这方面的招聘需求，自己总结一下，就知道自己需要学习什么了。其实这个准备应该是大一或者大二就应该去了解的，但是现在还不晚，也可以现学现准备，尽量在秋招之前，要对自己掌握的技能有信心🧐就行了。\n（2）如何学习？\n在清楚自己要学习的知识后\n自学的话 ：可以买一些几百块钱的网课，或者找一些视频教程、书籍学习。学习方法应该采用快速学习方式，倍速播放，重点放在基础知识和常见面试问题上，一定要弄透彻。常见的笔试面试问题下一点再讲。\n我这里分享一个工具：PanDownload ,这是一个百度云盘加速下载的工具，里面有一个链接分享搜索，可以搜到一些常见的培训网站的收费视频教程，如果为了节省钱，可以这样使用，提倡正版。\n在线搜索：https://www.dupanso.com/\n培训机构 ：这个对于基础比较薄弱，且自学困难的同学比较适合。一般培训费用大概都是1-2万。我没有报过培训机构，但我认为这是一个不错投资。尽管现在看来培训费有点高，但长远来看，对于自学困难的同学是很值得的。培训机构是专门为职位所需技能而培训的，而且还提供职业推荐。\n至于培训机构的选择，我不是很了解，但尽量选择培训机构比较知名的，培训前还是要了解自己的职业方向选择和所需技能，然后再去看培训。\n我周围有好几个参加报班，平时在校成绩基本是那种靠后的，但现在也能找到一个不错的工作。\n对于参加培训机构的建议是，尽早决定是否报班，然后尽早参加培训。\n然后培训机构我不了解哪家好，大家可以联系往届的同学，再自己综合考量。我这就不瞎推荐了。\n2.2.3 简历投递\n关于简历投递，之前说的你们一定要参加我们这届的春招（2020届），就是现在，重点放在下学期你们这届的秋招（2021届）。\n\n为什么一定要参加我们这届的春招？\n\n我先给大家说个现状吧，现在大厂（腾讯、阿里、百度、字节跳动、美团、爱奇艺）等都招实习生都会提前半年。时间恰好就是在我们这届的春招就已经开始招下一届的实习生了，也就是说，现在，他们就开始招你们这届实习生了。金三银四，说的就是三月是校招黄金期，就我现在知道的情况，昨天晚上7点，字节跳动已经进行了空中宣讲，今天晚上好像是有京东的宣讲，招收目标就是2021届，而就在刚刚我看见腾讯2021届空中校园宣讲今晚8点开始的。是不是感觉时间很紧？其实现在才开始准备还不晚，如果基础比较好，现在准备准备，也有面上大厂的可能。\n现状了解了，再说说为什么要参加现在的春招？因为大厂最乐意提前招人，而我们可以试试，积累经验。大厂也不要放弃投递，如果简历通过，就可以经历他们的面试，而大厂的面试比较正规全面，就算你经验不足没有通过他们的面试，但经过这次面试后，就会学习和了解到很多很多。如果面试通过了，那就可以考虑是否要提前实习了。\n\n接下来回到如何投递简历问题？\n\n投递简历的渠道 有：校园宣讲会、校招（双选会）、内推、公司官网校园招聘、招聘平台（牛客、拉勾、Boss）\n上面的渠道我是按照我认为的简历处理快慢排的，校园宣讲会是很重要的，是公司人事部门专门到处跑学校宣讲，现场hr亲自收简历，自然处理最快，而且宣讲会还能让大家了解到一下公司。当然，跑宣讲会是比较累的。我跑过大连理工的宣讲，还有海事的宣讲，成都这边我也跑过财大、电子科大等宣讲会。这个需要关注公司官网招聘的宣讲日程地点，另外也要关注一些一本大学的就业网站信息。因为公司不会每个大学都会去，需要我们带好简历跑到指定大学去参加。现在疫情期间，很多公司都举行的网上宣讲，这个就更应该参加了，还不用到处跑。\n然后是双选会，是学校组织的，企业都是经过学校筛选过的，但也不排除有套壳公司，打着招人的旗号，给培训机构收学员，通常他们会说实习前需要收费培训。双选会大家也要积极参加，简历也会很快得到处理。\n注意 ：宣讲会和双选会，去的时候要带简历，要带好纸笔，随时准备记录重要的或者进行现场笔试\n再谈谈内推，内推的意思就是已在公司内部工作的，他推荐你到人事部门或者hr手中去，这样也比较快。但是内推并不会降低什么笔试面试难度，可能会免去笔试，但面试肯定有，因为公司需要筛选真正有用有学习能力的人才去工作。\n然后还有公司官网的校园招聘，这个也要积极参与。\n最后说说招聘平台。一个公司的人事部，可能有好几个Hr，她们又可能分别再不同招聘平台招人。可能她们自己放到招聘平台的信息，自己都给忘了，所以处理时比较慢的。另外如果他们通过宣讲会双选会内推，收到很多简历了，干嘛还要在招聘平台收人。招聘平台只是最后的补充。对我们来说，这也是我们最后没找到工作，进行海投的方式。\n投递简历的方式 ：纸质现场投递、邮箱、网站填写、平台发送电子版\n这里只说说邮箱投递需要注意的问题。\n发送主题：一定要按照他们指定的格式发送，如果没有指定，可以自己设定一个，比如格式：职位-姓名-手机号\n发送内容：通常没有要求，可以自己写两三句，注意礼貌用语即可，如：尊敬的HR，我感觉贵公司的xx职位和我非常匹配，xxx。\n简历附件：简历附件一定要是pdf格式，不要用图片或者word。文件名称也要和主题一样格式命名好，方便HR处理。\n记住你给HR方便，HR也许会给你“方便”！\n2.3 笔试和面试\n通常，公司通过你的简历后，会打电话或者邮箱通知你，参加他们的笔试或者直接面试。这里可能会受到比较多的笔试和面试时间，整理好日程，有些冲突的可以联系hr换别的时间。\n2.3.1 笔试\n正常流程的话，如果说简历是第一道门槛，那么笔试是第二道。笔试会很直接很透彻的筛选人。当然，不排除有作弊的可能。\n笔试有线上笔试、现场笔试、到公司笔试。\n线上笔试就是和我们平常上机考试差不多，现场笔试的话，可能就是宣讲会或者双选会后，直接当天在学校某个教室就做一套题。\n前两个时间通常是不能商量更改的，通知到公司参加笔试的，这个如果日程冲突，可以联系HR协商时间。\n另外说一下，线上笔试时间不一定，通常是将近1个小时左右。线下笔试通常二三十分钟，题量较少。\n说到这里，可能大家还是对笔试有点陌生，我这里强烈建议大家去 牛客网 刷公司笔试真题，这个网站有很多笔试题，很多大佬都在这刷题。另外如果考研的同学（计算机方向），上面也有一些大学的考研真题。\n2.3.2 面试\n面试，可能大家已经经历过社团等面试，但求职时的面试，需要更加注意细节礼仪。通常给你面试的人是你即将加入的部门领导。\n先总结一点：HR或者面试官一般会比较在意你基础知识掌握情况、学习能力、和稳定性。基础知识掌握情况会通过问答形式了解；学习能力可以拿奖学金或者成绩证明，也可能会问问自学的情况；最后稳定性也是公司，特别是人事部门比较在意的，至于原因，大家应该很容易明白，公司花钱来培训个实习生，一两个月就跑到别的公司去了。所以，面试90%都会问你家乡是哪、父母在哪等问题。你一定要诚实回答，如果不是省内的，你一定要表现出你非常乐意留在这个城市。我是四川的，在大连面试的时候，问道这个问题老尴尬了，之后回到成都找工作，问到我是哪的时候（因为我还有点东北口音），我说是四川哪哪的，感觉她们瞬间松了一口气的样子。\n去面试时，等待时，不要太随意，从进门到离开，要做到有礼有貌，面试过程中要端正，不要敲个二郎腿吊儿郎当的。这是我实习后我领导，也就是我的面试官给我说的，你尊重对方，对方也会给你尊重，况且对方可能是你以后的领导。\n正规面试开始时，面试官通常会让你先来个自我介绍，所以这个大家得提前准备。不然现场组织一段话，有点小困难，对我来说是有点困难。\n面试时，面试官可能提前看过你的简历，或者现场拿着你的简历，主要围绕着你简历写的职业技能，对这些技能掌握情况进行询问了解，另外还会问你简历上的项目。这时候，你要记住，对面坐的是一个大佬，会由浅到深的问，有些答不上来没有任何问题，不要太在意。整个过程要表现得积极乐观，纯真。\n正规的面试最后，面试官会让你对他提几个问题，这很重要！！！这个提问环节可以在网上搜一搜学习学习，比如你可以问问面试官经过刚刚的面试，我有什么不足之类的，让面试官现场给你个评价，这样你可以通过他的评价，大致推断出你能不能面试通过；另外再问问他们公司现在项目上用的技术栈、框架是什么？或者就前面面试时，你无法答上的问题问一问，提现自己学习积极性等。\n2.4 公司的选择\n先谈谈接收Offer的问题，现在的HR做法，通常是先联系你，说你面试通过了，问你有没有意向到他们公司，手里有没有其他Offer等，那是HR担心Offer白发了。这个大家要尽可能说自己非常喜欢他们公司，手里没有其他Offer，在商量入职时间时，尽量拖晚一点。因为在此期间，你还可以去面其他公司，然后在综合对比，选择对哪家。\n当你有几个Offer后，感觉也差不多面试完了，你就要进行选择去哪个公司了，当然你也可以在自己的社交圈里先秀一秀。\n我个人总结了几个点，给大家参考一下，如何选择：\n\n公司规模实力，公司待遇补助情况，环境，地点\n是否提供转正，以及转正后的待遇\n工作内容是否真有兴趣\n能否真的学到东西，且对跳槽过渡容易\n加班情况，周末是否双休\n\n2.5 职业精神、职场礼仪（选讲）\n可能大家是第一次听到这两个词，我也是在学习中，这里只是简单分享提及一下，大家之后拿到Offer后，进入公司前应该好好了解一遍。\n就这两点，公司给我们培训了两个多小时，由此可见其重要性，我希望大家在进公司之前就有一定了解，因为这对你的面试可能有一定作用。\n2.5.1 职业精神\n职业精神：指的是主人翁精神、敬业精神、团队精神、创新精神等，它是一种热情的态度，一种坚定的信念，一种不懈的追求，一种向前的动力，更是使人从平庸到优秀的工作准则。\n这一句是我百度的，我也在学习中，这里只是给大家提及一下，今后工作上需要注意的问题。\n2.5.2 职场礼仪\n职场礼仪：是指人们在职业场所中应当遵循的一系列礼仪规范。学会这些礼仪规范，将使一个人的职业形象大为提高。\n当然这一句也是我百度的，这也是工作后需要注意的问题。\n职场礼仪的基本点非常简单。首先，要弄清职场礼仪与社交礼仪的本质区别，职场礼仪没有性别之分。比如，为女性开门这样的“绅士风度”在工作场合是不必要的，这样做甚至有可能冒犯了对方。\n其次，将体谅和尊重别人当作自己的指导原则。尽管这是显而易见的，但在工作场所却常常被忽视了，进行介绍的正确做法是将级别低的人介绍给级别高的人。\n就我这里，我额外说一点，在公司和同事间想建立较亲密的关系，是比较不容易的，珍惜大学现在的友谊。公司里虽然每个人对每个人表面都是很热心很客气。一起进去的实习生会比较好点。一句话：公司工作半年，不及大学军训两周。\n2.6 跳槽问题（选讲）\n这个不展开说了，我自己就从东华辞职跳到成都来，也不算什么经验，就不误导了，以后我请教一下前辈再来补充吧：是否要跳槽？跳槽前准备？\n2.7 毕设问题（选讲）\n毕设实际是大四上学期，期末就开始要报题目了。\n下学期，正式交开题报告、任务书、英文文献翻译，3月份开题，6月份最后答辩，交论文。\n毕设可以在大四上学期报完题目后就可以开始做了。\n工作期间，做毕设的时间有：上班期间（活不多，领导允许）、下班回家晚上、周末。\n三、总结\n最后总结我就不给大家总结了，感觉前面内容够多了🤣\n本篇稿子我之后会放我博客里，大家下来可以再参考参考。\n最后送大家一句我最近看到的话\n赠言：学习的苦需要主动去吃，生活的苦，躺着就来了！\n什么意思呢？是说大多数人很懒，那不是行为上的懒，而是懒得改变\n有什么问题不清楚，可以私聊我或者在下方评论🍰\n","plink":"https://www.zzboy.cn/Life/901a69042e71/"},{"title":"我花了12块钱买了个理财课","date":"2020-02-19T12:30:00.000Z","date_formatted":{"ll":"Feb 19, 2020","L":"02/19/2020","MM-DD":"02-19"},"updated":"2021-02-27T13:50:17.158Z","content":"一、先总结一下\n我感觉我被骗了12块钱！因为疫情在家，反正也出不去，看到一个关注的公众号给打的广告，12块钱培训12天的理财课，我就想着反正在家闲着也是闲着，而且钱也不多，就看看他们能讲个什么。\n上完3天后，我通过他们发的链接，通过微信开发者工具可以看到源代码（因为网页js要识别用户），最后我发现也可以通过浏览器设置禁用JavaCript来访问，通过简单试了一下url的传参，获取到其他班级的进度以及课程文章链接（这样我就提前获得了所有的课程链接），我发现每个班级除了进度不一样，文章内容是一样的，每个老师的总结、每个老师的感想都是一样的，甚至每个老师的经历都是一样的：“老师出身农村，从小父母都很节俭。。。”\n其实也不算被骗，花12块钱买了些文章来读。以下内容就是我这12天的学习笔记\n\n以下为个人笔记，如有侵权，联系删除\n\n笔记中含有的文章链接，均被我处理过，在任何地方都可打开！除特殊说明外，不需要任何认证。\n二、开营班会\n2.1 资料\n\n开营前学习\n\n\n《小狗钱钱》：点击下载\n《小狗钱钱》拆读： https://mp.weixin.qq.com/s/SwVPFIUeMD7FZRPX7vG_uw\n\n\n开营预习\n\n\n开营须知：点击查看\n\n2.2 课程内容\n@所有人\n同学们好，\n欢迎大家来到20-3期1057班微淼理财训练营。\n开营第一课班会预告\n地点：班级群\n形式：链接+文字\n主题：\n①训练营的基本流程，我该如何学习？\n②会教哪些内容？能学到哪些知识？\n③小狗钱钱是如何指引\n学习流程：\n①老师发《开营须知》链接，同学们请认真阅读，非常重要！\n②今晚20:30，跟着老师一起参加开营班会，有讨论和互动环节，大家一定要准时参加！\n独行者孤，众行者远，晚8:30不见不散\n@所有人，同学们，晚上好！还有5分钟，20-3期1057班微淼理财训练营，开营典礼马上就要开始啦！接下来我们开始签到，签到内容：2020年身体健康，财务健康\n大家好，欢迎大家加入微淼12天理财训练营！\n我是陪伴大家一起学习和成长的【逸鸣】老师，很高兴可以陪大家一起度过未来的12天，希望大家认真对待这12天，遇见一个更好的自己。\n首先老师不是机器人，给大家上课的内容都是老师提前准备好的文档。这样是为了能让同学们更精准，更方便保存收藏学习资料。当然了也是因为老师手速慢。\n1.在这12天学习中，我不会推荐任何理财产品。我只教你们理财思维和技能，自己学会就能选出来好的理财产品。\n2.想通过12天就暴富的，我帮不了你。出门右转。\n3.理财小白营是针对小白的，如果你有过理财经验，这几天我也会给你颠覆性思维。\n4.12天学习都坚持不下来，凭什么你能有钱？\n上课就是在群里，文字直播形式，文字是为了方便大家回看和记笔记\n在上课期间先禁言，会有提问环节，咱们共同营造一个良好的学习环境。\n好了，今晚开营班会内容主要是3项内容：\n1️、介绍我、微淼商学院和班规\n2 、12天课程和学习流程介绍\n3 、《小狗钱钱》精华解读\n先自我介绍一下：大家好，我的名字刘逸鸣，黑龙江人，29岁，工作在北京，加入微淼1年多时间，投资理财5年时间，目前做全职财务导师工作，大家平时可以叫我逸鸣老师\n我跟大家一样，都是通过小白成长起来的，我吃过很多亏，也踩过很多坑。\n在未来的12天，我会通过引领和陪伴，帮助大家建立正确的理财观，掌握有效的理财方法，建立好富人思维，帮大家找到解决财务问题的方法\n… 介绍公司，介绍封某…省略\n而现在大家只需要12元就可以接触到封老师设计的课程了。每个人只有一次参加小白营的机会，所以大家一定要好好学习\n微淼只做最好的理财教育，不卖保险！不卖任何理财产品！\n所以你们大胆放心学就好，理财技能是变现最快的方法，没有之一！\n老师强调两点：\n\n忘掉你交了多少钱进入的这个训练营，因为它的内容值更多的钱，你们不能因为它的学费低廉而轻视它，在训练营里学习到的东西，将会给你带来百倍，千倍，甚至无法估量的收益。\n相信老师，同学们只要认真听课，紧跟训练营的学习节奏，训练营结束的时候，你将会有以下改变：\n聪明消费，摆脱月光，增加结余\n建立正确的金钱观、理财观，初步形成富人思维\n了解各种理财工具并为自己所用，赚取非工资收入\n\n学习理财不能帮助你一夜暴富，但是能够帮你梳理财务管理上的漏洞，弄清楚自己的财务状况，迈向更好的生活。\n… 课程介绍…省略\n✏️每天的早读会让你建立富人思维。\n✏️每天的防骗让你了解理财中的骗局，以后在理财中不会被骗。\n✏️每天的晚课让你建立理财底层逻辑，了解理财实操方法。\n✏️每天的作业让你事半功倍的吸收掌握当天的重点知识。\n所以，每一部分都很重要，每一部分都别缺席哈！\n大家相信我，我会给你们带来超预期的知识的，保证每个同学都能学得会\n3天连续完成作业：可获得价值千元的奖励\n10天连续完成作业：可获得巴菲特推荐经典理财书籍\n2次不完成作业，会被移出群\n… 解释为什么要移出群…省略\n《小狗钱钱》是所有理财入门书中最好的！在全球非常的畅销，每个初学理财的人都应该读一下这本书。\n在书中，主人公吉娅的父母深受债务问题的困扰！\n债务问题可能很多同学也经历过或者正在经历中。\n那么，该怎么防范或化解债务问题呢？\n小狗钱钱给吉娅提出了四条忠告：\n1.欠债的人应要减少因「消费」产生的负债\n2.应当尽可能延长贷款期限\n3.发了工资每个人都要至少把工资的10%存起来养“鹅“\n4.对于所有的消费，都要问自己【这真的有必要吗？】\n老师先带大家依次看一下这四条\n第一条：减少因「消费」产生的负债。\n\n不必要消费产生的负债是坏负债，坏负债会持续的带来净现金流出\n坏负债会让我们在债务的泥潭中越陷越深，越来越穷，最终陷入财务危机之中。\n很多人会疑问，为什么负债还分好坏？不是只要负债就是坏事么？\n先讲什么是坏负债？老师举个例子：\n比如过年了，你透支信用卡买了一大堆根本穿不着的衣服，欠了一屁股债，欠的这些债不能给你带来任何帮助，反而会增加你的压力，这就是坏负债。\n我们要尽量减少因不必要消费产生的坏负债\n第二条：如果是能“帮你赚钱”的负债要尽可能的延长偿还时间\n[图片遗失]\n【生钱资产】产生的贷款是好负债\n因为生钱资产产生的现金流入能够覆盖贷款产生的现金流出。 资产会帮我们还债，而且还会有结余。另外资产的价格还会上涨，这样我们就会越来越富有。\n什么是生钱资产，我们明天会讲，今天大家先混个脸熟\n讲一下什么是好负债\n比如你借了12块钱来学习理财，虽然欠了12块的债，但你借钱学习投资你的大脑，这在未来是对你有帮助的。这就是好负债。\n比如你贷款买房，出租出去，出租的钱能覆盖你每月还的贷款，这也是好负债\n大家能区分好负债和坏负债了吗？\n好，买房的同学注意了：房贷要尽量选择最长年限，因为房贷利率跑不过通货膨胀\n第三条：要减少消费贷款，多存钱养鹅。\n[图片遗失]\n这里的鹅可不是在河里游泳的大白鹅，而是为我们下蛋生钱的金鹅\n存钱就是养鹅，鹅养肥了它就可以下金蛋。没有鹅的人是没有金蛋收的，是不能富有的。\n假设你是个农场主，有1000只鹅，早上起来，有200多鹅蛋。是不是非常开心\n老师建议，每月至少拿出工资的10%存起来或者投资\n第四条：要理性消费，尽可能的减少【不必要的】开支。\n[图片遗失]\n如果你冷静的好好分析一下自己每个月的支出，你会发现可能有三分之一甚至更多的支出都是【不必要的】支出。所以要理性消费，减少不必要的支出，尽快把自己下金蛋的鹅养肥\n小狗钱钱中:金先生通过一个故事告诉吉娅：【不要杀死自己的鹅】！\n一个农夫有一只下金蛋的鹅，农夫开始很高兴。后来农夫的欲望越来越大，鹅下金蛋的速度赶不上农夫欲望膨胀的速度。于是农夫就杀鹅取卵，最后农夫没了鹅也没了金蛋，农夫又变成了穷光蛋。杀鹅取卵，到头来会一无所有\n吉娅一开始的打算是：存足够的钱，然后花完这些钱去实现自己的梦想。\n如果吉娅真的这么做了，那么吉娅同样也是杀死了自己的鹅。\n那该怎么办呢？\n金先生告诉吉娅，把自己挣的钱，分成三部分：\n⭐️一部分储蓄起来养鹅；\n⭐️一部分放在梦想储蓄罐；\n⭐️一部分零用;\n[图片遗失]\n在现实生活中，很多人往往因为控制不了自己的消费欲望而杀死自己的鹅🆘\n比如说现实生活中，很多人花光自己所有的积蓄去买名牌衣服、买包，贷款买车\n老师并不反对买好东西，更不反对过高品质的生活\n但是你应该用零用钱或梦想储蓄罐里的钱去买，而不是杀死自己的鹅。\n⭐️插播一句：\n在明天晚上的课程中，会讲到好支出、坏支出这2个极其重要的概念，大多数人就是分不清这2个概念，才有不良的财务状况。\n说回来：从负债到梦想储蓄罐到养鹅，我们可以看到吉娅财商升级的历程。\n第一层次：控制不住消费欲望，为了新出的包、鞋就要花完自己所有的零花钱。\n第二层次：建立自己的储蓄罐，为了自己的梦想，开始运用自己的优点来赚钱，但是没有自己的鹅。\n第三层次：开始养“鹅”\n各位同学可以想想你们现在处于哪个层次呢？\n如果一直处于第一个层次，很有可能现在是月光甚至已经负债累累了\n从这里我们也可以看出，你目前的财务状况其实只是一种结果，富有也好，负债也好，往往并不是原因。\n决定穷富的根本原因是什么呢？\n对，【思维】才是最根本的原因！\n穷人思维导致贫穷的结果，富人思维导致富有的结果✔\n如果你具备了富人思维，你就会变得越来越富有\n但是如果你不具备富人思维，即便突然有了很多钱，这笔钱也会离你而去的。\n世界上90%中彩票大奖的人，10年后的生活比中奖前要悲惨的多。\n不信大家可以百度一下，那些中彩票的人的结局\n思维是穷富的关键，也是穷富的原因。而思维并不会因为你突然有了一大笔钱而改变✔\n那什么是穷人思维，什么是富人思维呢？\n我们来看一下这张穷人和富人思维的对比图\n\n给同学们1分钟，看一下\n一边是不断放弃\n一边是不断努力找方法解决\n但，穷人思维和富人思维的差别并不仅仅于此。还有很多\n更可怕的是，穷人思维的人往往意识不到自己是穷人思维。这也是很多人一生都难以富有的深层次原因。\n这12天的课程对建立富人思维，摆脱穷人思维，各位同学一定要认真学习！\n不要落下任何一节课，大家能坚持12天，给自己的人生一个改变\n永远牢记二八定律：20%的人掌握了80%的财富\n如果一个人12天的学习都坚持不下来，那他怎么可能富有？\n坚持12天，一定会遇到一个更好的自己\n希望大家都能在2020年活得更加自由\n最后问大家一个问题\n大家觉得获得经济独立、财务自由的意义是什么？\n我来给大家说一下，大家看看是不是跟你想的一样\n经济独立、财富自由并不是独善其身，它的本质是让自己、家人变的更好的能力。\n【从个人讲】，财务自由可以更好的选择自己喜欢的东西、自己喜欢的生活方式，最终实现自己的人生价值。财务自由不是想干什么就干什么，而是不想做什么就可以选择不做。\n【从家庭讲】，与爱人共同分担家庭的财务重担，应对老人的医疗花销、孩子的教育花销，让家庭关系因为共同的努力获得财富而更美好，而不是因为钱受到冲击而动摇。\n最高级的自由不是想干什么就干什么，而是不想做什么就可以选择不做。\n比如财务自由了，我们可以选择不上班，不用再看老板的脸色\n一句话总结：提升理财技能，实现财务独立，获得更多自主选择的权力，获得给家人更好的生活的能力。\n我们奋斗一生，不就为了给家人和自己更好地生活吗？\n上边我说的就是我们12天课程富人思维第一条\n每天课程老师都会给大家分享富人思维\n一共有14条富人思维\n不想错过的话，每天一定按时来听课\n富人思维第一条：提升理财技能，实现财务独立，获得更多自主选择的权力，获得给家人更好的生活的能力。\n今天的作业非常简单：自我介绍+财富目标\n自我介绍大家都知道，我来说说财富目标，没有目标的人生是很难成功的，要思考在什么日期之前，实现什么样的财务目标，这样的目标实现起来更有推动性。可能性要大很多。\n\n私发交完作业，给的总结\n\n同学的作业老师收到啦，这12天一定坚持，我会教你\n1 钱如何越花越多，只赚不亏的具体理财工具和方法。\n2 巴菲特变富有的理财工具和复利公式。\n3 从0开始增加非工资收入的3大核心工具和6大重要工具。\n4 通过财报进行自我财务分析的方法。\n5 长期必定赚钱，可以无脑赚的具体理财工具和投资方法。\n我会监督同学哈，坚持12天不要落下课程，有问题随时沟通[加油]\n三、第1天\n3.1 晨读\n\n晨读文章\n\n\n学习理财，遇见未来不一样的自己：点击查看\n\n\n视频分享\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n3.2 午读\n\n午读文章\n\n\n股票投资骗局：点击查看\n\n3.3 晚修\n\n晚修预习\n\n\n人生穷富的关键：点击查看\n\n\n晚修讲解\n\n@所有人\n同学们，晚上好，我们1057班正式晚课第一节马上就要开始啦。我们开始签到：学好理财是人生必修课！\n今天的晚课是小白营的核心——生钱资产，今天的内容围绕生钱资产这个概念来展开的\n好了，开始上课了哈，我言简意赅，让每个同学都听明白\n先说【理财】\n\n凡是涉及到跟钱有关的安排，都是理财\n不要觉得非得投资几百万几千万才是理财\n\n比如制定家庭日常消费计划、投资计划、保险计划、养老金计划等都属于理财。\n投资≠理财，投资也是属于理财的范畴，比如投资股票、基金、房地产等\n而且提前告诉大家：股票、基金几百块起就可以投资的，后边课程会慢慢的跟大家讲\n几百块钱就可以投资\n那什么是资产呢？\n简单的说资产就是一切可以用钱来计量的东西\n比如：房子、车、手机、电脑、股票、基金等都是资产✔\n资产的内涵是【现金流】\n\n资产跟水一样是有流向的，流向你的口袋，就是现金流入。你就在赚钱\n流出你的口袋，就是现金流出。你就在亏钱\n现金流的流向决定了资产的不同️\n这就是我们的核心重点：【三大资产】\n\n根据资产现金流流向的不同，可以把资产分成3种：\n⭐️生钱资产\n⭐️耗钱资产\n⭐️其他资产\n\n到重点了哈\n✅生钱资产：持有期间能给你【持续】带来净现金流入的东西\n就是不断给你赚钱的东西\n【持续】这两个字很重要，持续指每个月、每个季度或每年能不断的给你带来净现金收入。\n也就是我们昨天讲的大鹅，一直给我们下金蛋\n生钱资产不但在你持有期间能赚取收入，还可以在未来你卖出的时候赚价差收益。\n有了生钱资产，你躺着的时候还在赚钱，这就是【睡后收入】。\n因为你睡着之后你的生钱资产还在为你赚钱\n拥有生钱资产，你想不富都难。\n常见的生钱资产有：股息、版税、利息等\n很多人把钱存入余额宝，这也属于生钱资产\n只是收益率比较低，年化只有2.5%，跑不赢通货膨胀，其实钱还是在贬值\n那么那些工具是收益率高，可以跑赢通货膨胀的生钱资产呢？\n第四天晚课我们会讲到的，大家敬请期待\n再说耗钱资产：持有期间能给你【持续】带来净现金流出的东西。\n就是让你不断亏钱的东西\n有了耗钱资产，你躺着的时候还在花钱，这就是【睡后支出】。\n想想你贷款买的房子，你的车，你要不断的为它们付钱吧\n比如我养了一只猫，它就是我的耗钱资产，会不断消耗我的钱\n那么我们要不要买耗钱资产呢？\n当然可以买\n我们要用生钱资产养耗钱资产️\n当你的生钱资产，产生的现金流大于你的耗钱资产的支出，你买多少耗钱资产都没问题。\n比如你的股息分红收入超过你的房贷，那就没有问题\n富人就是这样\n记住：要用生钱资产养耗钱资产️\n比如，你的理财投资收入，每月给你赚5000，4000用来还房贷，这样是不是就很轻松\n️其他资产：持有期间产生的净现金流为0的东西。\n有了其他资产，你躺着的时候你就是在躺着。\n只有你卖出的时候才会产生现金流，但不一定是流入还是流出\n因为可能会亏，也可能会赚\n下边我要提问了\n大家来判断：黄金是什么资产？\n说生钱资产的同学，可要面壁思过了\n记住，黄金是其他资产\n因为如果你持有黄金，不卖出，就不会产生任何任何现金流。\n但是当你卖出以后你有可能赚钱，也有可能亏钱。\n黄金是赚不可预测的差价，没有持续的净现金流入，所以是其他资产\n其他资产在你持有期间不能给你产生任何收益，你只能在未来卖掉它的时候赚价差。\n至于未来你的卖出价是否一定会比买入价高，这个只能到时候才知道。\n买入其他资产，你的收益有很大的不确定性，所以想通过其他资产长期稳定的赚钱也很难\n以上就是我们今天要学习的重点——生钱资产和耗钱资产。生钱资产、耗钱资产也是理财中最最重要的概念。\n\n今天的晚课搞懂了，可以说你就一脚踏入了富人的世界\n有钱不一定富有，富有却一定很有钱。\n穷人之所以穷，富人之所以富的关键就在这两个资产️。\n大家在理解资产时，一定别忘记“持续”二字，\n【持续】带来净现金流入的东西是生钱资产；\n【持续】带来净现金流出的东西是耗钱资产。\n不断拥有生钱资产一定能让我们变富\n要想变穷，不断买入耗钱资产就好了\n其他资产既可以让我们变富，也可以让我们变穷\n大家都渴望财务自由\n大家想过什么样的状态才是财务自由吗？\n我来说一下\n当你的生钱资产，产生的非工资收入大于你的日常总支出\n非工资收入&gt;日常支出\n你就财务自由啦\n\n就是不上班也有钱花\n同学们想想\n如果你投资的生钱资产每个月为你赚的钱，大于你一家人一个月的消费，\n这样即使你不工作，你是不是也不必为钱担忧\n这时候就是财务自由了\n想干什么就干什么了\n前提是在法律范围内\n与家人共享天伦之乐\n财务自由是我们共同的奋斗目标\n所以我说学好理财是比高考还要重要的人生必修课！\n好的，下边来说说大家比较关心的问题\n房子是什么资产？\n假如你有一套房子，没有贷款，租出去获得了租金，给你带来了【净现金流入】，它就是生钱资产✔\n或者说有贷款，但租金不仅大于每个月的月供、物业费等支出，而且还有剩余，那它也是生钱资产✔\n生钱资产的房子的贷款就是【好负债】，因为这个负债在不断的为你赚钱。\n不管赚多赚少，总之在为你赚钱\n相反，如果是3成首付买的房子自住，不但没有租金收入，每个月还要支付大笔月供以及相应的物业费等，那么它就是耗钱资产❗\n当然即使没有贷款的房子，自己住的这段时间里你还需要为房子付物业费、保险费，【产生持续的现金流出】，所以没有贷款的自住房也是耗钱资产❗\n如果是三成首付买的房子投资，出租出去，租金【刚好等于】月供、物业费各种支出。那这时它就是其他资产啦\n厉害吧，同样是房子，原来可以是3种不同的资产啊。\n但不管什么资产，两个条件判断  1.持续的   2.净现金流入    就是生钱资产。\n有同学是不是会问，老师我的房子是耗钱资产，我要搬出去吗\n说明一下哈\n这里拿房子举例，只是帮大家更好地理解生钱资产、耗钱资产。\n不是说你就一套房子，还是耗钱资产，你就不住了。\n而是在未来投资房产或其他项目的时候，要系统的分析一下，这是耗钱资产还是生钱资产，有没有投资价值\n希望大家能明白这个道理\n咱们只是那房子举例子哈\n跟大家透漏一下：房子已经是很劣质的生钱资产，因为大幅增值很难\n首富李嘉诚已经撤出大陆房地产市场了，我们不要和首富反着来哈。\n想买房靠投资赚钱的要慎重了\n首先需要大量资金，而且回本周期太长\n靠预测未来房价增长来投资，这和赌博没什么区别\n用买房的钱投资其他生钱资产，收益更高\n后天我就会讲到理财工具\n这里问一下大家，贷款买的房子需要提前还款吗？\n是的，不需要哈，因为贷款利率跑不赢通货膨胀\n贷款利率首套房应该是5%左右\n中国通货膨胀可是10%\n通货膨胀就是钱越来越不值钱\n如果你学好了理财技能，用你还款的钱，投资10%以上收益的工具，那你完全不用担心5%的房贷。\n用你还款的钱，投资10%以上收益的工具，那你完全不用担心5%的房贷。\n第四天晚课我们会讲到的收益率高的理财工具哈\n我们一步一步来，投资一口吃不成胖子\n好了，说完房子，再来说一下车，私家车是什么资产？\n私家车是自用的，每年都有保险费、保养费、停车费等支出，私家车持续的带来净现金流出，所以私家车是耗钱资产。\n如果用这个车在业余的时候跑个顺风车，收入能覆盖掉自己的日常用车支出，还有结余，那么是什么资产呢？\n因为开私家车拉活赚的钱需要你投入大量时间和精力，这其实是你的【劳动收入】。\n而不是由车本身带来的净现金流入。如果你不拉活，就没有这笔收入，\n还有一种情况，你把车通过某个租车平台出租出去了，租金去掉各项支出后还有净现金流入，这种情况下私家车才是生钱资产。\n不过既然是私家车，谁会出租呢，除非有好几辆车\n所以私家车是耗钱资产。\n其实这就引出了下一个很重要的概念\n【工资收入】VS【非工资收入】\n\n【工资收入】就是自己付出时间、精力、汗水挣来的钱。像大部分人都是拿工资的，你必须去上班才有收入，这就是工资收入。\n【非工资收入】就是，你不需要去劳动，也能有收入。因为钱能帮你生钱。就像有人说的：躺着就把钱赚了。比如利息、股息、分红、版税、专利等收入✔\n注意，非工资收入才是我们投资的目标\n如果你要出卖时间、精力，那么所谓的财务自由就无从谈起了\n就像有些人，工资超级高，但是每天工作到半夜\n这样自由吗？财务自由的最高境界是时间自由，有更多的时间陪家人\n所以想要实现财务自由，我们应该工资收入和非工资收入两手都要抓，两手都要硬。\n因为只靠工资收入是很难实现财务自由的\n聪明的同学会在获得【第一笔工资】收入时就开始选择合适的理财工具来积累自己的本金和非工资收入了。\n我们今天的课程要建立两个关键富人思维，这个就是其中一个，大家一定要记住。\n好，大家来讨论一下：月光或者钱不多的人，为什么不能等有钱再学习理财？\n因为靠工资攒钱是最低效最差的方式，如果只靠工资收入来攒钱，很可能到退休了还没有攒够理财的本金\n具有富人思维的人即便是月光，或者积蓄不多的时候，也会【从一开始】就通过工资和非工资收入【两条路径】来增加自己的收入\n从自己发的第一笔工资就开始理财\n两条腿走路肯定比只靠工资收入一条腿走的更快更远。\n群里还有好多全职宝妈妈，那老公在外面努力工作，有工资收入，我们慢慢积累非工资收入，是不是家里财务状况会非常有改观呢。\n一句话再总结下：提升财富要靠工资和非工资收入两条腿走路，绝对【不能独腿前行】，想着都累啊。\n悄悄地，我已经把今天的第一天富人思维告诉大家了\n记住，一边工作一边投资，两条腿走路\n下面我们学习第二个关键富人思维，在此之前，我们看几张图\n\n\n大家看看跟自己像不像\n这应该是大家的现金流\n⭐️资产中主要是耗钱资产，以房子、车为主\n⭐️可能有贷款也可能没有贷款\n⭐️收入主要来自工资收入\n⭐️把工资收入变成了耗钱资产，耗钱资产不停消耗中产的钱。\n为了养耗钱资产，大家是不能停止工作的。\n一旦停止工作，收入来源就断了\n这样的财务状况安全吗？\n这样的财务状况是不安全的\n而且由于耗钱资产的存在，几乎是很难变得富有的\n我们再来看一下富人的现金流：\n\n跟上一张图对比一下\n富人的收入主要来自生钱资产！\n生钱资产产生的现金流入完全能够覆盖各种支出。\n\n大家看看马云，他投资了这么多企业\n这些企业就是他的生钱资产\n️富人不用为了生活而去工作！️富人买多少耗钱资产都没关系\n因为生钱资产赚的钱足够\n这是大家的奋斗目标\n想不想未来豪车豪宅\n未来都是要实现财务自由的人\n我们想要成为富人，就要知道富人的秘密\n富人成功的两个秘密\n✅ 生钱资产占总资产的80%以上；\n✅ 好支出占总支出的80%以上。\n\n这就是富人的两个秘密！\n只要你按照富人的秘密来做，那成为富人还会远吗？\n巴菲特最初只有114美元\n114美元，几百块人民币\n积少成多，现在巴菲特身价900亿\n那么对应穷人的两个死穴是什么？\n穷人的第一个死穴：毫无任何生钱资产可言！生活唯一的经济支柱就是工资！\n穷人的第二个死穴：不知道支出也分好坏！坏支出占了总支出的80%以上。\n\n大家看看自己身上有没有这个死穴，如果有，要尽快改变\n来学习理财课程，说明大家是想改变的\n大家加油\n只要系统学习理财技能，就一定可以改变的\n大家加油，2020年，让自己活得更自由\n如何区分好支出和坏支出？\n问一下大家，你花钱来上小白营是好支出还是坏支出？\n你双11花钱买了一大堆根本穿不着的衣服是什么支出？\n所以好支出和坏支出很容易区分\n投资自己、投资生钱资产、投资未来都可以是好支出\n反之投资耗钱资产、不必要消费就是坏支出\n争取让好支出占总支出的80%以上\n你离富人就不远了\n下边以问句引出今晚最后一个富人思维\n普通家庭为什么不能满足于自己的工资收入中？\n普通家庭看似收入比较稳定，其实抗风险能力不强，他们有房贷要还，小孩要养，甚至父母还要大量的开销。\n【孩子还未成年的家庭】孩子花销逐年增大，这时候如果夫妻中有一人遇到一段时间不能工作的情况，家庭财务整体情况可能会出现较大落差，进而影响生活质量。\n【全职宝妈的家庭】宝妈负责照顾孩子，没有收入，只有老公一人的收入是家庭收入的来源，如果老公遭遇大裁员等意外情况，家庭很可能立即陷入坐吃山空的财务危机中。\n所以普通家庭更需要尽早尽快建立自己的非工资收入体系，【在没发生意外的时候】，可以为家庭提供一份额外的收入，防患于未然；【在发生意外的时候】，能够抵御财务风险，不至于到毫无收入的被动地步。\n普通家庭最怕的就是生病了，一生病就破产\n一句话总结：普通中产的【财务安全】来自工资收入和非工资收入的双管齐下，没有充足非工资收入的普通家庭，财务状况并不安全。\n一定要非工资收入和工资收入两条腿走路\n好啦，今天的课程主要内容就是这些，我来总结一下哈！\n️️️今天的核心关键，大家要记住3+2，也就是三大资产、两大富人思维。\n🔆三大资产：生钱资产、耗钱资产、其他资产\n判断他们的关键是【持续的】净现金流的流入和流出。\n两大富人思维！\n【关键富人思维-第二条】\n⭐月光或者积蓄不多的人，为什么不能等有钱再学习理财？\n月光和积蓄不多本质是错误理财思维造成的结果，\n具有富人思维的人，哪怕是现在月光或者积蓄不多，就会从一开始就通过工资和非工资收入两条路径来增加自己的收入。两条腿走路肯定比只靠工资收入一条腿走的更快更远。\n一句话总结：提升财富要靠工资和非工资收入【两条腿】走路，绝对不能独腿前行。\n【关键富人思维-第三条】\n⭐中产家庭为什么不能满足于自己的工资收入中？\n中产家庭更需要尽早尽快建立自己的非工资收入体系，【在没发生意外的时候】，可以为家庭提供一份额外的收入，补贴家用；【在发生意外的时候】，能够抵御财务风险，不至于到毫无收入的被动地步。\n学习并掌握获得非工资收入的能力，是为自己负责，也是为了家人负责。\n一句话总结：中产的【财务安全】来自工资收入和非工资收入的双管齐下，没有充足的非工资收入的中产家庭，财务状况并不安全。\n富人思维一共14条，大家及时做好笔记\n我给大家做个明天预告\n我们去银行存钱，也是理财，我们第一件事是：看利息，看我们最后能挣多少钱，对吧？\n同样，我们理财也有自己的公式，明天我们讲理财最重要的公式，复利\n明天我们一起来看一看，学会理财技能的巴菲特，是如何从114美金变成919亿美金的\n课程是循序渐进的，每一天的课程内容都不是12元可以衡量的，希望大家能坚持到最后。\n牢记二八定律：20%的人掌握了80%的财富\n爱学习的人才能成为20%的人\n\n私发交作业后，给的总结\n\n作业收到了三类资产和财务自由的概念是我们学习的关键。尽可能的增加生钱资产，减少耗钱和其他资产，让生钱资产在总资产中的比例超过80%。这样下去就一定可以财务自由的。接下来好好跟着学习。改善自己的资产结构，向着财务自由努力。\n四、第2天\n4.1 晨读\n\n晨读文章\n\n\n如何从穷人思维过渡到富人思维：点击查看\n\n\n视频分享\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n4.2 午读\n\n午读文章\n\n\nP2P投资骗局：点击查看\n\n同学们，因为p2p太常见了，常见到大家以为这是合法安全的投资工具，不用动脑子，就可以高枕无忧的享受高收益这种美差。老师想提醒几点：1、P2P不是国家交易所标准化的投资工具。2、P2P有两类，一类一开始成立的时候就没想过还钱，就是为了骗你钱，一类一开始想好好经营，但P2P的本质就是互联网高利贷，贷款的人还不了钱，公司就得倒闭。3、在国家交易所交易的投资工具中，有些工具风险比P2P低很多，收益却高，这些工具本身是没有信用风险的，比如REITs、可转债、分级基金A等等，这些工具本身没有信用风险，风险在与投资者的知识，为什么要去选择P2P这种国家都不承认不保障的工具呢？4、P2P投资就是赌博，避免赌博最好的方式就是远离。\n⭐ 总之一点，你看重人家的利息，别人看重的是你的本金，一定要擦亮眼睛，远离非标准化的理财工具。\n4.3 晚修\n\n晚修预习\n\n\n从1万到100万的理财法则：点击查看\n\n\n晚修讲解\n\n@所有人\n⭐ 【第3天】晚间分享预告：从1万到100万的理财法则\n⭐ 重点：\n①富人都在用但不会说的理财法则是什么？\n②本金少如何积累财富？\n③单利和复利有什么区别？\n⭐ 学习流程：\n①同学们认真预习《从1万到100万的理财法则》链接，做好笔记，晚课我会提问的！\n②今晚20:30，老师带着大家一起学习重点，会有提问、讨论等互动环节，大家一定要准时参加！\n早开始投资和晚开始投资又会有多大差距？\n独行者速，众行者远，今晚8:30，不见不散\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n大家带着问题去学习。思考一下复利的三个因素，你觉得哪个因素是你的优势？\n1.短期改变本金？\n2.通过学习理财技能提高收益率？\n3.如何改变时间？\n@所有人\n还没预习的同学抓紧时间啦，咱们20:30准时上课哈\n@所有人\n同学们晚上好，准备开始上课啦~\n我们签个到：理财能力是决定复利最终收益的关键！\n大家一定把生钱资产的概念贯穿在每一天的内容当中，因为生钱资产非常重要！\n昨天的内容大家还记得吗，我们先来复习一下\n提问：资产分类一共有几种？\n生钱资产，耗钱资产，其它资产\n提问，我们的工资是什么资产？\n非常棒  工资是其他资产\n看来很多同学已经明白了资产的内涵\n我们的工资，包括手里的现金，放在那里就是死工资，不会带来任何现金流入。而且还会贬值，所以是其他资产。\n只有将钱买入生钱资产，才会让钱生钱，才能变成生钱资产\n只有将钱买入生钱资产，才会让钱生钱，才能变成生钱资产\n只有将钱买入生钱资产，才会让钱生钱，才能变成生钱资产\n重要的事情说三遍\n做笔记的同学可以记下来了\n下边开始今天的课程\n第一件事\n理财计算器 http://www.yaocaiwuziyou.com/calculator.html\n把链接打开，点击右上角的「…」弄成浮窗。然后回来上课\n\n这个很关键啊，每个人都要设置成浮窗\n好，这个计算器一会我会带着你们用。用的时候我会跟你们说。\n今晚的课程主要讲三个重点，两个富人关键思维\n我们就从复利开始\n复利是帮助普通人实现财务自由的法宝\n通俗点讲，复利就是利滚利，今天的本金+利息=明天的本金\n复利的公式：最终收益=本金x（1+收益率）^时间\n\n^是次方的意思。\n举个例子：如果本金是10000元，年化收益率是15%，时间是20年\n那么计算最终收益的公式就是：10000x（1+15%）^20\n大家打开浮窗用计算器算一下\n结果是多少\n163665\n是不是很简单。\n复利根本不用自己计算，计算器可以帮我们解决\n复利本质上是一种让钱高效生钱的思维方式。\n富人财富都是用复利积累起来的。但是他们从来不公开说\n提问：根据复利公式，同学们说一下，影响复利的因素有哪些？\n根据复利公式，影响复利的因素是：本金，时间，收益率\n同学们你觉得哪个因素最关键呢？\n好的，大家意见各不相同。我们一个一个来分析一下\n第一个重点要素：本金\n本金越多，最终收益越大。\n真的是这样吗？\n如果投资到收益错误的方向上，那么本金再大也是无用的了\n很多人不懂乱投资，亏了几十万，就是因为投错了方向\n所以，本金并不是最重要的要素\n我也知道大家很多人在本金方面没法快速提升，不过好在本金相对没有那么重要\n其实就是因为本金少，那就更需要利用好❗\n巴菲特最初的本金也只有114美元\n现在大家应该都比他有钱\n那本金不多，就要花在刀刃上——投资生钱资产！\n放在优质的生钱资产上就可以高效的钱生钱啦，无论价格涨跌，生钱资产都能赚到【现金流】，满足【高效生钱不亏损】的基本原则\n哪些是优质的生钱资产呢？今天讲完复利，明天就讲工具了，\n我们一步一步来，循序渐进\n而且跟大家说一下：投资我们只需要几百几千元就可以起步\n积少成多\n所以，本金不是那么重要\n下面我们来看第二个重点要素：时间\n咱们先看个例子哈\n假设小黑和小白两人都是每月定投1000元，每年的收益率为12%（定投指数基金或某个好股票完全能够达到）\n大家先不要质疑指数基金的事，因为有的同学可能连基金是什么都不知道。更没办法选出好的指数基金。\n咱们后面第九天会有一节晚课的时间来讲基金\n小黑从20岁开始投资，共投资10年，到31岁的时候就不再投入本金\n小白从25岁开始投资，一直投入本金直到60岁\n大家先看例子\n这里要注意，小白比小黑晚投资了5年，我们来看一下，当他们到60岁的时候各自都有多少钱呢？\n\n60岁的时候，小黑有790万，小白有620万\n即使小白的投入本金是小黑的3.5倍，最终也还是没有追上小黑。\n并且，我们可以看到，在人生的各个阶段，小白始终落后于小黑，仅仅就是因为相差了5年。\n这就是时间的威力\n所以投资越早开始越好，学习理财越早开始越好\n但是，我们是没法控制时间的，没法拉长缩短它\n不受自己控制的因素，我们本质上是无能为力的，我们能做的只是尽早开始\n指数基金是举的例子，在第九天晚课我会详细讲指数基金\n理财最好的时间是10年前，其次就是现在\n咱们班不到30岁的同学还是非常幸运的，因为这个年龄开始理财能享受到时间带给你们的巨大福利\n但是30岁甚至40岁以上的同学们怎么办呢？因为即使马上开始理财，在时间上也不占优势了。\n别担心，还有办法。\n因为时间还是算不上最重要\n最后，我们来看看第三个重点要素：收益率\n适用所有人\n⭐收益率影响非常大，年化5%和年化10%，差别是显而易见的。\n再强调一下，这里的收益率指的是年化收益率。\n我们在本金不多、时间不占优势的情况下，就要努力提高自己的收益率\n收益率就是我们的理财能力\n有了理财能力才能选出收益率高的工具\n\n如上图所示，从10万开始，收益率5%、10%、15%，30年后的差异，大家应该都能从曲线就可以看到\n下边大家打开计算器。\n本金10万，收益率5%，投资30年，大家算一下\n微淼复利计算器：http://www.yaocaiwuziyou.com/calculator.html\n是43万\n再算收益率10%\n是174万\n再算15%的\n662万\n看出差距了吧\n43万/174万/662万\n收益率看似只差了3倍，但是实际差的非常多\n不是倍增\n而是指数级增长\n指数级的差距\n为什么富人越富，穷人越穷\n当你在用加减法增加财富的时候，富人是指数级的增长\n现在大家知道哪个要素是我们最该掌握的了吧？\n对  是收益率\n也就是提高我们的理财技能\n只要掌握好理财技能,大家完全可以找到这么高收益率的工具\n让你的财富指数级增长\n你现在没有理财能力，是不是只知道银行存款\n结合这三要素，我给大家说一下今天第一条富人思维\n⭐为什么说复利三要素中最容易掌控的是收益率？\n本金大的人，复利作用也比较大，但是投错了地方，本金再大也会亏完。如果本金和时间都不占优势，那么最有效的就是提高年化收益率，而提高年化收益率的关键在于自己的理财能力。\n提高年化收益率的关键在于自己的理财能力。\n理财能力没有捷径,只能靠学习来获得\n这是今天的第一条富人思维\n复利的反方向作用是什么？大家预习还记得么\n复利的反方向作用就是通货膨胀\n我们辛苦赚的钱的购买力一直在被通胀吞噬着，\n用最典型的例子来说明，90年代的万元户是有钱人，现在只有一万元就是扶贫对象\n中国目前的通胀是10%\n意思就是只要你的收益率低于10%,你的钱就在贬值\n钱会越来越不值钱\n你可以想一下10年前的100元和现在的100元购买力的差异\n现在一碗面和10年前一碗面的价格\n我们打开计算器，量化一下。\n假设你现在有400万现金，存银行20年。通胀每年10%，20年后你的钱还剩多少？\n收益率是  -10%\n大家算一下\n理财计算器 http://www.yaocaiwuziyou.com/calculator.html\n是的，你的400万还剩不到49万购买力了\n可怕吗？同学们，通货膨胀每天都在【收割】收益率低的人??\n所以，努力提高自己的理财技能吧\n只要学好理财技能，找到10%以上的理财工具，就可以应对通货膨胀了\n说到这里问大家一下:穷人不能变富是为什么呢？\n谁能用一个字概括\n其实就是懒\n贫穷的原因很大一部分是因为懒惰，这种懒惰不是身体上的懒惰，而是思维上的懒惰\n很多人也知道 变富一定【有方法】，贫穷一定【有原因】！但他们就是懒得改变\n️记住：你推迟学习理财的每一天，通货膨胀都会发挥复利的【反向作用】，吃掉你的钱。\n所以，通货膨胀面前，理财对于人生不是选修课，而是必修课！\n理财是人生的必修课\n尤其是对孩子来讲\n理财也要从娃娃抓起\n\n\n人民日报也说了，理财是必修课\n结合昨天的晚课，生钱资产和复利的关系，我来说下：\n拥有了生钱资产，给你带来源源不断的现金流在复利法则的作用下，帮助普通人实现财务自由，而你的理财能力高低决定了你收益率。\n你的理财能力高低决定了你的收益率。\n下面我融合今天所有的学习内容，提出第二个富人关键思维\n【提问】为什么说投资自己的大脑、学会理财技能是最快的脱贫之法？\n大家要善于思考啊 别管说的对不对 也要发言哈 \n大家说的都挺好的，都很有道理\n我总结了哈\n⭐为什么说投资自己的大脑、学会理财技能也是中产升级之法？\n如同经典书籍《富爸爸》中说的，穷人卖时间换钱，其实本质是“卖命”。他们抱怨自己没有钱，其实本质是他们没有认识到投资自己的大脑是最快的脱贫致富之法。\n比如一个专家花费一生写了一部巨著，我们花100元买了他的书回来看，其实某种意义上我们是买到了他一生的生命成果，学到了能获得成千上万的收益，这就叫“站在巨人的肩膀上”，贫穷的矮人站在“巨人的肩膀上”也会达到巨人的视野。\n很多人心疼这点投资大脑的钱，所以一直什么都不懂，一直贫穷下去。\n反之，穷人也能通过投资自己的头脑，学习他人成功的方法，买他人花了很多时间转化的成果，变成自己的东西，快速创造财富，这是最快的脱贫之法。\n一句话总结：心疼投资大脑的钱，一直什么都不懂，不是被通货膨胀割韭菜，就是被投资市场割韭菜，一直穷下去。反之学习他人成功的方法，变成自己的技能，是最快的脱贫、升级之法。\n当今社会，就是知识改变命运\n因为人只能赚到自己认知范围以内的钱\n很多产品收益率可以超过10%\n现在要改变思维\n今天重点说完了，跟大家多讲一些\n财商在中国老百姓的大脑中是普遍缺失的\n所以老百姓只知道把钱存到银行\n永远也分享不到国家经济增长带来的复利\n复利公式学完了，大家会不会有这样的疑问，我把钱都放在理财里面。我也不敢拿出来。我挣这个钱啥用？\n要等30年。我都老了，还没嗨我就没了……\n是不是有这个顾虑\n我来给你们回答，大家记得收藏\n其实构建家庭保障体系的方法，也是资产分配的科学方法。\n我们家庭资产配置要分为这4部分\n1.财务自由资金 \n2.风险保障资金\n3.学习培训资金\n4.生活保障资金（欲望消费包括其中）\n我们来具体聊一聊\n1.财务自由资金 \n举个例子，一个月赚5000，拿出500-1000来投资财务自由的理财工具\n拿出这些钱，不会对生活的产生影响\n投资生钱资产的工具\n让钱生钱\n2.风险保障资金\n保险保障，保险是好支出，我们一定要给家人保险保障\n我不是推荐买保险啊。别曲解我意思。我就是说每个人都应该有保障型保险\n同时，大家要清楚，不要指望保险来赚钱\n保险仅仅用来保障财务风险，而不是用来获得收益的。\n所以理财型保险和分红型保险，大家不要买\n买了就是给保险公司送钱\n保险公司推荐的保险产品，看似多少年后给你返多少钱，但只要细算一下，收益率很低\n你看上的是这点收益，保险公司看上的是你的本金\n大家只买保障型保险就足够了\n保险公司会拿着你的钱去投资收益更高的工具\n你是不是在给保险公司送钱\n自己品一下\n所以理财知识真的很重要\n3.学习培训资金\n这个不多说，我们每个月都要给自己留出学习的资金，去提高自己\n这是穷人和富人最大的区别，富人是有定期的资金来学习的，而穷人不会这么做\n很多公司的老板来我们微淼商学院学习的\n先上课，刻下讨论哈\n4.生活保障资金（欲望消费包括其中）\n生活保障资金主要是日常开支。占很大比例了。包括房子车子，烧烤，涮肉，羊蝎子……额，有点饿了\n1.财务自由资金 \n2.风险保障资金\n3.学习培训资金\n4.生活保障资金（欲望消费包括其中）\n以上就是家庭资产配置\n大家收藏好\n最后,给大家看一下巴菲特的资产信息\n11岁净资产114美元。\n21岁净资产为 2万美元。\n26岁净资产为 14万美元。\n30岁净资产为100万美元。\n39岁净资产为 2500万美元。\n43岁净资产3400万美元。\n47 岁净资产 6700 万美元。\n52 岁净资产 3.76 亿美元。\n60 岁净资产 38亿美元。\n66 岁净资产 165 亿美元。\n72 岁净资产 357 亿美元。\n84 岁净资产 670亿美元。\n87 岁（2018 年 1 月）919 亿美元\n巴菲特最初也只有114美元，700多块人民币\n老爷子今年90岁，最新的数据还没有更新，不重要了，他的成就足以证明了“复利”的威力，而且越到后面，越是爆炸性的增长。\n看完巴菲特的资产增值后什么感受？我们和他差的是什么？\n对，其实其实我们和他就差理财技能！！！\n我们和他就差理财技能！！！人家理财技能学得早。\n时间是一方面，但是收益率是最关键的\n巴菲特11岁就会投资还有个更重要的原因\n因为他爸爸是股票经纪人，从小就耳濡目染，可以看出父母对孩子的影响了吧\n大家想想自己的孩子，为了孩子是不是也要学好理财技能\n让孩子赢在起跑线\n明晚给你们讲你们期待的理财工具，生钱资产\n\n\n\n时间不早了，我最后说两个事\n1.想投资变富有，尽量不要在三方平台买基金\n比如支付宝\n支付宝是场外平台，是场外基金，跑不赢通胀，支付宝是第三方代理平台，代理就像是超市，各家基金公司的基金都有为的是方便大家直接购买，因为你们没有好的理财技能，不会挑选\n支付宝的场外基金，收益看似高，但是等你卖出时你会发现手续费特别高。养鹅首要就是节流。\n场外基金，简单来说就是，他代理了这个基金。卖给你，他拿点手续费，你挣点钱。\n除了余额宝，其他的基金都不建议。在没有掌握更好地理财技能之前，可以暂时放在余额宝里，只是暂时，因为收益率很低。\n第2件事\n银行的理财产品更不要买\n为啥不能买银行的理财产品呢？因为那是银行大堂经理推荐的。他有提成的。为了完成任务的。收益率很低。5%都不到\n通胀可是10%呢\n保险理财，就更别买了，收益更低\n而且如果用钱资金还拿不出来\n保险的关键是在于【保】而不是理财的，保险分为两大类。一类是保障型，另一类是理财型。\n通常来说，保障型保险可以理解为是纯做保障的，分为4类，分别是重疾险、意外险、医疗险和寿险。 \n对于学了理财技能的大家来说，理财型的保险就不用考虑啦\n大家会问了，那我们去哪里买呢？去哪里投资呢？\n国家有正规的证券交易平台，我们在那上面买就行了。\n简单来说中国有深证和上证两大证券交易所\n但不只是股票，reits  国债逆回购 指数基金都可以为我所用\n大家坚持一个原则：不懂不要投，懂了放心投\n明天给大家打开一个新世界的单\n好了小加餐结束了\n提前布置一个作业【心得作业】\n到今天，咱们已经学完了《人生穷富的关键》、《从1万到100万的理财法则》，明天会讲《财务自由三大核心工具》，请每一位同学根据所学到的知识，结合自己【三个最重要的财富目标】，写一篇学习总结和学习心得。学习总结字数不限，但一定要写！\n心得作业明晚上完课在写\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n先看这个视频  之后做作业\n\n视频分享\n\n这两个保险视频看一下，应该会对买保险有帮助\n\n\nYour user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n@所有人\n【第3天】晚间提醒\n【今晚分享】从1万到100万的理财法则\n【明日晨读好文】《普通人是如何通过复利法则变富的？》\n⭐ 【重要链接】学习资源大汇总 xxxxxxx\n⭐【作业2】xxxxxxx\n⭐ 微淼商学院理财计算器：www.yaocaiwuziyou.com/calculator.html\n【晚安心语】学习理财最佳的时间是十年前，其次就是现在~\n不知道这个能不能用，暂时保存\nhttp://xiaobai.yaocaiwuziyou.com/index.php/Home/Test/Financial \n个人财务健康体检，同学快测试一下自己的财务状况吧，测试完可以把结果发给我哈\n\n私发交作业后，给的总结\n\n复利的3要素，通过我们后天努力可以尽快改变的因素有：\n时间：越早开始越好。\n收益率：通过学习掌握技能可以提高收益率。\n总之，继续努力学习，将来一定要掌握生活必备的理财技能哈\n微淼商学院理财计算器：www.yaocaiwuziyou.com/calculator.html\n可以收藏，方便使用。\n老师给到的建议是：投资自己的大脑，让自己先成为生钱资产，然后不断买入生钱资产\n减少坏支出以及耗钱资产和其他资产等，学习增加生钱资产的技能——好好学习，后面的课程会对你很有帮助的。[加油]\n五、第3天\n5.1 晨读\n\n晨读文章\n\n\n普通人是如何通过复利法则变富的：点击查看\n\n\n视频分享\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n另外为了方便大家理解复利逻辑\n给大家举个例子，大家知道荷花定律吗？\n荷花定律是（Lotus's law）一个哲学定律，意思是成功需要厚积薄发，需要积累沉淀，这也是复利力量\n一个荷花池，第一天荷花开放的很少，第二天开放的数量是第一天的两倍，之后的每一天，荷花都会以前一天两倍的数量开放。\n提问：如果到第30天，荷花就开满了整个池塘，那么请问：在第几天池塘中的荷花开了一半？\n对的 ，答案是第29天，这就是荷花定律，也叫30天定律\n这就是厚积薄发，复利魔力，这不仅仅用到投资理财上\n荷花定律和复利也可以运用到人生哲学上\n有时候往往离成功只有一步之遥，但是第29天的时候放弃了坚持，这就是所谓的“死在黎明之前”\n我们投资更是这样的，理财是从我们出生就开始了，就开始和钱打交道了，衣食住行方方面面，如果我们按照正确的方法加以时间的复利\n积少成多，聚沙成塔\n那么我们将会有一个完全不一样的人生\n人很难赚到自己认知范围以外的钱，为什么巴菲特能够运用复利身价百亿？\n现在应该可能上千亿了\n因为人家从小就跟爸爸学习经济，和投资相关的知识，同时巴菲特人家也赚自己认知范围以内的钱，看看这个视频\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n我们普通人不用想着像巴菲特一样，因为可能达不到，人家十几岁就学习，我们本身就完了缺少了时间的复利，那么我们学习理财是为什么？\n为了给家人更好的生活，让自己不用被金钱所拖累，得到身心的自由，财务自由是只要你的非工资收入大于你的生活支出你就财务自由了，你可以不用担心失业，不用担心换不起房抵，不用担心生活的突变，父母的养老，孩子的上学等等问题\n因为你通过理财，把资产进行了合理的配置，做了家庭的风险保障等等\n就算你天天躺在家里，也不用焦虑\n这就是财务自由状态\n好啦早课结束啦\n赚自己看的懂的钱，是最重要的，按照正确科学的方法，系统的学习，系统分析得出来的结论，赚放心的钱，靠运气得赚钱都会靠实力亏掉\n一日之计在于晨，刚醒的小伙伴不要忘记看早读哦，有时间写感悟可以私发给老师哦\n我们投资理财到底是为 了什么：第一直觉是赚钱，但深入想，理财是为了不被钱奴役，解放时间做自己喜欢的事，快乐的生活。\n@ all people\n【昨晚分享】从1万到100万的理财法则\n⭐【重要链接】学习资源大汇总xxxxx\n【作业二】昨晚作业链接xxxxxxx\n微淼商学院理财计算器：www.yaocaiwuziyou.com/calculator.html\n🤗【早安心语】富人思维想着改变，穷人思维只会抱怨\n5.2 午读\n\n午读文章\n\n\n原始股投资骗局：点击查看\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n5.3 晚修\n\n晚修预习\n\n\n财务自由三大核心工具：点击查看\n\n今天内容多，浏览一遍就行不要求都弄懂，上课老师言简意赅梳理下就懂了，都好好预习哈\n抓住重点去学习，老师也会给大家拓展很多课外的干货，越到后面越精彩\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n晚修讲解\n\n工具有点多老师给大家梳理了一下\n\n大家主要记住无风险工具，货币基金+国债逆回购=【黄金组合】\n低风险工具，记住三个名词（股票+企业+reits=财务自由三大工具）\n后面课也会展开讲哈\n老师上课给大家梳理一遍就清楚啦\n先做好预习\n本课会给大家普及市面上常见的理财工具，内容比较多，浏览一遍就行\n@所有人\n同学们，晚上好，准备上课，开始晚课签到，投资第一原则：不懂不要投，懂了放心投\n首先我们，老规矩，回顾一下前面所学\n复利的三大要素中最重要的要素是什么呢?\n是收益率\n时间无法改变，越早开始越好；本金几百块就可以开始投资；\n收益率源于理财能力，理财能力才是决定复利终值的关键\n学好理财，提高自己的理财能力，将很大决定你以后的财富\n收益率对应的就是你的理财能力\n下一个问题：你钱包里的现金是什么资产？\n其他资产\n很好，钱只是工具，放在钱包，不会为我们生钱\n而且还会因为通货膨胀贬值\n只有把钱买入生钱资产，钱才会为我们生钱\n那么该买入什么样的生钱资产呢？\n这就是今天要讲的内容\n生活中，大家都听过这样一句话吧：\n不要乱投资！投资有风险\n这个风险指什么呢？\n是投资工具的风险？\n还是投资者理财能力风险呢？\n很多人“谈股色变”那股票的本质是什么，它的风险究竟有多大呢？\n21种理财工具中，我们掌握哪几种工具能实现财务自由呢？\n带着以上问题的思考我们开始今天的内容\n根据风险程度的不同，可以把理财工具分为4类：\n无、低、中、高\n\n今天的课程讲了21种工具，我们不必苛求样样精通，因为记住那么多也没用，但抓住重点，让我们实现财务自由的工具记住了就行了\n财务自由三大核心工具是哪三个？\n哪些工具我们坚决不能碰？\n风险和收益真的成正比吗？\n如果知道了这三个问题的答案，那么这节课就ok了\n学习投资就像小孩走路一样，如果想要跑，先要学会走\n想用投资工具赚钱，就先要认识它们的“模样”，一步一步来，一口吃不成胖子。\n今天的课程主要是三个重点+一个关键富人思维\n⭐21个投资工具金字塔，第一层\n\n无风险的理财工具主要有5个，无风险但是收益率比较低\n年化收益率一般在3%-5%左右\n跑不赢通货膨胀\n只适合用来管理零钱\n用来投资就算了\n老师重点讲两个无风险工具组成的一个捡钱小秘密，利用好这个小秘密就可以稳妥的管理好零钱啦\n捡钱小秘密是由：【国债逆回购】和【货币基金】组成的\n首先【国债逆回购】：本质就是国债抵押借款，是没有风险的。\n有时市场缺钱，借钱不容易的时候，【7天期的逆回购】年化利率可能高达20%左右。是余额宝平时的8倍左右，这也是无风险的超额收益了\n下面看一下3天期国债逆回购的年化收益率\n\n这个图大家只需要看懂关键信息就可以啦\n第一要看的是 3.111，这个地方就是关键信息，代表年化收益率，\n意思是现在把钱投出去可以获得年化3.111%的收益\n第二要看这些绿线，可以看到多次超过了12.950，什么意思呢？\n意思就是：国债逆回购的年化收益率经常能达到13%以上，偶尔还能超过20%以上。\n这都是无风险收益，是市场白送的钱\n既然这么好，国债逆回购怎么操作呢？\n我给大家录了个视频\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n大家一分钟看一下视频\n是不是很简单  看明白的，回复1 \n好的\n中国股市分为深市和沪市，\n深市是1000买起，沪市的是十万买起\n我们买深市的就好\n要是有10万，买这个是在浪费钱\n国债逆回购操作非常简单，但是比存银行活期收益高多了。\n下面我们讲捡钱小秘密的第二个工具\n不懂得  先知道有这么个事，就行了。之后我还会教你们的\n【货币基金】\n货币基金家族有个家伙是很出名的，它叫【余额宝】⭐\n想必很多同学都买过，至少也听过。其他货币基金也和余额宝差不多。\n特点是：收益太低了，跑不赢通胀\n不过灵活性还是不错的\n下面这个也是货币基金\n\n上边说到【捡钱小秘密】怎么操作呢？\n平时把钱买货币基金，代码：511660，每年可以获得3%左右的无风险收益\n当国债逆回购收益高时，比如大于5%时，卖掉货币基金直接买入国债逆回购😎这样就可以获得几天的高收益。\n等国债逆回购的钱回来后，当天买进货币基金\n因为买卖货币基金没有手续费。这样组合操作就能获得较高的收益。在保证资金方便使用的情况下获得6%+的无风险年化收益率。\n这个小秘密就是我刚才录制的视频，你们按照那个方法管理零钱很好用，就管闲钱的，也叫【现金管理】\n比如有一部分闲置资金，不甘心存在银行持续贬值，那么就适用于上述办法了。\n大家一定要把小钱打理好哦\n打理好小钱才能赚大钱，积少成多，聚沙成塔\n当然财商高的小伙伴会有更好的投资组合，我们先往下看\n那就是⭐第二类，低风险的理财工具\n\n它又分为两类\n一类是低风险中等收益，年化收益率一般6%—15%之间，\n主要包括【分级基金A】、【可转债】、【债券基金】、【股票指数基金】。\n一类是低风险高收益，年化收益率一般在15%—30%之间，\n主要包括【生钱资产类型】的股票、REITs、房地产。\n这些名字不要纠结，它就叫这个名字，现在听着陌生没事，多听就熟了\n下边我要提问了\n提问：低风险只有低收益，高风险才能带来高收益，这个说法对吗？\n不对\n可以说，低风险只有低收益，高风险才能带来高收益，这个认知真是错的离谱\n从今天开始，大家记住实际的情况是：\n低风险也可以存在高收益，高风险更可能高亏损。\n风险和收益从来都不成正比\n这其中还有一个能力问题\n【风险和收益的大小】主要不是由理财工具本身决定的，而是由我们的理财知识决定的⭐\n【风险和收益的大小】主要不是由理财工具本身决定的，而是由我们的理财知识决定的⭐\n【风险和收益的大小】主要不是由理财工具本身决定的，而是由我们的理财知识决定的⭐\n重要的事情说三遍\n牢记这句话\n低风险也可以存在高收益，高风险更可能高亏损。\n举个例子：就像大家开车，风险不来源于车，也不来源于路，而是来源于开车的人。\n懂开车技术，风险就很小，不会开车就上路就风险就极大\n投资也一样，风险不来源于工具，也不来源于股市，而是来源于投资的人。\n懂投资技能，风险就很小，\n不懂乱投资就风险极大。\n大家可以看看身边炒股亏了的人，有几个是真的懂了再投资的\n股票对于不懂理财技能的来说，依然是高风险的\n但是对于掌握了理财技能的人来说，股票就是低风险甚至是无风险的。\n就像在巴菲特眼里，股票就是他赚钱的工具，几乎没有风险，他可以任意掌控股票，让钱生钱\n因为他有超强的投资技能\n投资技能没有捷径，只有靠学习获得\n低风险≠低收益，高风险≠高收益。\n下面一起学习下这几个低风险的理财工具。\n【生钱资产类型的股票】就是持续分红的股票。\n生钱资产类型的股票可是一只持续下大金蛋的鹅\n每年分红收益率越高越优质。优质的生钱资产类型的股票，每年的分红收益率可以高达10%以上。\n\n比如这家在A股上市的公司就是非常优质的生钱资产，\n它的股息率为14%，意思是每年光现金分红的收益率就有14%了，\n如果加上价格上涨的收益，年化收益率超过15%，甚至达到20%是很正常的\n如何查看股息率呢，我也给大家录了个视频\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n是不是清晰了，看完的回复1\n通过股票代码能分辨\n是不是很简单\n多看几遍视频\n结合前两天的内容，大家想一下\n持续高分红的股票是不是就是生钱资产了呢？持有这样的股票是不是就可以享受复利了\n这就是生钱资产的魅力，因为它给你带来的分红是稳定的，带来的正向现金流是确定的。\n但是，你们肯定有个疑问，怎么选啊。很害怕啊。怕血本无归啊。\n不用担心，后面我会讲。我给你们讲的清清楚楚的。\n以后每一天都很重要,不要缺席哈，实现财务自由就靠接下来三天了\n赚自己看得懂的钱，投资安全第一\n先把今天课上完，一天一天来\n再说一下生钱资产类型的REITs\nREIT，读作 “瑞子”就行\n【REITs】是房地产投资信托基金。投资REITs本质就是投资房地产\n【生钱资产类型的REITs】就是持续高分红的REITs。其实一般的REITs都是持续高分红的。因为各国法律都规定REITs每年至少要把90%以上的净利润分配给投资者。\n所以生钱资产类型的REITs也是一只持续下大金蛋的鹅。\n通过REITs几千元就可以投资房地产了。就像买卖货币基金、股票一样方便。\n有些REITs每年的现金分红高达15%以上（比股票还要收益高）\nREITs我们后面第八天晚课会详细的讲哈，大家现在先混个脸熟\n小白投资神器\n下一个【股票指数基金】复制股票指数的股票基金。\n指数基金具有永生不死，长期上涨的特点。在合适的价位买入股票指数基金长期持有几乎没有风险。其年化收益率一般在10%—15%。\n在合适的价位买入，不是什么时候的都可以的哈\n有孩子的可以给孩子做教育金定投，指数基金100元起投资，还有老人的养老金定投。\n这几个低风险的投资工具，都可以在证券账户中交易\n没有证券账户不要紧，这就是我说的连续三次打卡做作业的奖励。课后我会发的\n以上两大类工具，是我们今天课程的两个重点，大家今天不必个个精通，后面还会逐一学到哈\n今晚大家主要知道，哪个是用来管理零钱的，哪个是用来主要投资的生钱资产\n⭐第三类，中风险的理财工具\n\n中风险的是这些\n同学们，我问一下，学到现在，你们还想买中风险的理财工具吗？？\n中风险对应中收益吗？对还是错？\n再强调一下，中风险≠中收益\n中风险可能对应着低收益，当然也可能对应着亏本\n那么股票到底是什么风险的理财工具呢？\n刚讲的就忘了吗？\n那么不是生钱资产类型的股票呢？\n好的，下面听我讲哈\n对于拥有不同理财知识的人，股票的风险和收益是不一样的\n股票可能是低风险高收益的理财工具，可能是高风险高收益的理财工具，也可能是高风险高亏损的理财工具\n不懂乱投资的，就是高风险\n学好了理财知识后再投资的，风险就很小，收益却又高又稳定。\n决定风险和收益大小的不是理财工具本身，而是我们的理财知识。\n简单来说，【懂了再投】就低风险，【不懂乱投】就高风险。\n所以，如果大家之前“炒股”亏了，或者看见身边炒股的人亏了几百万，就惧怕股市\n请大家仔细想一想，你们是否是真的懂了才去投资股票的？\n还是跟风追涨，不懂技能，盲目乱投资，才被疯狂“割韭菜”亏钱的？\n找找亏钱到底是自己的原因，还是股市的原因？\n所以以后，一定要学懂了在投资\n股市全世界创造价值最多的部门，股票背后就是企业，几乎所有的富人都在投资企业。\n股市是绝对合法化的理财工具\n这个是毋庸置疑的\n只有穷人永远攥着现金，只知道存在银行、买买理财保险，怎么可能变富？ \n好，我们再看一下高风险理财工具\n\n常见的高风险理财工具有这几个\n对于高风险的，我的忠告是，这辈子最好永远别碰它\n高风险不一定对应高收益。一般情况下对应的都是高亏损\n远离他们 远离他们 远离他们\n因为这些高风险是我们即使有了理财技能，也无法掌控的\n大家赚钱都不容易，千万不要听信高收益就买了这些工具\n收获的只会是痛苦\n在实现财务自由的过程中，大家主要用好【无风险】和【低风险】类型的理财工具就可以了️\n完全够用了\n大家一定要有风险防范意识，赚自己看的懂得钱，不要把自己辛辛苦苦赚的钱，置身于危险中\n下面是今天的第三个重点\n实现财务自由的三大核心工具：\n\n生钱资产类型的：股票，REITs，企业\n【生钱资产】类型哦记住前提\n只有当企业、股票、REITs具有生钱资产的属性的时候，才能算成我们的财务自由核心工具\n这三大核心工具，只要用好了其中的一个就能脱贫致富\n购买生钱资产，主要就是购买生钱资产类型的股票和REITS\n代表人物 比如巴菲特 罗杰斯\n创造生钱资产 ，主要就是创造企业就是创业\n比如马云、马化腾\n而我们普通人，大部分都可以通过购买生钱资产致富\n用好了企业这个核心工具，你会成为企业家\n用好了股票或REITs这两个核心工具，你会成为投资家；\n用好了企业、股票、房地产这三个工具，你会成为资本家\n同学们，第一天你设置的三个财务目标吗？接下来你需要掌握哪个核心工具来实现你的目标呢？\n好的，下面又到了今天最后也是最重要的一个知识点了：关键富人思维—第六条\n提问：到底什么时候可以开始投资？\n现在可以了吗？\n真正弄懂才行，这是正确答案\n因为每次学完这一课，就有很多同学摩拳擦掌，跃跃欲试来找我，说自己看中了哪个股票，或者看中了什么什么理财工具，一定能赚\n当我真的问出刚才那个问题的时候，他们都没法答出来，思前想后自己又乖乖回去学习了\n为什么有的人买股票必亏，看了几本书，学了几天课就急急忙忙要去股市里了。\n我们学车还要几个月，投资作为高度专业化、精细化的一个领域，不经过【系统的】学习就去“尝试”。\n这和训练了三天、看了几本武侠小说就上战场的士兵有什么区别呢？\n士兵进行系统训练是为了保命，投资者进行系统的学习是为了保钱的“命”，\n反之，学个半瓶水就去投资市场，美其名为“试试”，这样的“试试”不会学到任何教训、经验，只会收获痛苦。\n那些经过系统训练的人会把那些无知且盲目入市的人收割的一分钱不剩\n【这就是投资的真相】\n不系统学习就想赚快钱就是送命。当你打算投资一个目标，有系统的分析方法，不再为了涨跌而心惊胆战的时候，这才是投资可以真正开始的时候。\n不系统学习就想赚快钱就是送命。\n一句话总结：投资第一原则：不懂不要投，懂了安心投，盲目“尝试”无疑送命，系统训练方可真正保住钱“命”。\n血和泪的教训太多了\n大家赚钱不容易，千万不能盲目投资\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n请对你自己的人生负责，对家人负责\n最后一个问题\n什么是价值投资？什么是投机？\n投机：所谓低买高卖。想着挣快钱，我投了就要挣钱。亏了怪这个理财工具风险大。不看本质，就想着挣钱。\n这和赌博有什么区别\n价值投资：\n我举个例子，假设你想投资一家企业，你要花钱买他的股票，不能闭着眼买吧。\n你是不是要看他的财报？就好像我们去买一个转让店铺要看他过去的流水一样。看他盈利情况，如果他不赚钱，我们买它干啥，对不对？\n流水代表它过去赚钱的能力\n看完流水之后，要再看他的未来是否有增值的潜力，这就需要看这家企业的模型。企业管理模型。\n看清楚了在投资，投资以后长期持有，关注企业内在价值，和这个企业共同进步，这是价值投资。\n与好公司共同成长\n大家，抱着价值投资的心态去学习、去投资。你们就不会亏损。\n相反会分享公司成长带来的财富增值\n明天就学习财报了\n明天学习分析企业财报。学好财报，才能选出好的公司，好的股票哈。\n@所有人\n下边我要发奖了\n【作业奖励提示】\n3天连续完成作业：可获得价值千元的奖励\n10天连续完成作业：可获得巴菲特推荐经典理财书籍\n说一下3天连续作业的福利\n之前我一直说，我们有了财商的人就不要用微信、支付宝理财了。\n那我们投资理财需要通过国家的正规证券交易账户才能完成，证券账户是每个人理财必备的工具。\n我们的奖励就是\n【完成前3次晚课打卡作业的奖励】从老师提供的华泰证券开户优惠链接，开户免费，自愿，交易才会产生佣金，佣金是给证券公司的。\n如果有的可以选择一《富爸爸财务自由之路》电子书，做完作业的，私发老师你要那个奖励哈\n【注】只有完成前三次晚课作业的同学才可以找我领取哦\n如果你想学懂了再开户也是可以的\n补交作业后也可以找我领取\n一定告诉老师你要哪个奖励哦\n要不然把你漏下\n大家把下面这段话都收藏好哈，接下来要做一名价值投资者，投资这八步走，一步不能少，少了容易被割韭菜哈\n正确系统的投资技能包括：\n①理财的底层逻辑、富人思维\n②股票的海选\n③精选出好公司\n④财务报表分析\n⑤企业分析\n⑥计算好价格\n⑦制定买进标准\n⑧制定持有标准\n⑨制定卖出标准等\n最后老师提示一下：对于没有经验的小白，先开始掌握无风险的理财工具就可以了，后面随着认知能力的提升，再开始操作低风险高收益的理财工具！\n因为我们虽然身体长成了大人，理财方面，大家还是个小学生\n我们的教育中没有理财的知识，所以大家现在才开始学，不懂不要乱操作！！！这句话一定要深深的刻在脑海里️\n老师会一条一条看的 \n和前两天一样哈,把打卡的截图发给我,我会给你们做总结\n大家作业打不开的刷新一下哈\n【心得作业】\n前三天课程已经学完了，请每一位同学根据所学到的知识，结合自己的【个人财务状况体检】和【三个最重要的财富目标】，写一篇学习总结。学习总结字数不限，但一定要写！\n@所有人\n【第4天】晚间提醒\n🤗【今晚分享】财务自由的三大核心工具\n【明日晨读好文】《怎样越花越有钱》\n【重要链接】xxxxx\n【作业三】：xxxxx\n心得作业认真思考并完成哦\n【晚安心语】选对了投资工具，时间就是财富的朋友~\n要想选择生钱资产类型的股票和REITs，财报和企业分析是不能少的，明天咱们就该学财报了，一定要准时参加\n\n私发交作业后，给的总结\n\n老师知道这么多的工具，有点懵懵哒。不要纠结那么多的工具，只要记住高风险的工具，咱们不要碰。低风险和无风险的工具就可以让我们实现财务自由，最重要的要记住以下，『财富自由三大工具』，『现金理财的黄金组合』『小白标配指数基金』就可以了。\n同学想要哪个奖励？\n快点击下面的链接，输入密码领取自己的电子书学习奖励吧\nhttp://xiaobai.yaocaiwuziyou.com/Site/page2.html\n( 富爸爸财务自由之路 4325 )\n我当时打开这个链接，ctrl+u，查看源代码，获取到了他们所有电子书。这些电子书，我就放本文最底部，点击就可下载\n前三天的课程上完了，你表现的很好。我发给你一个【财务自由纲领】，这个纲领特别的好，你结合前三天的课程尤其是三大资产的内涵和实现财务自由的三大核心工具的来看会有很大收获的，一定要看哦\n\n给的一个二维码，文件见本文最底部，点击下载\n\n六、第4天\n6.1 晨读\n\n晨读文章\n\n\n怎样越花越有钱：点击查看\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n凡事皆有因果️\n但请你对你自己人生负责\n没有人会替你过生活\n如果你的支出大部分都是坏支出，你的钱怎么会越花越多呢？??\n如果你从来不在自己的健康上投资，你怎么有个好身体呢？??\n如果你从来不在技能、成长上投资，你怎么能快速提高自己的收入呢？??\n老师正在学习做一个会花钱的人\n希望各位小伙伴也能成为真正会花钱的人，活成自己想要的样子\n投资大脑，会让自己学习到某一领域有成就人的思想知识，相当于让自己站在巨人的肩膀上思考问题。\n大家要明白\n钱永远只是一种交换工具\n钱放在口袋永远不会让你变富\n真正让你变富的是生钱资产，是理财技能\n富人都是在让钱为自己生钱\n穷人才会拿着现金，让钱贬值\n所以富人越来越富，穷人越来越穷！\n各位好好体会一下\n我的分享就到这里 ，同学们可以分享一下自己的早读感悟了\n有理财技能，有方向，跟着老师一步步走，大家都必定会实现财务自由的\n大家可以想一下，要是5年前，你学会了投资，现在是不是会富有很多呢？\n同样，我们现在做的事就决定了我们5年、10年后的生活\n人活在世上，无非是追求两大健康，一个是身体健康，一个是财务健康，我们一定要在这两方面多投资才行，两方面健康决定了你日子是否会好过。各位同学，一定要牢记\n好了，今天的早读就上到这里\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n6.2 午读\n\n午读文章\n\n\n炒外汇投资骗局：点击查看\n\n6.3 晚修\n\n晚修预习\n\n\n牛X的财务报表：点击查看\n\n\n晚修讲解\n\n今天带大家学习了解认识财务报表，这里给大家几个学习建议：\n⭐1、别局限在里面的数字和计算中，这并不是重点，财报最重要的是看结构而不是数字和计算。\n⭐2、认真思考文章中各种家庭的财务情况，要联系我们学习过的积蓄不多的人、中产家庭的财务危机\n⭐3、联系实际想一想自己家庭的财报是什么样\n老师给大家分享两位同学写的大作业  写的非常好 这是一段对自己的总结，不只是这三天的总结  大家也一定认真哈  大家可以看下这几位同学的作业 互相学习\n学习理财心得体会1:\n无意中在微信中看到理财网络学习课程，看到12元学习12天课程，抱着试一试的心态参加了前三天的学习。三节课下来，收获挺多。回头看看这么些年下来，自己依然没什么资产，就觉得很失败。课后剖析原因，一是没有富人思维，没有投资理财技能，没有消费自控力。二是在没有认真学习理财知识就盲目投资，跟风买股票，却因工作原因没法操作，以至于听之任之，以至于亏损。三是太容易相信别人，以至于被骗，走进了别人挖的坑，造成了无可挽回的经济损失。\n通过这三天的学习，可以说是颠覆了我的理财思维，感觉必须学习投资知识，提高理财技能，才能积累财富，不一定能达到财务自由的地步，但一定会比以前好很多。我会继续努力学习的。谢谢逸鸣老师\n逸鸣老师，感谢这3天的课程，通过这3天的课程，觉得自己在投资理财的道路上很渺小，需要学习的太多了。\n学习理财心得体会2:\n以前没有接触微淼的时候，我也在接触理财，最初我会把钱放在余额宝，通过余额宝的利率获得收益，后台知道余额宝的利率比较低，微信的零钱通利率高，我就把余额宝的钱转到零钱通，后来在支付宝上买过定期理财，也有过定投，定投了90期，每周定投一次，一次金额20元，后来因为听朋友说大跌了，就下车了。再后来也接触过p2p的平台，接触了半年就退出了，这是我的经历。\n通过3天的微淼课程，听逸鸣老师的讲解，让我觉得豁然开朗。我之前是接触过理财，但是根本就想不明白其中的逻辑，跟着大家一起盲目投资。通过老师的讲解我明白了：\n1.穷人和富人最大的差异就是思维的差异。2.通过学习是唯一可以改变自己命运的机会，通过学习，可以提高收益率，收益率源于理财能力，理财能力才是决定复利终值的关键。3.要懂得划分自己的资产（生钱财产、耗钱财产、其他财产），扩大自己的生钱财产，通过非工资收入来支出耗材资产。4.不懂不要投，懂了安心投。\n这12天一定会跟着逸鸣老师好好学习，知识是学给自己的，感谢逸鸣老师每天的辛苦讲课和课后作业监督，老师辛苦了️\n大家认真看  每个人的感想收获 和经历都是不同的  但我们可以通过其他同学互相学习\n【为什么学财报】通过分析造假的常见科目，比如前段时间暴雷的康美药业，其实如果仔细看过财报，就能发现公司账上有大量的货币资金，但是却借了很多钱，每年还要还很多利息，这就要怀疑货币资金的真实性了。\n再比如今年业绩暴雷的东阿阿胶，如果认真分析过财报，就能发现东阿阿胶的应收账款大幅增加，存货居高不下等都是有问题的。\n前段时间暴雷的东阿阿胶，其实18年就已经分析出它的财报有问题了。这是18年4月份的聊天记录。大家可以看一下\n@所有人\n同学们，晚上好，开始签到：学好财报是选出好股票的关键\n同学们心得作业写的都非常好，我每一个都认真看了，还没有写的要尽快写了发给我哈\n首先，我们老规矩，回顾一下昨天的内容\n昨晚我们学习了4大类理财工具，我们投资主要选择哪两类呢？\n没错，我们实现财务自由，只需要用好无风险和低风险的工具就够啦\n哪三个是我们实现财务自由的核心工具呢？\n很好，企业 股票 Reits是财务自由三大工具\n是生钱资产的企业、股票和reits \n从今天开始，我们将展开介绍股票、企业、REITs三大核心工具\n首先我们从股票讲起\n其实不仅仅是股票，绝大多数的投资工具其实基本都绕不开的就是财报。\n财务报表\n就是一个公司的流水\n投资一家公司一定要看这家公司的流水，这家公司要赚钱，我们投资才有意义\n我们开始学习财务报表\n我大白话讲课，争取让每个人都听懂\n大家先看一下这两家公司2018年的资产负债表中的几个科目，看看哪家公司更好？\n\n\n\n\n直觉上：大家觉得哪家企业好？\n好多人是不是一看数字就晕了，妈呀上亿了，咋算\n其实不用管数字，我们也不用自己算\n财务报表是一个excel表格\n我们用公式一拉就出来了\n我先来解释一下四个名词：\n看完之后你们会知道原来是海天更好\n海天大家都知道产酱油等调味品\n假设同学是海天的老板\n⭐应付：【先用货，后给钱】\n我大海天要产酱油了，我没有黄豆了，我先跟供货商说，你把豆子给我，然后我晚点结账。帅吧！不给钱就能把豆子拉走了。\n意思就是我本应该付钱，我没付钱。简称：应付\n⭐预收：【先收钱，后发货】\n预收：预收款项。先收了经销商的钱，但是货还没有给。\n我跟经销商说，我酱油马上做好了，你先打钱，然后我再给你发货。快打钱，不打钱没货了啊，别人订走了。牛吧，先给钱后发货。\n提前收了别人的钱，就是：预收\n这就是实力的体现\n海天  供货商 经销商  三者之间的关系\n海天占主导地位\n各位老板，这样说能明白么？\n好，我们继续\n⭐应收：【先发货，收不到钱】，\n如果有一天我先发酱油给经销商，但是人家不给我钱，谁让他卖得好呢。哎不牛了。\n我应该收的钱，我没收到，就叫：应收\n⭐预付：【先给钱，收不到货】，\n哎，我黄豆钱都打过去了，黄豆还没给我呢，谁让人家黄豆好呢。不帅。不牛。\n我提前把钱打过去了，就是：预付\n应收+预付，是不是就证明，海天弱势了，这时候就不牛了\n海天  供货商 经销商  三者之间的关系\n这样清楚了么？\n多理解理解就好了，不清楚的下课多看两遍\n所以我们完全不用管上亿的数字\n掌握原理就好了\n这样我们表格就很好理解了。\n从表格中很明显看出，海天要比金螳螂在这方面好，具体的数字这里就不赘述了\n提前预习的同学应该知道了：\n海天味业是调味品行业的第一名公司\n金螳螂是建筑装饰行业的第一名公司\n虽然同是行业的第一名，但优秀程度是不一样的！\n优秀程度，我们可以从竞争力和安全性这两个方面来判断\n【应付预收】减去【应收预付】，就是竞争力\n这个金额越大说明公司的竞争力越强\n这个你们可别去手算啊，什么年代了还手算，用excel 加减法公式一拉就算出来\n相减得出金额越小，竞争力越弱\n那通过什么科目来判断公司的安全性呢？\n资产负债率\n♻️总负债÷总资产=资产负债率\n⭐️资产负债率大于70%的公司，偿债风险比较大\n⭐️资产负债率小于40%的公司，几乎没有偿债风险\n企业兴衰的本质归根结底还得看“兜里”有没有money！\n这里举个例子，我们看企业的时候可以看看我们自己家庭，其实大同小异的\n你有100元的现金，这时候你还有70元的债务，相比于只有40元的债务，如果遇到个意外要花钱，你（70元的债务）肯定抗风险的能力更弱，也就是财务的安全性差。\n这个很好明白吧\n不明白的地方先做好笔记，课下多看几遍就更清晰了\n接下来说：上市公司的财报！\n所有上市公司的财报都是必须公开的\n我们想看任何一家上市公司的财报都可以\n在哪看呢\n推荐下载上市公司的财报地址：http://www.cninfo.com.cn/new/index （巨潮资讯网）\n操作步骤：进入巨潮资讯网—输入公司名称或代码—点击更多（选择财务报表）\n\n提示：大家先把网址和步骤收藏，知道怎么查看就行\n不需要分析，现在的段位还不够分析的哈\n⛈很多同学，第一次看到完整的财报的时候，一定会有些惶恐，因为有很多页！\n✍️其实，看财报有方法，记住：\n【看财报重点看结构，而不是看数字，看财报有23个具体步骤，按步骤来就可以看懂】 \n【看结构也一目了然了，看数字谁看谁晕】\n\n\n财报分析的23个步骤\n23个步骤拿出来讲都需要讲一天\n大家一晚上弄懂是不现实的\n各位想一想，现在就是知道了【竞争力】和【安全性】的知识点，就会比什么也不知道就瞎买的人好很多！\n大家要明白：股票的本质就是企业，买股票就等于买企业\n学好财报才能分析出好公司，好股票\n好公司的股票才是好股票，才是我们投资的重点对象\n我这里讲的【竞争力】和【安全性】是可以用来淘汰那些你们蠢蠢欲动要买的自以为好的“坏公司”，但是不是直接用来选股，因为财报肯定不只这两个指标，选择一家好企业肯定也不止这两个指标。\n所以大家别贪图快钱，就拿了这2个指标去选，小心被割韭菜，还是要谨记我们的投资第一原则哈！\n不懂不要投，懂了放心投\n不懂不要投，懂了放心投\n不懂不要投，懂了放心投\n给你们看我在选股的时候我做的23个步骤财报分析。\n\n老板电器财报分析.docx：点击下载\n\n1分钟大家看一下\n大家可别被吓到了哈\n看完的吱一声扣个1\n现在看不懂正常\n不要被吓到，也不要盲目购买，你们学完23个步骤，也可以轻松做出这样的分析\n的目的是想告诉你们。你们的钱来之不易。不能轻易乱投资，学会了再说。钱是我们花时间挣来的。时间就是生命。\n你要是乱投资，你就是在浪费生命。一定要珍惜自己的钱。\n学会了再投资。先好好学习\n… 省略，讲进阶课课表 …\n财报需要10周的学习时间\n现在大家只要知道财报是选出好股票的关键就可以了\n我们课程继续哈\n财报的用途不仅仅是投资，找工作也能用到\n跳槽的时候，可以先通过财务报表看一下这家公司是不是一家好公司\n找工作，其实也是一项投资，上班投入的是时间，时间才是最宝贵的资源。\n投入的时间最后能获得多少回报，一方面和自己创造的价值有关，一方面和公司的好坏有关✔\n有的同学可能会说，我要找的公司没有上市呢，怎么去看它的财务报表呢？\n️如果想要跳槽的目标公司没有上市，那就看一下同行业的上市公司！\n如果同行业的上市公司情况比较好，那么这个行业可能就比较好\n如果连同行业的上市公司情况都不太好，那么目标公司你就不用去了\n在好行业的好公司，你就在一列高速行驶的高铁上，你能跑多快其实是借助高铁的速度。\n反之，选择坏行业的坏公司，你就算是短跑世界冠军，一个人的力量也无法对抗行业和公司的沉沦。\n这就叫选好赛道，方能事半功倍，工作也好、投资也好，一定要学会借力！\n之前讲的站在巨人的肩膀上学习理财投资也是借力，\n就像现在大家借的是【封老师复旦大学金融科班出身，又有实战十年的财务自由经验，而且还是在行平台理财领域全国评分第一名的行家】的力！\n跟着已经财务自由的人学习，总没错的\n微淼现在是财商教育第一的公司，大家放心学就是，不会错的\n\n看一下我上个月的工资单\n这就是选好赛道价值，获得工资收入。\n原因是微淼正在以每月100%的速度增长，公司的利润持续增加\n这就是选择好企业的重要性\n【通过财务报表就能读懂自己和别人未来的财运】\n\n建议同学们把这张高能的图片都保存一下，当你犯懒的时候，不想学习的时候，可以打开这个图片想一想哈！\n大部分关于【钱】的问题，我们都可以从财务报表上找到答案\n人也是有财务报表的\n你可以通过他的财务报表分析一个人\n有对象的你可以分析你的另一半\n他是生钱资产还是耗钱资产\n没找对象的也可以分析与你相亲的人\n️通过财务报表，我们不但能够了解一个人，一个家庭现在的财务状况，而且在某种程度上我们还可以预见到一个人，一个家庭未来的财务状况。\n问个问题：假设现在你面前一个人，他有很多资产\n那么他是富人吗？\n耗钱资产过多的就不是富人\n有好几辆车，有好几套房，要是全是贷款的呢\n车奴房奴\n☄️富人指“生钱资产”在总资产中的占比大于80%的人。\n☄️中产指“生钱资产”在总资产中的占比小于80%的人。\n牢记：有无资产，拥有什么类型的资产，决定了一个人最终会成为什么样的人\n看你的另一半，就看他有什么资产\n一身生钱资产，那你有福了\n要是全是耗钱资产\n那就凑活过呗\n努力把自己培养成生钱资产\n用你这个生钱资产来养耗钱资产的另一半\n努力把自己培养成生钱资产\n加油\n那孩子是啥资产？\n孩子的财商教育要从娃娃抓起\n培养成未来你的生钱资产\n再回顾一下中产的财务报表：\n\n中产的家庭财运预测如下：\n1️⃣ “耗钱资产”规模将会越来越大，现金流出也会越来越大，所以中产不能停止工作。\n2️⃣ 中产没有改变自己资产结构之前，不能实现财务自由。\n3️⃣ 让“生钱资产”在总资产中的占比达到80%以上，中产也能比较容易实现财务自由。\n其实财务自由离大家并不遥远，只要你掌握了选择生钱资产的技能。只要不断拥有生钱资产，加以复利，都会实现财务自由\n️其实掌握了正确的方法和思维，财务自由只是时间问题！\n要是你从10年前开始理财投资呢？\n虽然财务自由不会马上实现，但是你手里的生钱资产会让你的财务状况越来越好\n每天都进步一点点，就是好的\n你手里的生钱资产会让你的财务状况越来越好\n生钱资产给你带来源源不断的现金流，就好像给你发工资一样\n\n是不是像发工资一样\n这就是生钱资产\n学好理财，你也可以\n我们再来看一下富人的财务报表：也是你们未来的财务报表\n\n️我希望你们未来是这样的\n️富人，擅于区分“耗钱资产”、“其他资产”和“生钱资产”，擅长创造“生钱资产”。\n用生钱资产给自己生钱\n可以根据自己的喜好选择上不上班\n这是我们的奋斗目标\n不要觉得成为富人遥不可及\n大家掌握了理财技能，升级了思维观念也能变成富人\n这个时代的铁饭碗其实是高财商，扎实的理财知识。\n就像现在疫情这么严重，只有会投资的人的现金流在源源不断\n现在大家应该知道了什么样的人在未来一定能实现财务自由吗？\n有了富人思维，又精通理财技能的人未来一定会实现财务自由\n你们现在富人思维基本有了\n接下来需要系统学习理财知识\n子孙三代具有富人思维和技能，都能准确识别生钱资产，并一直维持生钱资产占总资产的比率大于80%的家庭会富过三代。\n我们虽然不是富二代，但要先成为富一代\n希望同学们都要认真学习理财技能\n让自己的家庭富过三代、四代~~~~\n好了，我总结一下今天的课程\n【第一个重点】\n通过财报看企业，用安全性和竞争力淘汰你手里的坏企业。\n【第二个重点】\n学好财报是选出好股票的关键\n【第三个重点】\n无产、中产、富人是可以相互转换的，学好理财技能就能由穷转成中产，由中产转成富人。\n记住这三个重点，今天的课就ok了\n最后跟大家说一下投资的正确步骤\n正确系统的投资技能包括：\n①理财的底层逻辑、富人思维\n②股票的海选\n③精选出好公司\n④财务报表分析\n⑤企业分析\n⑥计算好价格\n⑦制定买进标准\n⑧制定持有标准\n⑨制定卖出标准等\n这几天内容很多，但都是可以实现财务自由的关键。理财知识是需要系统深入学习的，肯定不是几天就能全部学会的。\n12天小白营课程主要是让同学们建立正确的理财底层逻辑的，初步形成富人思维，让同学们对理财最重要、最核心、最底层的东西有正确的认知，以后理财的时候不再掉坑。\n今晚的财报是帮助大家排雷的，这个技能是筛选优质生钱资产的灵魂，\n今天简单介绍了两个指标，有难度不要害怕，因为一天把财报这个工具就掌握了是不现实的。财报分析也是后面需要系统学习掌握技能。\n现在就是脱白，先弄明白概念就行啦\n建立好思路和底层富人思维逻辑。\n明天带大家好好学习股票\n让大家看清股票到底是个什么样的东西\n学懂了，大家就不会再害怕股票了\n【作业奖励提示】\n3天连续完成作业：可获得开户奖励\n10天连续完成作业：可获得巴菲特推荐经典理财书籍\n@所有人\n【第5天】晚间提醒\n【今晚分享】牛X的财务报表\n【明日晨读好文】《无论投不投资，你都是在投资 》\n【作业四】链接：xxxxx\n【重要链接】学习资源汇总xxxxx\n【晚安心语】财务报表是股票、家庭、人生的体检表，读懂财报就能读懂股票、家庭、人生未来的财运。\n\n私发交作业后，给的总结\n\n咱们这节课要抓住重点。知道读懂财报的好处就可以了。不用纠结看不懂财报，咱们这23个步骤是需要10周才能学完的，咱们也还没开始学，看不懂很正常。咱们小白营，主要是帮助同学脱白。咱们先建立好底层逻辑和框架。不懂的地方呢，多看一看老师课上举的例子，这样就会清晰很多了\n七、第5天\n7.1 晨读\n\n晨读文章\n\n\n无论投不投资你都是在投资：点击查看\n\n学会理财技能练就了一双慧眼，学会分析，它们就会显出原形。\n昨天我们学的财报就是一个重要的分析工具\n并且，我强烈建议各位小伙伴们从今天开始，坚决抛弃“买股票、买基金是开始投资”的错误思想\n牢记我们从拥有【第一笔】【第一笔】【第一笔】的“钱”的时候，就已经开始了投资。\n你存银行、存余额宝、买的理财保险其实都是你在投资\n只是这些收益率比较低，跑不赢通货膨胀\n本质上还是在亏钱\n好公司的股票、好REITs都是优质生钱资产，能持续稳定的生钱。这样养鹅才能不断下出大金蛋。\n所以，每位同学要提升自己的理财技能，才能让自己的财富越来越多，对自己的学习负责，对家庭负责，对未来负责。\n千万不要让通货膨胀一点点吃掉你辛辛苦苦赚来的钱\n千万不要让通货膨胀一点点吃掉你辛辛苦苦赚来的钱\n千万不要让通货膨胀一点点吃掉你辛辛苦苦赚来的钱\n学习投资，学习保护自己的资金\n学习跑赢通货膨胀这个吃钱机器\n通货膨胀、货币贬值对谁的影响最大呢？这个视频给出了答案\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n大家看完可以发表自己的感悟啦\n只有掌握正确的投资理财姿势，才能在通货膨胀的竞争中立于不败之地 ，接下来继续坚持好好学习 掌握 正确的投资姿势 ，去识别并拥有生钱资产这只大鹅 。一起努力吧\n通货膨胀对于投资最大的警告是什么？\n锁定相对高的利率还是要找收益率高的，但当你年化收益率低于10%时，你其实还是在亏钱\n当你年化收益率低于10%时，你其实还是在亏钱\n\n学习的苦需要主动去吃，生活的苦，躺着就来了\n\n视频分享\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n看看这个视频，虽然说的是2019，但是2020年同样适用\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n穷人什么苦都能吃，就是吃不了学习的苦\n富人只吃学习的苦\n所以富人越来越富\n同学们相互监督，一起学习，一起进步\n7.2 午读\n\n午读文章\n\n\n虚拟货币投资骗局：点击查看\n\n比特币我们说过是高风险的投资工具，今天的日防一骗就讲类似的虚拟货币，大家要好好学哈，凡是不在国家交易所交易的标准化理财工具，我们一定要远离哈！\n\n\nYour user agent does not support the HTML5 Video element.\n\n7.3 晚修\n\n晚修预习\n\n\n反常识ー一股票暴跌收益会更高：点击查看\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n晚修讲解\n\n分享@没事儿晒太阳 同学的感悟  大家认真看一下\n学习理财知识心得:\n在进入微淼财商训练营之前，我自认为是一个有理财意识的人，也就是有理财想法的人，虽然我的年收入不足8W，每月的固定工资不足5000，但是我每月会定额存款，我给自己买保险，对非生活必需品的欲望很低。我今年42岁，已经在国企工作超过20年，但由于对自身的投资不足，至今仍然只是个普通蓝领，也就是个一般的技术工人，预计10年后我的退休金也不会超过7000元/月。加上人到中年，身体也出现大小问题，还有孩子的教育，老人的养老…想想都焦虑。于是，我增加了一些收益率看上去比银行存款多一些的投资手段，每月拿出1300元基金定投，买了保险公司的理财险（要到80岁才能拿回本金和利息），还跟同学一起做过安然直销，折腾得自己心累，投出去的钱，却都打了水漂。我和老公的收入相当，他见我太折腾，不放心我管家里的钱，总是在抱怨，于是除了家庭生活的必须支出平摊外，我们夫妻的财务基本是AA制的，各管各的钱，其实我知道，他所谓的投资也不过是跟风买股票和基金，而且也是赔的多，可是对于我们两个中年国企员工，稳定的收入和固定的生活模式已经麻痹了我们的思想。这两年我在考虑提前退休，趁自己还能折腾得动，做点自己真正感兴趣的事情，可是提前退休到正式退休之间我每月只能拿到很少的生活费，我不能指望老公会用他的钱来养我，我一定要养得起自己才行。很偶然的机会从一个公众号的推送上看到了微淼财商小白训练营，12元的学费还不够孩子吃一只汉堡的钱，我果断报名，没想到只听了三天的课，就已经完全颠覆了我的金钱观，原来我的身边全是穷人！从小到大从没有人给过我这样的金钱概念，社会和家庭，包括最爱我的父母都是教育我要视金钱如粪土，金钱不是万能的；而现实生活却在无时不刻地提醒我：没有钱是万万不能的，穷才是万恶之源。这三天的训练课程，从早到晚的信息、链接文章、视频我都要反复看好几遍，重点的也认真的记在笔记本上，把老师说的触动我的话都收藏起来。我很感激这一次的遇见，让我在这个非常时期能静下心来好好地充实自己，为实现自己的财务自由这个由来已久的梦想踏踏实实地迈开脚步！佛教讲，菩萨看因，凡夫看果，然而所谓因果，还要靠个人的修行。加油！\n今天带大家学习股票的核心关键，这里给大家几个学习建议和提示：\n⭐1、文中的表格与计算如果看不懂没关系，并不是重点，表格里的数据只是用来论证结论的，只要记住结论就可以啦\n⭐2、思考两个问题，我们课上提问、讨论\n股票是不是真的高风险、不能碰，为什么那么多人亏？\n这节课的核心内容用一句话提炼出来是什么？\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n@所有人\n同学们，准备晚课签到，签到内容：与好公司一起成长，做价值投资者\n12天课程进行了一半了，你已经站在财务自由的大门口了\n千万不要半途而废\n昨天我们讲了财报，财报是看一个公司的过去和现在\n没有看过财报的不能称之为价值投资者。\n大家不必纠结于数字计算，真正看起财报来不用我们自己计算\n我们只需掌握我讲的重点和富人思维就够了\n学好财报是选出好的股票的关键。\n其实，买股票的本质就是买公司。\n那股票到底是一个什么东西呢？我们现在开始今天的课程\n投资选择股票，就要先弄懂股票\n第一个重点：认识股票\n【股票】是公司的所有权凭证。持有股票的人是公司的股东，拥有公司的一部分。\n可以说你持有一家公司的股票，你就是这家公司的股东\n持有股票比例最多的人，是这家公司的大老板，持有少的人是小老板\n举个最简单的例子：\n你和张三、李四、王五合伙开餐厅，每人出资2.5万，一共10万，那么你就拥有25%的所有权。\n假设1单位股份价值1元，那么你就拥有该公司2.5万股份。\n为了防止赖账，你们拟了一个证明，证明每个人拥有2.5万股份。\n股票的作用就类似于这个证明。\n那么企业为什么要发行股票呢？\n继续上面的例子。你们四人合开的餐厅，一共投入10万，餐厅经营得很好，每年可赚2万，回报率20%。\n你们掐指一算，按照20%的回报率，如果投入1000万来扩大店面或开连锁，那每年就可以赚200万\n于是你们想方设法找钱，\n但终究资源有限，可用于抵押的资产又不多，也借不到钱\n那怎么办？还能去哪里去找钱呢？\n这时候你想，既然餐厅收益这么好，如果在网上发个帖子，告知所有人我们的项目：投10万即可赚2万，那肯定很多人都来投资！\n你所想到的这个模式其实就是发行股票\n也就是IPO，首次公开募股\n这么说明白吗？\n好的，很简单哈\n继续\n企业发行股票的主要目的就是为了融资！\n股市是什么意思？\n股市相当于是一个公开的“菜市场”。\n中国A股市场有两大交易所，分别是上交所和深交所，相当于两个“菜市场”。\n这两个“菜市场”的作用就是让大家更方便地买进或者卖出股票\n比如你手上有100股某家公司的股票，但是现在手里需要用钱，想要卖出去找谁呢？你并不知道谁想要买你手中的股票！\n这就有了股市\n股市很好的解决了这个问题，让买卖股票变得非常的方便\nA股交易时间是每周一到周五，早上9点半到11点半，下午一点到三点，节假日休市\n股市就是方便大家交易股票的菜市场\n以上就是股票和股市\n是不是很简单，并没有那么高深\n跟买菜差不多\n但是不同与菜\n投资一家好公司的股票，成为这家公司的股东，也是实现财务自由甚至是成为富豪的重要途径\n那我们投资【好公司】的股票赚的是什么钱呢？\n①【公司持续的现金分红】\n②【股票价格上涨带来的价格收益】。\n投资好公司的股票光现金分红就可以获得15%以上的年化收益率。\n再加上价格上涨带来的收益，年化超过20%是很正常的事情。\n\n比如这家在A股上市的公司就是非常优质的生钱资产\n它的股息率为14%，意思是每年光现金分红的收益率就有14%了，\n如果加上价格上涨的收益，年化收益率超过15%，甚至达到20%是很正常的\n为什么股票的收益率那么高呢？\n因为一个国家GDP的组成中，企业是【创造价值最多】的部门。\n大家想一下，一国股市的平均收益率是不是远远大于该国的GDP增长率的。\nGDP组成包括农、林、牧、渔，企业是创造价值最多的\n好上市公司的平均收益率 &gt;所有上市公司的平均收益率&gt;所有企业的平均收益率&gt;GDP&gt;银行理财收益率\n根据统计：\n中国的GDP大概6.5%以上；\n中国所有上市公司的平均年化收益率大概12%以上\n中国好公司的平均年化收益率大概24%以上\n这个逻辑关系大家ok吗？\n都很棒\n如果不想自己创业，想比较舒服的实现财务自由，好公司的股票是一个非常好的选择\n买了好公司的股票就相当于中国甚至世界最优秀的管理团队为你打工\n有最优秀的人给你打工，那你赚钱不就是很轻松了\n那什么样的股票算是好股票？\n这次我先给结论，再来解释\n股票的本质是企业，好企业的股票就是好股票。\n股价下跌是市场的正常现象，只要公司利润在增长，这个公司就是有好公司的潜质\n我们看例子哈\n腾讯控股\n腾讯在刚开始成立的时候，只是一家做寻呼机的小公司，到今天凭借微信、QQ两大社交软件，成为中国最大的互联网公司之一。\n我们来看一下腾讯过去16年的净利润\n\n\n腾讯2004年当年的净利润4.2亿，2018年全年净利润多少呢？\n腾讯2004年当年的净利润4.2亿，2018年全年净利润多少呢？\n高达896亿！\n这样的一家公司，经营业绩不断提升，那么股价的上涨是自然的，我们来看下股价的表现！\n\n我们看到腾讯的价格最高达到2506元，而腾讯上市价3.7元，\n如果你在腾讯上市的时候花370元买100股腾讯，这些年一直傻持，那么到今天大概有17万，在最高点相当于25万元，\n厉害吧？\n这就是长期投资，跟随公司一起成长\n你要是高买低卖，根本不会享受这种价值投资\n腾讯虽然很厉害，但是现在已经不是好价格了\n最低点 和最高点\n但是\n中国股市中肯定还存在在下一个腾讯\n需要大家有了理财技能去识别并持有\n抓住一个机会就能改变自己的命运\n当然，有同学会认为腾讯这样的大牛股并不具有代表性，那我们再来看一个更普遍的例子\n中国股市建立之初，在上海证券交易所上市8只股票要，也就是所谓的“老八股”，分别是\n1、延中实业（600601），现用名方正科技\n2、真空电子（600602），现用名云赛智联\n3、飞乐音响（600651），现用名飞乐音响\n4、爱使股份（600652），现用名游久游戏\n5、申华电工（600653），现用名申华控股\n6、飞乐股份（600654），现用名ST中安\n7、豫园商城（600655），现用名豫园股份\n8、浙江凤凰（600656），2016年退市\n这8只股票表现如何呢？\n其中3只股票上涨超百倍，\n延中实业（600601）上涨超120倍，\n飞乐音响（600651）上涨超150倍，\n爱使股份（600652）上涨180倍，\n申华电工（600653）上涨80倍。\n如果当时你把10000块钱，分成8份，分别买入买入这8只股票\n那么你今天大概能获得43万\n年化收益率约为15%，这个收益率远远超过市场上的理财产品！\n厉害吧\n这还只是“随便买”的结果\n闭着眼睛买\n如果你会选择好公司，并且知道如何制定投资标准，那么收益率会更高！ \n那如果买了好公司的股票之后股票持续大跌怎么办呢？你担心吗?\n同学们根本不用担心你买的好公司的股票大跌会亏钱。\n你会因为好公司的股票暴跌而暴富！\n好公司的股价下跌，是你赚钱的机会\n我们还是看例子吧。\n通化东宝\n为什么拿通化东宝举例呢？\n主要是通化东宝很普通\n普通的意思是它不是特别优秀的公司。市场同类竞争对手多，在上市公司中并不算很好的公司，最多算是中等偏上，比较有代表性。\n其次是通化东宝股价波幅比较大，经历过大跌\n\n可以看一下它的股价走势图\n跟心电图一样\n只看趋势就行\n从2003年7月1日到2018年6月30日15年之间，仅腰斩以上的跌幅就有5次，平均每3年腰斩一次\n腰斩就是股价跌一半\n通化东宝2003年7月1日的收盘价为7.64元。\n假设你在这天投入7.64万，买入1万股，买入后股价一路下跌，最低跌到了2.95元。\n2年时间浮亏61%，够惨了吧？\n⭐但，你是长期的价值投资者，你看了通化东宝的财报，分析出了他是好公司\n你买入后持有不动至2018年6月30日，你完全不管股价的波动\n你所做的，只是在每年收到分红时，直接按照当时股价把你的钱全部买入通化东宝的股票\n也就是分红再投的意思\n分红给你的这些钱全部买入他家的股票。\n经计算，至今你持有80323股通化东宝，\n按照2018年6月底收盘价23.97元计算，当前市值192.5万元，15年的年化收益率24%\n\n看到了吗\n股价这么跌，竟然还有24%的年化收益率\n这不是假设，是根据真实的历史分红数据得出来的\n所以不用担心股价暴跌你会亏钱，其实只要买到了好企业，股价跌的越多，你的收益就越高。不可思议的高，瞠目结舌的高！！！\n虽然通化东宝的股价一直在暴跌，但是通化东宝的利润是一直在增加的\n这个看他的财报就看得出来\n他的分红也是持续的\n股价越跌，它的股价变的更低，你可以拿着【分红的钱】再以低价买入更多股票。\n这时候你得到的股票数量就越多，分红是按照【你持股数量】分的。\n股票越多，分红就越多。\n股价和利润没有关系\n分红越多，股票就越多。\n所以一定要系统分析，选出好公司\n股价下跌是市场正常现象，就像白菜、猪肉价格一样\n比如，一股分红1元，你有100股，就可以分红100元，此时股价暴跌。\n你拿着这100元的分红又买了50股的低价股，你就一共有150股了\n公司下次分红你就会收到150元现金分红。\n就这样周而复始，股价越跌，你的收益就会越来越高\n所以完全不用担心好公司股价下跌\n股价下跌不是风险，公司利润减少才是风险\n但是但是但是\n前提是【好公司的股票】。\n一定要记住前提是【好公司的股票】。\n烂公司股票越跌才真的越亏\n如果你选的是垃圾公司（如学习链接中的金杯汽车），利润不断下降甚至是亏损的。这个时候股价暴跌就是真亏了。你是赚不了钱的。\n所以！投资股票真正重要的，是选出好公司！\n所以！投资股票真正重要的，是选出好公司！\n所以！投资股票真正重要的，是选出好公司！\n刚才有同学问。公司利润在上涨，为什么股价下跌\n问大家个问题：股价和公司价值有关系吗？\n真的有关吗？\n听我讲一下公司市值和公司价值的关系\n你们就知道了\n公司市值是反映了市场在某个时期对这个公司的看法。也就是股价的表现\n公司价值就是这个公司到底值多少钱，和公司利润相关。\n这里再拿之前的你们四个人开的餐厅举例：\n你们的餐厅经营的很不错，一年能帮你赚100万，于是市场上有人出1000万买你的餐厅，你不愿意卖，因为你在赚钱。\n第二年你开了一家分店，两家店赚了200万，但是由于市场行情不好，现在市场只愿意出800万买你的餐厅，你愿意卖吗？\n这个1000万到800万就是你公司的市值\n股市上的表现就是你公司的股价下跌了\n跌了200万\n但是，注意，\n你们餐厅的利润却在增加\n去年赚100万，今年200万利润\n那么现在你在乎他给你出多少钱买你的餐厅吗？\n你在乎餐厅股价是多少吗？\n这就是市值和价值的关系\n所以股价和公司关系，并不大\n股价下跌是正常市场现象\n就像白菜、黄瓜的价格有波动\n所以在股市上你公司的股价下跌，但你亏了吗？\n你还在赚钱\n所以股价涨跌不重要，真正重要的是这家公司好不好，未来能不能赚到钱。\n大家投资股票，一定要把这家公司当成你自己开的餐厅\n只需要关心这家公司的经营怎么样，而不要被股价的下跌吓到，更不要被股价的上涨所诱惑。\n把这家公司当成你自己开的餐厅\n跟着这家公司一起成长\n了解这一点之后，大家以后还会在意今天股价为什么跌了、为什么涨了吗？\n现在大家还会在意股价走势图上面的红绿柱什么意思吗？\n还会在意今天的账户好像比昨天亏了一点钱吗？\n总之一句话，和股价相关的不要纠结，你唯一需要知道的就是这家公司内在到底怎么样\n大家消化一下\n财报分析和企业分析\n选择一家好公司要经过系统的分析\n一家股票有没有分红是公司决定的，不是咱们来决定的，咱们可以在雪球APP上查询\n并不是所有的好公司都有分红的，就像Facebook就是没有分红的\n这节课的整个逻辑是：\n好公司的股价越跌越好，可以用每年得到的分红去买更多股票，这样未来就能收到更多股息。好公司持续下跌会提高长期收益率。\n如何才能分析出好公司的好股票呢？\n学好了【财报分析】、【企业分析】方法（特别是关于商业模式、护城河、领导者、团队的分析）才可能选出好公司\n【财报分析】可以看出一个公司的过去和现在。\n【企业分析】可以看出一个公司的现在和未来。\n没有看过财务报表，不足以称之为投资者。\n判断一个投资者是否入门，就看他是否看过财务报表。\n\n老板电器财报分析.docx：点击下载\n\n这是我昨天分享的选出好公司的23个步骤\n大家抽时间再看看\n明天带大家学习企业分析\n好了，到了我们的关键富人思维的压轴重点了\n我们【投资股票正确的步骤】：\n①理财的底层逻辑、富人思维\n②股票的海选\n③精选出好公司\n④财务报表分析\n⑤企业分析\n⑥计算好价格\n⑦制定买进标准\n⑧制定持有标准\n⑨制定卖出标准等\n这个一定要牢记\n想要投资一个好公司\n这些步骤一个都不能少。\n为什么股市里流行着“七亏二平一赚”的说法？\n这主要是因为大部分人买股票的姿势不对\n大部分人没有系统的学习过投资技能，投资理念不正确，很容易走上投机的道路。\n他们的表现为：关注股价的短期波动，频繁地交易买卖，追涨杀跌，不仅损失惨重，更会让自己精神崩溃。\n跳楼的也有\n其实投资股票的钱并不难赚，只要大家掌握好技能，赚钱的机会多得是。\n其实投资股票的钱并不难赚，只要大家掌握好技能，赚钱的机会多得是\n机会永远是留给准备好的人\n最后一个问题：买了股票要不要天天看股价？\n公开荐股是犯法的\n都是未来的价值投资者\n完全不用经常看股价，为什么？\n同样的一家公司今天和昨天有什么区别吗？\n除非有了重大变故\n公司还是那家公司，股价却不一样，这个股价有什么好看的呢？\n很多投机者每天盯着股价看，这是一件很可笑的事情！\n股价是实时波动的，由于交易的人太多，有的人给这个价，有的人给那个价，所以短期的股价也在不停变化\n于是就有一些看似“聪明”的人，通过各种K线、均线等研究股价波动的规律，企图在低点买进来，高点卖出，最后损失惨重。\n一周看一次股价就差不多了\n投机者完全不看股票背后的公司，只是在预测股价的涨跌，本质是在赌博\n把股票当成一种赌博的工具，长期操作下去，不仅会让自己损失惨重，还很有可能难以承受股价的波动导致最后精神崩溃。\n之所以很多人热衷于短线投机，这与大部分人不懂理财有关，也与人性有关\n很多人认为自己本金少，于是只想要赚快钱，一夜暴富，但是这种方式最终不仅难以赚到钱，还会让自己的钱变的更少\n非常的危险，同学们一定要注意！\n【真正的投资股票】，是关注股票代表的公司的好坏，是看到股票背后的本质，经过严谨的分析得出的结论。\n这样的投资，即使短时间的价格波动也能心理踏实，最终能够获得复利带来的长期收益\n一句话总结：\n投资股票的正确姿势是靠分析，能选出好股票风险自然就小。赌徒在股市是把身家性命交给市场，不懂就投，肯定要被懂的人收割的。\n今天的A股里，未来盈利增长水平，能超过通化东宝的也不少。找出这些企业，长期傻持，你就能成为百万甚至千万富翁。\n改变自己家族的命运\n实现财务自由看似离普通人很遥远，工作很努力，但却离财务自由越来越远了，这真是一件很悲哀的事情。\n很多人努力工作了大半生也没有留下多少钱。\n其实普通人只要通过傻持一家好公司的股票就可以财务自由了。\n我们明天学习企业分析\n有同学学了股票就要跃跃欲试的想投资，说是不在乎盈亏，就想试试。\n老师提醒一下大家\n如果你还没有学会【财报分析】和【企业分析】，还不懂这些标准，建议你们慎重投资。\n不懂不要投，懂了放心投\n做完作业领取选股视频哈\n@所有人\n【第6天】晚间提醒\n【今晚分享】反常识——股票暴跌收益会更高\n【作业5】累计2次作业不私信我的要送机票喽~链接：xxxxx\n【明早分享】《8岁小女孩问倒巴菲特，为啥那么牛？》\n【补习链接】xxxxxx\n【晚安心语】股票的本质是企业，选择好的股票其实关键在于选择好的企业。\n\n私发交作业后，给的总结\n\n作业收到了，你已经连续5次交作业了，很棒，现在明白 为什么好公司的股价暴跌，收益会更高了吗？\n然后给了一个视频：\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n八、第6天\n8.1 晨读\n\n晨读文章\n\n\n8岁小女孩问倒巴菲特，为啥那么牛？：点击查看\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n这是前一段时间结束的一年一度投资界的盛宴伯克希尔股东大会。1个11岁的小孩，第2次参加股东大会和巴菲特的对话。\n财商教育也要从娃娃抓起，不过作为父母先要提高自己的财商哦，父母的财商是孩子财商的起跑线\n让孩子起点比别人的孩子更高？\n我们也同样反思一下，我们要留给孩子什么？\n留给他金山银山，一堆钱吗？\n如果他没有驾驭金钱的能力，不会理财，他是否能够守的住？\n如果留给他一堆钱，没有理财知识和驾驭金钱的能力，是否反而害了他\n在知乎上看到一段话，感觉很符合今天的主题，分享给大家\n[图片过期遗失]\n好了，老师的感悟就到这里，有感悟可以自由发表，各位小伙伴请输出自己的读后感吧！\n\n视频分享\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n深度思考反省写出来的感悟其实就是我们没有看透投资的本质，生活的本质，当你看透了，明白了，提升自己才是最重要的，钱并不是最主要，思维才是最主要的，富人思维让我们获得心理和财物的自由，成就了自己，你的孩子也会以你为榜样，家庭关系也会更好，你会遇见更好的自己的\n父母是孩子第一任老师，言传身教非常重要\n现在国家对于投资理财的教育也非常重视了，咱们班的同学已经都走在了前面哦，好好学习及早提高孩子的财商，让你的孩子们遥遥领先同龄人\n其实我们能给孩子最好的并不是金钱，是一种富人的逻辑思维，钱并不是传家之宝，而智慧，技能是可以代代相传的\n倘若大家从小就交给他正确的金钱观，教他辨别好支出坏支出，生钱资产，长大了他会有无限可能\n思维是最重要的因为人的思维会决定一个人的处事方式，也就会决定一个人的命运，所以大家一定要教会孩子富人思维\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n通过你的教育说不定你的孩子就会有机会成为富豪\n因为你的改变，你的孩子走上人生巅峰，小朋友因为你的熏陶变得更优秀，现在拥有富人思维，以后就是真正的富人，有了理财的知识，才能富过三代\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n请为你自己的人生负责\n只有自己拥有决定你自己人生的能力，趁早知道这个道理，你的人生就会过得更好，重要的是此时此刻，以及你愿意抓住此时此刻，接收此时此刻，忘记过去，迈步向前，请开始对自己负责吧，同学们\n最后给大家【加个料】\n中国证监会与教育部联合发布的关于“将投资者教育逐步纳入国民教育体系”\nhttp://www.csrc.gov.cn/pub/newsite/zjhxwfb/xwdd/201903/t20190315_352226.html\n伟大祖国已经意识到财商是刚需，作为我们普通人将来该给孩子留下什么样的财富呢？值得我们所有人深思??\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n看看这小孩对于财富的理解，通透不，比很多大人理解的通透的多，人生其实就是那么简单\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n分享给大家这个视频，好好看一下，作为父母的我们要怎么做呢？\n扎心的很，我们怎么做才能改变下一代的命运？\n\n这个图再送给大家\n我们课后反思一下，我们到底要留给孩子什么？\n留给他金山银山，一堆钱吗？\n如果他没有驾驭金钱的能力，不会理财，他是否能够守的住？\n如果留给他一堆钱，没有理财知识和驾驭金钱的能力，是否反而害了他呢？\n8.2 午读\n\n午读文章\n\n\n二元期权投资骗局：点击查看\n\n关键思维：\n二元期权的本质就是赌博，只不过不是赌输赢，而是赌涨跌。\n目前世界上的主流国家都没有承认其合法性。所以很多二元期权都是骗子平台。也是一台小白收割利器。\n同学们，想要投资理财是非常正确的事，但是一定要掌握正确的投资理财思维和技能，投资国家交易平台的【标准化工具】。\n8.3 晚修\n\n晚修预习\n\n\n升职？跳槽？创业？不懂企业怎么行？：点击查看\n\n\n晚修讲解\n\n@所有人\n亲爱的同学们，大家晚上好！我们开始晚课签到，签到内容：越了解企业，我就会越富有\n有电脑的同学准备好电脑，没电脑的可以下载I问财app操作\n咱们训练营今天都到第7天了哦，学习已经过半了哈，课程进入重要阶段了，掉队的同学要有点紧迫感哈~\n先给大家回顾一下昨晚内容\n第一题：好股票的本质是什么呢？\n投资好股票的本质是选出好企业！\n第二题 股价下跌是风险吗？\n好公司的股价下跌，是我们赚钱的好机会，关键要看是否是好企业\n股价越跌，它的股价变的更低，你可以拿着【分红的钱】再以低价买入更多股票。\n股票越多，分红就越多。分红越多，股票就越多。\n前提是：好公司\n选出好公司，要有一套科学的分析体系，分别是【财报分析】、【企业分析】。\n【财报分析】可以看出一个公司的过去和现在。\n【企业分析】可以看出一个公司的现在和未来。\n今天老师带大家认识一下企业。\n财报是分析企业过去的情况，让我们排雷，不要被劣质企业的股票忽悠了，买了劣质企业的股票就扎心了。\n企业模型是分析企业的发展情况，有助于我们低价买入非常有潜力的企业，买入这样的企业，后面的收益率是非常大的\n我先说一下为什么要学企业呢？\n【因为】买股票就是买公司，投资要学企业；打工族如果学了企业更有助于升职加薪，上班要学企业；创业者学了企业能大幅提高成功概率，创业也要学企业\n企业可以说跟每个赚钱的人都息息相关\n\n世界上所有赚钱的人基本都在这四类中\nE（employee）象限的人拥有一份工作，是雇员。就是打工者\nS象限（self-employed）的人为自己工作，是自由职业者。他们可能是包子店主，可能是水果摊主，可能是某个工作室老板。\nB象限的人都是大企业主，集团性的企业。比如腾讯，阿里巴巴的老板\nB和S有点相似，但有个最大的区别是：B象限的企业离开了B象限的人照样可以运行的很好，而S象限的企业离开了S象限的人就会倒闭。\n因为B象限的人比S象限的人更了解企业一些\n经营阿里巴巴和开个包子铺的区别哈\n最后我们来看一看I象限的人\nI象限的人让钱为自己工作，是投资家。\n大家可以想一下将来你要往哪个象限努力呢？\n我也希望你们都能成为投资人。让钱为你生钱\n李嘉诚说过，30岁以前靠智力和体力赚钱\n30岁以后就要靠钱赚钱了\n我们可以看到：这个世上的大部分人，无论是赚【工资收入】还是赚【非工资收入】，这些收入基本都和【企业】有关。\n企业是国家GDP的发动机，也是富人致富最主要的工具\n那么如果想要提高收入，就要了解企业。\n无论你是【打工者】、【自由职业者】、【企业家】还是【投资家】，\n你越了解企业，你就越富有\n这四个象限中收入最高的人都是最【了解企业】的人。\n同学们现在思考一个问题：在【2020年1年内】把自己的收入【提高3—5倍】，你应该怎么办？你觉得可能吗？\n其实很多人会说臣妾做不到呀！\n其实这也是穷人思维的一种局限性，记住：下次再想放弃的时候，问问自己当初为什么要开始❗❗\n富人会怎么想呢？富人此时想的不是我做不到，而是我怎么才能做到。\n\n记得收藏  时刻提醒自己\n说下我自己\n我刚进微淼的时候，月薪6000多，通过半年多的努力，现在是翻了8倍左右，还拿了几千分红股，公司上市后，这些分红股价值很有可能翻10倍\n\n我之前跟大家一样，也是小白，我都可以，大家一样也可以\n这就是选好赛道价值，获得工资收入。\n就像现在疫情，很多公司裁员，我们还在大量招人，原因是微淼正在以每月100%的速度增长，公司的利润持续增加，财商教育，微淼在中国现在是第一，未来也是第一\n是想告诉大家，如果大家在这半年内好好研究企业，学习【企业】相关知识，一年以后你的收入有可能会【提高3倍以上】的\n再问大家一个问题：假如现在微淼请你做CEO，在公司内部你有至高无上的权力，你也想把这家公司管理的更好，那么你需要做的最重要的事情有哪些呢❓\n其实当CEO也需要技能，如果你的技能不过关，即使让你做了这个位置你也很快会下来的\n了解企业，这个问题就很简单了，其实，做高层、中层、基层都是很像的\nCEO是在整体上去了解企业\n中层是在局部上去了解企业\n基层是在某个点上去了解企业\n那么，CEO需要掌握哪些技能呢？\n这就是企业分析工具——强大企业模型\n\n强大企业模型，包括9个关键要素：领导者、企业文化、治理结构、商业模式、团队、沟通、现金流、系统、法规\nCEO要掌握这9大要素\n领导者就相当于火车头，是最重要的因素\n其他8个关键要素都和领导者有着直接或间接的关系\n这9大要素共同决定一家企业的成败\n“强大企业圆模型”就像是一面镜子，企业怎么样，一照便知\n预习链接中以乐视为例分析了一下领导者、企业文化、商业模式和治理结构这四个要素\n前几年我还去乐视应聘呢，没想到乐视倒下的这么快，乐视的失败是和贾跃亭是息息相关的，足以看出领导者的重要作用\n同学们可以模仿着去分析一下你的企业或者你想了解的企业\n微淼的领导者就是封贺和王楼楼\n优秀的领导者一般具备，有识，有仁，有恒，有才，有志，有德\n同时企业文化也是很重要的\n给大家分享一下微淼的企业文化：点击下载文档\n感兴趣的可以看一看，继续上课\n【强大企业模型】主要有哪些作用呢？\n1、可以指导我们像CEO一样去思考企业的问题。\n2、可以指导我们【从0到1】创造一家企业；\n3、可以指导我们【从1到100】做强一家企业；\n4、可以指导我们看明白别人的企业，当我们想要【投资或者加盟】一家企业的时候，我们就更容易【做出正确的决策】。\n假如你用CEO的眼光看问题，你能不升职加薪吗？\n当今社会是个阶层越来越固化的时代\n普通人如何能快速逆袭呢？\n途径可能不止一个，但是了解企业，用好企业这个工具肯定是最主要也是最有效的一个。\n给大家看一下我投资的时候，做的企业分析\n\n老板电器企业分析：点击下载文档\n\n一分钟大家浏览下，看完的吱一声，扣个1\n我主要是用来给企业估值\n也就是说通过分析，看到这个企业的未来\n现在晕没事，因为这是需要学一个月的\n你连一个企业的未来都看不透，你会赚钱吗？\n在投资中，我们通过分析企业强大圆模型的九大要素，可以估算出建立在数据之上的未来几年企业合理市值。\n企业合理市值一旦确定，我们就可以估算出我们投资的回报率了，也就是我们每投入10000元，一年能获得多少收益，\n这个收益是体现在股票的价格收益上，这时候还没有算股息分红收益。\n因为投资一个企业带来的收益来源于两部分：【价差收益】、【股息分红收益】\n看透一个企业的未来，你说你赚钱还会远吗？\n大家现在可能看不懂，现在也不用都看懂，我想让你们知道。做企业分析是有方法的，只要学好了方法，就很简单。\n强大企业模型的9大要素，每个要素要详细的讲解清楚至少需要9节晚课的时间。\n同学们不用想着通过这节晚课就把企业搞明白了，这是不现实的。需要学一个月\n\n在学这节课的时候有些要素理解不了也是很正常的，\n这节课大家只要知道决定企业成败的9大要素是什么就可以了，先在脑海里构建一个正确的企业认知框架，这个是非常重要的。\n有了框架以后再针对性的去学习，这样就会大幅提高学习效率，学习的过程就是先了解再精通的过程。\n昨天提到了，学好了【财报分析】、【企业分析】方法（特别是关于商业模式、护城河、领导者、团队的分析）才可能选出好公司\n简单讲一下什么是护城河\n护城河也叫企业的核心竞争力，是竞争对手无法复制或模仿的竞争优势。\n护城河主要有4种：网络效应、转换成本、成本优势和独特资源\n目前世界上有70%以上的企业，这4种护城河一个也不具备。\n一个企业只要具有1种护城河就有强大的生存能力和较好的盈利能力。\n如果同时具备2种护城河，企业一定是行业龙头公司。\n同时具备3种或以上护城河的企业，这个世界上也不超过100家。\n长期持有具备3种或以上护城河的企业，想不赚钱都困难。\n以后我们投资企业，最好买具有3个或3个以上的企业，至少也要买具有2个或2个以上的企业\n同样，对应到我们的个人，同学们也可以思考一下，你自己的护城河又是什么呢？\n你的护城河就是你的竞争力，你在社会中、家庭中、工作中的核心竞争力和不可替代性\n只要你能打造出属于自己的1个护城河，你这一生不会差钱\n如果不知道从哪里下手的同学，可以先从理财技能开始。\n因为理财技能是每个人必须要打造的一个护城河\n你掌握了理财技能，你的个人价值就会变高，你就是你们家的生钱资产\n你的单位时间附加值就会更高\n想想你在家人中、朋友中，你周围的圈子中，你的地位会提高\n你也会慢慢的富有！\n就像今年回家过年，之前跟我话不多的亲戚，都主动找我要跟我学投资\n这就是我的护城河\n大家学好理财技能也是一样的\n你会发现围绕在你身边的人越来越多\n因为你变得优秀，他们都愿意和你在一起\n尤其是孩子，你变得优秀了，孩子耳濡目染，也会变得更好\n微淼的护城河就是财商课程\n因为是独一无二的\n是封老师十年财务自由的结晶\n最后我用一条关键富人思维把所有的内容打通一下\n为什么工作者、投资者都需要通晓企业分析技能？\n并不是创业者 、大老板才需要了解企业。\n普通人更需要了解企业\n【投资中】，股票本质是企业，只有把9大要素都分析清楚，才能分析出好企业，才能给企业估值。\n【工作中】，干工作的时候也要有企业经营的思维,这样才更容易升职加薪。\n总结一句话：上班者用企业分析模型看透工作，投资者用企业分析模型看透股票\n@所有人\n海选股票了  做好准备\n大家准备好电脑了吧。现在没电脑的，迅速下载app“i问财”\n想听的发朵玫瑰。人少我就不讲了啊\n\n首先打开爱问财，选股网站：http://www.iwencai.com/\n用电脑的同学打开链接\n没在的同学后悔去吧\n正确系统的股票投资技能包括：\n①理财的底层逻辑、富人思维\n②股票的海选\n③精选出好公司\n④财务报表分析\n⑤企业分析\n⑥计算好价格\n⑦制定买进标准\n⑧制定持有标准\n⑨制定卖出标准等\n先记住上面的步骤\n一共九步啊，逻辑思维就先不说了，我们学完小白营就有逻辑思维了\n下面我来拆解第2步 股票的海选\n咱们再开始筛选前先假定一个前提，就是所有的公司财报都是真实的\n是有前提的哦\n记住前提了吗? 就是所有的公司财报都是真实的\n看好啦，首先打开爱问财，选股网站 http://www.iwencai.com/\n大家记住这个网站，筛选股票就是在这个网站里\n好公司的第一特点是什么？\n当然是要赚钱能力强\n不赚钱我们投资他干啥\n行话叫：ROE，净资产收益率，也就是企业的盈利能力\n封老师说过一般要选ROE大于20%的公司。当然为了扩大选择范围，我们刚开始海选的时候可以把标准降低一些，我们把ROE设定为大于15%。\n第一个条件就明确了，在搜索框输入：连续5年的ROE 大于15%\n\n3500个公司瞬间变为118个公司\n选出来的发截图到群里哈\n好  继续\n好公司一定是即赚到了利润又赚到了钱的公司。也就是净利润现金含量比较高。封老师一般会选净现金含量大于 100%的公司。\n但是为了扩大选择范围，我们可以把净利润现金含量设定为大于 80%。同样这个 80%也要满足连续5年大于80%。\n下一个条件：连续5年的净利润现金含量大于80%\n条件不要删除啊，都要留在搜索框\n\n现在只剩下30家公司了\n好了，这30家公司\n那么请问大家，我们接下来要做什么了？\n一只股票买一手吗？还是看哪个顺眼就买？\n接下来就是分析财报了\n因为海选的前提是假设所以公司的财报都是真实的\n要是目标公司财报造假了，那你会被割韭菜\n所以 一定要好好学会财报\n学会了财报才能分析出是否造假\n投资一只股票的顺序\n股票的海选～\n精选出好公司～\n财务报表分析～\n企业分析～\n计算好价格～\n制定买进标准～\n制定持有标准～\n制定卖出标准\n大家记住这个标准。这才是你们选一只好股票的标准流程\n没看财报之前，一定要慎重\n财报是有可能造假的\n企业分析是用来给企业估值\n进阶课会详细教大家看财报和企业分析的，边学习边投资\n还记得之前发的东阿阿胶的造假吗？\n所以学好财报很重要，可以帮助大家排雷\n财务自由三大工具\n已经讲了两个了\n股票 企业\n只剩reits了\nreits比股票的收益还要高的\n好股票的收益大概在15%以上，轻松跑赢通货膨胀，让手里的钱不再贬值\n明天晚上，我就给大家讲REITs\n瑞子（REITs）可是小白投资神器\n很多同学都在问进阶课的事情，我会给大家申请到优惠名额\n明天晚上我讲完了REITs我会把进阶课程介绍一下。小白营的12元已经是超值的，进阶课也不会让大家失望的。\n@所有人\n第7天】晚间提醒\n【今晚分享】升职？跳槽？创业？不懂企业怎么行？\n【明日晨读好文】《别让“等有时间再做”毁了你》\n【重要链接】补课补作业都在这里: 。。。。。。省略\n【今日早读】。。。。。。省略\n【晚安心语】工作者用企业分析技能看透工作，投资者用企业分析技能看透投资工具，创业者用企业分析技能看透经营。\n\n私发交作业后，给的总结\n\n收到作业\n《企业》重点知识\n强大企业模型，的9个关键要素。这9个关键要素是：领导者、企业文化、治理结构、商业模式、团队、沟通、现金流、系统、法规\n核心要素是什么？领导者\n强大的企业圆模型可以让我们像CEO一样去思考企业的问\n不但可以指导我们从0到1创造一家企业\n还可以指导我们从1到100做强企业，不但可以指导我们经营好自己的企业，还可以让我们看明白别人的企业，\n在跳槽的时候能选出更有发展潜力的好公司\n在做投资的时候就能选出好公司，获得年化20%甚至更高的收益率\n九、第7天\n9.1 晨读\n\n晨读文章\n\n\n别让“等有时间再做”毁了你：点击查看\n\n学习理财不是喊口号，是要付出行动的，大家一起加油\n就是因为：有了目标，你就可以区分事情的轻重缓急，才会有更好的时间规划，去做好自己时间的主人\n这就是为什么我在开营第一天就让大家写目标，甚至不厌其烦的催促那些缺课的同学补上。\n大家要明白，学习是为自己学的。学的理财技能受用一辈子，开的账户是你自己的，赚的钱也是你自己的，别人谁也拿不走！！！\n其实人最大的竞争对手就是自己心里永远长不大的那个孩子，\n你要勇敢去打败过去的自己，将来才能收获更美好的自己！\n\n人站在山脚下的时候，是无法替未来站在山腰上的自己，去思考做决策的\n下面是股神巴菲特常用的决策模型，分享给大家，希望能给大家带来更多帮助\n\n一定是主动+被动一起学习 才能不耗时耗力哈\n\n好，今早晨读到这了，大家都忙吧，记得整理笔记哦，拆群很多资料会失效\n你们只要努力也一样厉害，都是锻炼学习出来的，没有人天生什么都会\n再就是有负债的同学们，对于信用卡的使用也要理性哈，要分清好支出和坏支出，还是好好学习提高收益率把坏负债转变成好负债才是正路呢。\n\n视频分享\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n9.2 午读\n\n午读文章\n\n\n信用卡融资骗局：点击查看\n\n9.3 晚修\n警告：网上看，很多人都说微淼经常给人灌输REITs赚钱，切不可轻易相信笔记内容\n> 晚修预习\n\n小白必备的房地产投资神器：点击查看\n\n\n晚修讲解\n\n@所有人\n这篇文章分享给大家，中国经济网：\n微淼商学院荣获xxxxx\n微淼商学院荣获xxxx\n腾讯网回响中国专访xxxxx\n虽然微淼只有2岁，但有着任重道远的使命\n让我们一起努力，普及财商，造福百姓，完成伟大使命“让1亿人财商及格，让财务自由不再难”\n课前看一下，8:30 我们准时开始\n@所有人\n同学们晚上好，准备上课了哈，开始签到：投资自己是回报率最高的投资\n还有5天大家就毕业了\n有哪些事情是你想做还没来得做得呢？过去的你是否留有遗憾了\n现在已经进入3月份了，今年已经快过去两个月了\n如果有遗憾，就像咱们的早课一样，请不要在等有时间在做了\n今年开始请不要在有遗憾了；\n记得对你相爱的人说喜欢；\n对你想感谢的人说一声迟来的谢谢；\n对你想做的事是还没有做得，抓紧时间制定个可行的计划；\n不要等到今年年底时候又在后悔又在感叹；\n希望今年你能收获更好的自己，大家共勉；\n凡是过往皆是序章，愿2020年所有的美好如期而至\n愿去年所有的遗憾都是今年惊喜的铺垫\n不止一个人对微淼说：2019年遇到微淼很幸运！\n老师课前先带大家做个简要回顾！\n还有几天大家就毕业了，我们来简单回顾一下大家是如何一步步走到现在的\n第一天的晚课，我们知道\n人的穷富，其实首先取决于你的思维，思维决定行为，行为决定命运。\n怎么初步形成富人思维呢？\n1、量化思维，2、分清生钱资产\n当你拥有的生钱资产，产生的钱大于日常生活开支时，你就【财务自由】了\n第二天晚课，我们见识到复利的魔力\n复利的公式是 最终收益=本金*（1+收益率）^时间\n在这3个要素中，【本金】短时间难以改变，【时间】无法改变，能做的是尽早开始，【收益率】是每个人通过学习就可以提高的。\n在本金不多的情况下，我们应该【尽早学习】，提高自己的理财能力，提高【收益率】！\n记住：【复利法则】在漫长的时间中发挥了魔力，如果你行动时间晚了一点，那么你的投资回报就会少得多！你推迟投资的每一天，通货膨胀都会发挥复利的反向作用，你与别人的差距也会越来越大！\n第三天晚课，我们学了21个最常见的理财工具\n\n低风险≠低收益，高风险≠高收益\n风险和收益的大小主要不是由理财工具本身决定的，而是由我们的理财知识决定的！\n在实现财务自由的过程中，大家主要用好【低风险】和【无风险】的理财工具就好了\n在这两种类型的理财工具中，有两个理财工具最重要??\n生钱资产类型的股票、生钱资产类型的REITs。\n这几天我们主要讲了投资【生钱资产类型股票】【企业】的相关知识。\n选出好公司，计算出好价格，等待好价格出现买入股票，就相当于在打折季用便宜的价格买到了一件品质上乘的奢侈品\n长期来看是稳赚不赔的\n今天我们就来学习财务自由三大核心工具中的最后一个——【REITs】\n我想大家都想成为包租婆包租公，每天收收房租\n想必这就是很多同学热衷于买房子投资原因之一\n觉得买房子可以赚租金，运气好还能赚房价上涨的钱\n如果以前，大家提到包租婆，一定觉得这人生在了好地方，有好几栋房子才可以做到，离我们普通人很远\n但我们都是普通人，没有那么好的出生地，但也有一颗想要当包租婆包租公的心\n今天，老师带大家认识一个工具，普通人【几百块钱】就可以成为包租婆包租公，全球收房租了\n几百块就可以投的房地产神器哦\n今天的内容主要是三个重点，两个关键富人思维\n第一个重点：到底什么是REITs\n它和房地产又有什么区别呢？\n我们知道房地产作为投资工具的优点和缺点都很明显\n房地产的优点：能带来稳定的现金流，保值增值能力较强\n它的缺点也非常明显：投资金额大，交易税费高，变现难。\n由于房地产缺点的存在，大部分投资者被房地产拒之门外，投资房地产的人大部分都是有钱人\n但是\n“REITs”的出现消除了房地产作为投资工具的缺点，保留了其优点\nREITs的使命就是要让草根也能投资房地产，分享房价上涨的收益\n虽然“REITs”是为普通投资者设计的投资工具，\n但是目前中国内地的投资者基本还不了解“REITs”是什么\n大部分房地产投资者都还处于“炒房”的初级阶段\n所以Reits可是一片不为人知的肥肉啊\n大家单单知道reits这个投资工具，已经比国内80%的投资者强了\n大家还ok吗？\n好，我们再来看一看REITs的全面定义\nREITs是一种依照法律程序成立的，以发行股票或基金单位的方式汇集投资者的资金，由专业机构进行房地产的经营管理，并将90%以上的税后收入净额分配给投资者的一种信托组织\n划重点\n依照法律，专业机构，90%以上\n我们一起来看一下\nreits一共有六大优点\n1、定期强制高分红。\n各国都要求REITs每年至少要把净收入的90%分配给投资者。这样REITs每年都能给投资者带来持续的现金流。\n美国reits一般每季度分红一次，香港一般每半年分红一次。\n这就像收房租一样，美国是季付，香港是半年付\n\n看到了吗，一年分红4次，单位是美元\n我们可以投资港股和美股的reits\nREITs第二个特点\n2、投资门槛低。一般几千元就可以投\n香港REITs 1手为1000股，1手起买；美国REITs 1股起买。\n几千块就可以投资了\n积少成多\n如果直接投资房地产，至少也要几十万才能起步\n这就是REITs独有的优势\n3、交易成本低。\n一般REITs会免企业所得税。投资者买卖REITs只需要支付交易佣金，和买卖股票一样，不用支付其他高额税费。\n如果是直接投资房地产，光买卖的税费也要在房价的10%-30%\n在税收这方面，REITs的优势可以说是异常的明显\n4、流动性强。\n买卖REITs像买卖股票、基金一样方便。在证券交易时间内随时可以买卖\n房地产的流动性差可以说是一个最致命的弱点\n炒房者一旦遇到房价低估的时候，房子锁死了很大一部分钱，让人干着急，要是有急事要用钱，房子短时间卖不出去，能把人急的要命\n但reits很好的解决了这一问题\n5、专业化管理。\nREITs的管理团队都是房地产领域的专业人士。他们管理物业的能力一般会比个人强很多\n所以说REITs更加稳健，也更加靠谱\n最后一个有点\n预习过的同学，知道是什么吗？ \n是收益率高\nREITS是比股票收益率还要高\n优质的生钱资产类型的REITS 收益率可达15%到20%\n预习链接中计算的汇贤产业信托每年9%的现金分红已经挺高了\n但是在REITs中还只是中等的回报率\n高的可以达到20%左右\n\n比如这是一只美国REITs，每年的现金分红收益率高达18.1%。\n每个季度分红一次，这可是实实在在能拿到手的钱。\n这就是生钱资产\n它本身给你带来持续的正向现金流\n前面介绍股票时说过，长期来看与黄金、银行存款、债券、房地产等主要投资工具相比，股票的投资回报率是最高的。\n股票与REITs的回报率相比，股票也是甘拜下风了。\n大家看一下，下面这张图\n\n看画红线的地方\ns&amp;p500是标普五百指数，标准普尔公司出的一个指数，代表股市大盘指数\n下边的红线代表所有reits的平均收益率\n意思是说，在过去20年中，美国所有REITs的平均年收益率为11.19%\n而标普500股市大盘指数的年平均收益率只有7.81%\nreits的收益跑赢了同期股市大盘指数\nreits的收益率是炒超过股票的\n有同学肯定会问，reits这么好，中国没有REITs，那我们怎么投资呢？\n方法也很简单，在港股、美股证券开通账户就能购买。\n这个也完全不用担心\n微淼进阶课实践班会有零门槛开户福利\n\n先灌输REITs很好，推广进阶班？？？我也不知道\n\n所以大家放心学就好了\n微淼在理财类商学院是全国唯一教REITs的 \n通过“REITs”我们可以很容易就实现了【全球化投资】\n世界主要比较厉害的reits是美国和香港\n只要把香港和美国的REITs弄明白了，对于实现财务自由来说就完全够用了\n因为通过香港和美国REITs我们可以间接投资中国内地、中国香港和美国的房地产\n这三个地区的房地产运行周期是不一样的，完全够我们轮着买\n好了，说了这么多的优点，也要说说风险\n没有风险？当然不是，\nREITs的本质就是房地产\n房地产有的风险REITs基本都有。\n但  大家还记得吗\n风险的大小主要还是和我们的理财技能有关\n风险的大小主要和我们的理财技能有关\n学会了理财技能，把reits弄明白了，REITs对于你几乎没有风险\n学懂了再投就是你收房租的工具\n不懂乱投资呢，就风险很大。\n不懂不要投，懂了放心投\n这就是赚自己看得懂的钱\n有些人一辈子可能都不知道reits\n人永远赚不到自己认知以外的钱\n人与人最遥远的距离就是认知上的距离；\n人与钱之间最遥远的距离也是认知上的距离。\n赚钱机会对于懂的人近在眼前，对于不懂的人却远在天涯\n财富增加也是执行正确方法论的必然结果，\n目前reits国内普通老百姓知道的很少，所以这个也是一个大商机。\n国内人口基数这么大，都普及了的话，那得到什么时候？\n那个时候投资这个可能普通老百姓又玩不起了\n所以大家早一步学好，就能提前分一杯羹\n这就是机会\n机会永远只留给准备好的人\n好了，又到了我们的关键富人思维了。\n【提问】：为什么要自己掌握理财技能才是最可靠的？\n因为只有自己掌握了理财技能，才能对自己的钱负责\n之前很多学员都表示跟着自己的家人、朋友投资，当赚了的时候会特别感激对方，但是亏的了时候又怨恨对方不靠谱。\n其实他们的家人、朋友很多也许是好心，但是他们没有掌握投资技能，靠着小道消息，本质是投机，赚了是运气好，长期亏损是必然\n理财投资这么重要的事情，如果交给别人，就像把自己的“财富之命”交给了别人，\n如果遇上的是一个没有扎实理财技能的人，那就对自己的“财富之命”太不负责\n【最可靠的】还是自己通过学习成为家庭资产理财师，制定出专属于自己家的理财规划书，为自己的家人打理财产，创造更多非工资收入，这才是最安全可靠的方法\n【一句话总结】：理财——事关自己和家庭的财富之命，只有自己掌握了，才是对家庭、对自己负责。\n这也是我从不推荐任何理财产品，只教理财方法的原因\n已经12条了。 还剩最后两条， 明天教你们懒人躺赚神器，指数基金，跟着大盘跑的基金，跑赢通货膨胀的必备神器\n先保存，好了后. 接下来要说进阶实践班的安排了。\n…\n… 半节课多的介绍进阶课，优惠介绍\n\n\n\n…\n今天的课程是唯一一次超时的，20:30到21:30，超时到23点\n\n私发交作业后，给的总结\n\n作业已收到！我总结一下REITs这节课的课程内容\n买优质的生钱资产型REITs，掌握好REITs投资技能就可以很好的增加非工资收入的，好的reits下跌比银行赚的利息高（分红率高），上涨也能赚钱（赚的是价格增值收益）。认真看一下进阶课介绍，小白营是梳理具体框架，进阶课是具体实操，小白营是思想，进阶课是落地行动。今天我们讲定投指数基金，这是巴菲特公开推荐的理财工具。一定来哈\n\n然后给了一个电子书链接，之前我就已经通过ctrl+u全部拿到了，见本文底部，点击下载\n\nhttp://xiaobai.yaocaiwuziyou.com/Site/page2.html\n( 富爸爸穷爸爸  4316 ）\n十、第8天\n10.1 晨读\n\n晨读文章\n\n\n免费到底是便宜还是贵？：点击查看\n\n\n视频分享\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n10.2 午读\n\n午读文章\n\n\n互联网金融传销骗局：点击查看\n\n提示一下，像这种保证月收益30%的投资平台，无论叫什么？无论具体表现形式是什么样子的？全都是骗子，没有一个例外。别说保证月收益30%，即使是保证年收益30%的也是骗子，无一例外。\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n10.3 晚修\n\n晚修预习\n\n\n懒人躺赚的理财方式：点击查看\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n给大家加餐个小视频，穷爸爸富爸爸作者罗伯特清崎，财务自由思想在90年代掀起了浪潮，真的是说出了穷富的秘密，务必看很重要，颠覆你的认知。\n从我们接受的教育来看，我们教育体制内就缺乏理财知识的教育，所以不少学员都说自己以前吃过大亏。\n那老师也想说，人的一生能处理好感情和金钱，那么90%的烦恼就会烟消云散，所以对于理财这样的人生必修课，一定要主动去学习。\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n晚修讲解\n\n@所有人\n同学们晚上好，开始晚课签到：我们走错的路，就不要让孩子再走一遍了\n…这里省略一段内容，全是回顾reits的，是小白理财神器什么的，收益率20%…\n今晚讲指数基金定投，用好了指数基金，有孩子的每年给孩子定投，等孩子长大，就是个小富翁了\n开始今天的课程\n今天我们主要讲的是【定投】 \n定投指的是【定期变额定投】\n【定期】可以是每月、每季度、每年\n 建议每月定投。每月定投日可以设定为发薪日。这样发了工资直接拿出一部分（比如10%-20%）定投，这有点强制储蓄的味道，这样做的好处是可以直接解决掉很多人的月光问题\n 还记得第一天早读，我说的先储蓄，再消费吧。就这个意思\n 【变额】指投资额度会变化\n 这个变化不是随意变的，而是跟随投资工具的市盈率而变\n 比如：市盈率小于15时，每个月定投金额为1000元\n 市盈率小于12时，每个月定投金额为2000元\n 市盈率小于10时，每个月定投金额为4000元\n 根据市盈率大小来改变投资策略\n 这样做的好处是标的在价格便宜的时候会买的更多，价格贵的时候不买。\n 这样就能很好的起到降低总成本，提高收益率的效果\n那什么是【市盈率】呢？\n 简单来说就是市场投资者为了获得1元的盈利，愿意付出的价格。\n 一般来说，用15元的价格获得1元的盈利是相对合理的。这样15年就可以回本，年化收益率6.7%左右\n 不用深究市盈率是啥，它就是一个投资回报指标\n 市盈率是不断变化的\n 市场狂热的时候，市盈率会高达30以上，也就是说市场投资者为了获得1元的盈利愿意花30元\n 这个时候的年化收益率\n 1÷30100%，年化收益率只有3%左右\n 收益率很低\n这时候我们就减少定投金额\n 市场悲观的时候，市盈率会低到10以下，也就是说市场投资者为了获得1元的盈利只愿意花不到10元的价格。\n 这个时候的年化收益率\n 1÷10100%=10%，年化收益率就10%。\n 这个时候买入的话，收益率就超过10%了\n 我们要做的就是在市场悲观的时候大量买入。\n 比如，市盈率小于10的时候，买入4000块\n 市盈率大于15的时候，只买入1000的块\n 这就叫变额定投\n 大家跟上了吗？\n那我们定投什么比较好呢？\n 这就是我们下一个重点\n 【基金】可以理解为一个特殊的篮子，里面可以装股票、债券等理财工具\n 主要装的是股票，就是【股票基金】\n 主要装的是债券就是【债券基金】\n 主要装的是1年期以内的短期债券就是【货币基金】\n我们定投，主要选择股票基金\n 股票基金就是里边装了很多不同的股票组成的基金\n 股票基金可以分成【主动型基金】和【被动型基金】\n 主动型基金，由【基金经理】决定买哪些股票。\n 我们不要选择\n 被动型基金就是指数基金，只根据指数配置股票，不人为选择股票。\n 一只指数基金里面包含了50-100只股票不等，可以简单理解为买了一只指数基金，就等于买了50家公司的股票，这支指数基金的波动就是这50家公司的整体波动\n 我们的收益就是这50家公司股票增长的价差\n 所以我们投资主要选择被动型指数基金\n 可以理解为是国家选的，符合国家标准就纳入，不符合就淘汰。\n我们定投只考虑【被动指数基金】就行了，因为至少80%的主动型基金是跑不赢指数基金的。\n 因为被动指数基金有一个特别厉害的特点\n 长生不老\n 指数基金这个篮子是会新陈代谢的，会自动淘汰那些不好的股票，加入满足条件的股票\n 就像富豪排行榜，有能力的就上，没能力的就淘汰\n 所以，大多数的主动基金无法跑赢指数基金\n 只要相信国家经济能继续发展，指数基金就能长期上涨，我们就能分享国家经济增长带来的收益了。\n 指数基金最主要的特点有：\n 1、完全复制指数。完全复制指数意味着不用费任何 力气就可以胜过 70%的投资者。\n 2、长生不老。公司会消失，但是指数不会，它通过定期调整成分股， 通过引入新公司，剔除老公司的方式实现了真正意义上的长生不老。 \n 因为指数的背后是上市公司，指数会定期调仓，把赚钱能力强的 公司选入指数，淘汰赚钱能力弱的公司。\n 所以随着国家经济发展，指数必然是长期上涨的。\n 比如我们看恒生指数\n \n 恒生指数始于1964 年，最初指数 为100，我们看到恒生指数整体上一直上涨的，最高 3 万多点\n 如果你在1964年买入1000块的恒生指数，现在有多少钱呢\n 300多万\n 再看标普指数\n \n 标普指数 1957 年开始编制，基期指数为 10，现在标普 500 指数 3000 点。\n 如果在 1957 年买入 1 万元的标普 500 指数基金傻持到今天的话，\n 到现在能有多少钱呢\n 10000X300= 3000000\n 也会有300多万\n 只要相信这个国家经济能继续发展，指数基金就能长期上涨，我们就能分享国家经济增长带来的收益了。\n 想象一下你从现在买入一支指数基金\n 未来能不变富吗？\n 以上还ok吗？\n 好，继续\n 【无脑定投指数基金】就是懒人躺赚的最佳理财方式，这种方法非常简单，适合所有人。\n 几百元就可以投资\n 有孩子的父母，我建议可以给孩子准备个指数基金账户\n 已经开通涨了财付通的就可以买\n 把孩子的零用钱和压岁钱之类的，定投指数基金\n 这样等孩子长大成年，他就能有一笔不菲的收入，很可能是个小富翁或者小富婆了\n 赢在起跑线\n 定投指数基金可以获得年化10%以上的收益率\n 以上明白的同学回复1\n 已经开户的同学，可以在涨乐财富通app操作下，感受一下\n讲到这里，你们还愿意用支付宝 微信里的基金理财吗？\n 同学们，有了财商就不要用支付宝和微信里的基金理财了\n为什么呢？\n 基金根据交易平台不同分为【场内】和【场外】\n 场，就是【证券交易市场】，也是我们平时所说的股票交易市场。\n 我们买基金一共有4种渠道\n1、证券公司，场内渠道\n2、银行\n3、基金公司\n4、第三方代销平台。（微信、支付宝等）\n只有1是场内渠道，2~4是场外渠道。\n场内和场外的区别：\n场内的优势：交易方便，方便，方便。佣金手续费低，便宜，便宜，便宜。\n场外：不用开股票账户，可以设定日期自动投。但是无法设置【定期变额】定投。所以，这个算不上优势。\n 但是\n 这种场外基金有超高的手续费\n 很多时候一卖一买扣除手续费，自己却没赚什么钱。\n 所以，大家只需要关注场内基金就够了\n好，下面是今天第三个重点\n 大家想一想指数基金，是最好的投资工具吗？\n 其实，还有比指数基金更好的工具\n 比如生钱资产型的【股票】、【REITs】\n 【股票】、【REITs】同样适合定投\n 定投【股票】、【REITs】，获得年化收益率在15%以上\n 通过定投好股票、好REITs可以获得比指数基金高5%左右的年化收益率\n 每年看似5%的差异不大，但是30年后就是巨大的差别⭐\n 来量化一下\n 做个小练习，本金10000元，投资年限30年，大家分别计算一下收益率12%和20%的最终收益\n 微淼商学院理财计算器：www.yaocaiwuziyou.com/calculator.html\n 我们算一下\n 29万/273万\n 看到了吧\n 这就是收益率的差距\n 有人说这么高的收益率不好找\n 人只能赚到自己认知范围以内的钱\n \n 带百分比的就是收益率\n 理财技能将直接决定你的收益率\n 学会了理财技能，有的是方法挣钱。\n 这就是赚自己看得懂的钱\n 财富间的巨大鸿沟仅仅源于理财技能水平的不同。\n 大家觉得你该怎么提高你的理财技能呢？\n 有人会说，6998这么贵老师！！！我没法学。太贵了\n 但等你有了理财技能，你还会在乎那点学费吗？\n 生活的真相是：只有行动才促成了机会本身的产生，“要想改变，从行动开始”！\n 下面又到了关键的富人思维环节\n 大家觉得，我们最应该为孩子留下什么财富？\n 是几百万的钱还是几套房子？\n 以前总想为孩子留下一笔钱、一套房等，这并没有错，但我们给孩子留下的最重要财富却不是金钱。\n 因为如果给孩子留下了金钱，但孩子无法对抗通货膨胀的贬值、缺少科学的理财知识，金山也会吃空，最终落得个流离失所的下场，正如我们前面讲到的富豪之子一样。\n 【聪明的父母】会选择在孩子很小的时候就开始正确的财商教育，让孩子从小就养成正确的金钱观，从很小的时候就享受理财技能带来的复利\n 而【这都取决于父母的理财能力】，\n 我们走错的路，吃过的苦，就不要让孩子再走一遍了。\n 我们走错的路，吃过的苦，就不要让孩子再走一遍了。\n 我们走错的路，吃过的苦，就不要让孩子再走一遍了。\n 我们最应该留给孩子的财富是可贵的品格和可靠的理财能力，身教重于言教，用我们的理财能力让孩子的财商有一个好基础。\n @所有人\n下边讲点进阶课才会讲的\n 想听的，发朵小红花\n 选择指数基金的时候，我们要怎么定投，什么时候买进，什么时候卖出？进阶课都是手把手的教\n 刚才说了，要看市盈率来定投指数基金\n 那我们要看哪个交易所的市盈率呢？\n 都知道我们国家有上证和深证，一个是上海证券交易所。一个是深圳证券交易所。\n 我们要看深证的市盈率\n 上证的不要看\n 因为，上证的公司，大部分是超级大的公司，\n 像中国石油，中石化这样的大公司，国企居多\n 国企发展速度慢，而且发展空间小，上市的时候，就被高估了，然后发行股票后，就会呈现一路走低的态势\n而深证的公司，大部分是中小企业，我说的都是上市企业，大部分是民营，\n民营企业的活力是远超国企的\n中小型企业的市盈率更能真实的体现出市场行情，小企业和大企业市盈率肯定是不一样的\n进阶课第一周就会讲如何选择指数基金，具体投资哪个。这里我不能推荐，但我还能给你们讲一下市盈率的看法\n深证的市盈率\nhttps://www.legulegu.com/stockdata/shenzhenPE\n打开网站就能看到\nhttp://value500.com/PE.asp\n\n现在的市盈率是在26\n深证平均市盈率主要在 20 到 60 之间波动\n2007、2008 年的大牛市，2015 年的大牛市，深证市盈率超过 60 倍\n最低是在 20 倍附近，40 是中位值\n所以我们投资指数基金， \n最好的进场机会就是深证市盈率在 20 倍左右的时候\n到 40 倍左右的时候不建议买进\n而 到 60 倍左右，这个时候就要卖出了。\n目前深证市盈率在 26倍左右，高于 20 倍市盈率，这个时候还能投资吗？\n其实整体市盈率 还是低估的，虽然不是最好的机会，但是我们依然可以用定投的方法投资指数基金。 \n这就像价值 10 元的东西，你 5 元买入，可以赚 5 块钱。\n现在又跌到 3 元，可以赚 7 块钱， 赚的更多了。 \n这个策略的本质是越跌越买\n很多同学管不住自己花钱的手，有很多不必要的消费，比如多买件穿不了几次的衣服，花几百块钱吃顿没必要的饭菜等等，\n其实这些钱如果省下来，放到指数基金里，过几年的收益很 可能会超过你的想象。\n很多同学可能也会买一些返还型保险之类的，十几二十年之后开始返钱。其实估计连通货膨 胀都跑不过，根本比不了指数基金。\n我讲完了\n大家想一下，你每年买保险花的冤枉钱\n是不是够买好几个全套课程的了\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n@所有人\n【第9天】晚间提醒\n【今晚分享】懒人躺赚的理财方式\n🔆【明日晨读好文】《如果你爱TA，一定让TA学会理财》\n️【重要链接】学习资源大汇总xxxxxx\n😎【作业八】xxxxxxx\n温馨提示：优惠名额还剩【23】个啦，有需要的抓紧时间私聊我哈，名额有限，先到先得！\n️【晚间心语】认真学习就是最大的聪明，投资自己就是最大的智慧~\n\n\n交完作业的总结\n\n进阶课会教你全球化配置资产，学会A股，港股，美股，REITs，可转债，打新股，分级基金a，家庭保障性保险，年化收益率可达到15%~20%左右，还有退费保障，包教会。还有十几个名额了，考虑下？\nX1、第9天\n11.1 晨读\n\n晨读文章\n\n\n如果你爱TA，一定让TA学会理财：点击查看\n\n人们潜意识里，坚信自己是对的，自己看到的才是事实\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n但成功的人都是先相信后看到，而大部分人都是先看见才相信，这句话大家可以好好体会一下\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n半分钟看一下这个视频\n体会一下你到底差在哪里了\n客观的说，理财的确不是唯一的致富途径，也不是非要【理财】才能赚到钱\n层次再低一点，像中国上市公司的那些【创始人和原始股东】，也成为了富豪\n如果你能创立伟大的事业，那么理财那点“小钱”确实无足挂齿！\n在中国内地、香港和美国上市的大陆公司一共约【4000家】\n这帮“天子骄子”的数量级大约是【4万人】\n占人口比例0.0029%\n这其中包含反对你学习的人吗？\n如果不包含，敢问，他们是以“贫穷”的经验在反对你进步吗？\n我们要与巨人同行，你才能成为巨人\n反过来呢？你要和贫穷的思想的人同行吗？\n相信大家不会的，学习就是为了跳出现有的圈子，解决财务问题，经济危机创业困难，实现最终的财务自由\n物以类聚人以群分，如果你在哪现有的圈子或者比你层次低的圈子寻求答案吗？\n那你永远不会成功\n都说股市【七亏二平一赚】\n还有说：我二叔的大舅的三表哥炒股亏了几百万那些人\n他们说的也许是真的是他二叔和大舅。\n但是相信经过我们小白营学习的人，已经知道他们为什么亏，是什么原因导致的了\n很多新手，不经过学习就冲进资本市场大有人在。\n对于这些做【决策不过大脑】、想把【股市当提款机】的人\n给你们一个深情的拥抱，\n他们太敢做了！！！\n人们学习游泳，有教练，怕有生命危险\n开车上路，有驾校\n职场技能，有蓝翔技校\n学习烘培，也要先找个专业的师傅吧\n为什么到了股票上，到了投资这种事关大量钱财、身家性命的问题上，却如此轻率呢？\n不学习就乱投资是普通投资者亏损的主要原因\n包括你们现在的投资正在票面挣钱，要是不通过学习，也许一变现就亏了\n中国人口14亿，中国的股民已达到1.2亿\n即便是七亏二平一赚，也代表有【1200万人】是在股票里赚了钱的。数量比葡萄牙、希腊整个国家的人口还多。\n你要思考的应该是：如何成为这1200万中的一员\n正是因为大部分人不理财，参与理财的人才能获得丰厚的回报！\n理财永远是一件小众的事情。\n就像我们群一样，最后坚持到最后的可能就是20%的人\n有的同学天天写作业，不懂得就问老师，有的同学必须的崔才能完成作业，有的同学根本老师就没见过踪影\n估计就是在小白营毕业的时候，领个毕业证找老师，晒个朋友圈，说自己是学理财了，你这是骗了自己啊\n生活最怕的就是自欺欺人的人\n也正是因为如此，，理财永远是一件小众的事情。精通理财，参与理财的人才必然能获得丰厚的回报！！\n牢记二八定律\n20%的人赚80%的钱\n所以咱们的优惠名额也设置43人\n根据二八定律得来的\n那些面对直接否定一切的人，请你用量化思维思考一下：\n其实！\n账户是你的！\n学习的知识是你的\n赚了钱也是你的\n记住：无论什么时候，劝你学习的人，都是真正想让你变好的人。\n\n好了老师的分享到这里啦，你会劝谁去理财呢？为什么你会选择TA？\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n人们只相信自己看到的\n等你赚到钱，他们就相信你了\n就会求着你告诉他怎么理财\n\n疫情之下的历史性行情机会.docx：点击下载\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n11.2 午读\n\n午读文章\n\n\n房地产投资骗局：点击查看\n\n中午介绍了他们公司招聘\n11.3 晚修\n\n晚修预习\n\n\n理财不被割韭菜：点击查看\n\n\n晚修讲解\n\n@所有人\n同学们，晚上好，开始晚课签到：在通货膨胀面前，理财是人生的必修课！\n每天都能坚持下来的同学们，你们都很棒\n时间会帮你么干掉一部分人，那些人就是不愿意学习的人。\n大家已经站在财务自由的大门口了\n掌握了科学的方法，财务自由只是时间问题\n牢记二八定律，20%的人掌握了80%的财富\n小白营结课后群会解散，汇总链接将失效，大家尽快补课，有不懂的及时问\n昨晚讲的是指数基金，指数基金非常适合给小孩子定投\n有孩子的父母可以利用好指数基金这个工具，管理孩子的压岁钱\n老师先带着同学们复习一下昨天的内容哈\n昨天的基金定投，对于大家来说还是很实用的\n⭐1、什么是基金？\n基金就是一个特殊的篮子，里面主要装的是股票，就是股票基金；主要装的是债券就是债券基金；主要装的是1年期以内的短期债券就是货币基金。\n⭐2、基金有哪两类，应该选哪一类？\n主动型基金，被动型基金；我们应该选择定投被动型基金\n⭐3、指数基金属于哪一类基金？\n被动型基金\n⭐4、定投有哪两种方法，我们应该选择哪一种定投？\n定期变额定投，定期定额定投，选前者\n⭐5、为什么定投指数基金可以持续保持较高的收益率？\n昨天有一些同学问老师，基金经理很厉害，为什么主动基金跑不赢被动基金呢？\n（1）最主要的原因是主动型基金都有短期业绩考核，基金经理为了完成短期目标经常进行短期交易。经常进行短期交易的人基本都会被割韭菜，基金也不例外，所以至少80%的主动型基金是跑不赢指数基金的，。\n（2）指数基金永生不死，长期上涨，会新陈代谢，能自动淘汰那些不好的股票，加入满足条件的股票。\n⭐6、如果想获得比指数基金高的收益，如何定投？\n选出好股票、好REITs进行定投\n好了，上一节课是和我们以后的投资有关系，是一个很重要的基础，所以大家要把握好哈\n实践班第一节课，老师就会带大家操作指数基金了\n我们开始今天的课程\n这一两年“割韭菜”这个词突然火起来了，主要是因为很多人被割了韭菜。\n比如P2P爆雷，很多P民被割了韭菜；虚拟货币滥发，很多炒币的人被割了韭菜；楼市限购，很多炒房的人被割了韭菜\n今天有同学和我说，投资太难了，我弄不了，理财投资不适合我\n对此，我想说很多事情是逃不掉的\n理财可能会被割韭菜，如果不理财是不是就不会被割韭菜了呢？\n答案是否定的，如果不理财，只会亏的更加悲惨\n因为通货膨胀是世界上最强大的韭菜联合收割机，它收割所有持有现金的人。\n\n这位阿姨的故事想必大家在链接中都看过了\n44年前（1973年），她存入银行1200元，\n历经44年，得到1484.04元利息，如今取出2684.04元。\n当时的1200元可以建2幢别墅，到了今天就只能买一张床了。\n那么她到底亏了多少钱呢？\n我们计算一下\n如果她选对了一个年化收益率20%左右的好的理财工具，这1200元经过44年的复利可以带来多少收益呢？\n理财计算器：www.yaocaiwuziyou.com/calculator.html\n大家用计算器算一下\n365万\n没错，是365万\n356万，是她存银行收益的一千三百多倍，\n现实就是这么残酷\n当时茅台还没上市\n如果在茅台上市的时候买，现在早就是千万富翁了\n现实就是这么残酷\n亏的这么惨，连个找说法的地方都没有\n如果你把钱存银行，你就跑不赢通胀，\n当你发现自己被通胀割韭菜的时候，你连个说理的地方都没有。\n因为你被不明的力量合法收割\n那通货膨胀到底是怎么一回事呢？\n今天老师就带大家把通货膨胀了解透彻。\n通货就是通用货币，就是钱，我们国家就是人民币。\n【通货膨胀】=通货+膨胀\n意思就是钱多了\n钱多了，当然就不值钱了\n正常的市场经济下，钱的流通数是有标准的\n但是为了某些原因，增发货币\n钱越来越多，肯定就不值钱了\n我们来看一下著名的费雪方程式\nMV=PT\nM 一一货币的数量 ;\nV 一一货币流通速度 ;\nP 一一物价水平 ;\nT 一一各类商品的交易总量。\n在社会中V和T一般是比较稳定的，所以货币量M决定物价P。\n货币越来越多，物价就会持续上涨。\n比如你有1万元现金，随着物价的上涨，你能买的东西越来越少，这样钱就越来越不值钱了\n这就是通货膨胀~\n大家日常生活能感受到通货膨胀带来的物价上涨吗？\n越来越累，工资却涨不过物价。猪肉都上天了\n病也生不起\n现在100块和10年前的100块的购买力根本不是一个等级了\n最现实的，现在一碗面要12块左右，小时候只需要三四块\n这就是货币贬值了\n钱贬值太厉害了\n那我们手中的钱每年实际贬值到底是多少呢？\n有些数字我们看到的是不准确的，所以对于真实的通货膨胀要用到下面这个公式\n⭐实际CPI=M2增长率-GDP增长率\nM2增长率反映了一个国家每年钱的增长速度\nGDP增长率反映了一个国家每年创造的商品和服务的增长速度。\n将M2增长率减去GDP增长率，就是，钱增长比商品增长多出来的部分。\n这就是实际的CPI，也叫实际通货膨胀率\n它能比较准确反映出你手中的钱每年实际的贬值情况\n\n计算一下实际通胀率\n20年M2增长率=（1826744.22-104498.5）÷104498.5×100%=【1648.11%】\n20年GDP增长率计算方法相同，结果为【970.08%】\n【实际年化CPI】=M2增长率-GDP增长率=1648.11%-970.08%=【678.03%】\n为了方便计算，我按最初100，最末678.03，时间为20年，用理财计算器就可以算出来\n\n可以计算出中国过去20年的实际年化通胀率为10.04%。\n这也就是说过去20年通货膨胀让每个持有现金的人实际年化亏损10%\n想想这么多年，你们辛辛苦苦挣的钱，每年10%的速度贬值。\n发了1万块工资，当年就被合法收割1000块。购买力只剩9000.你还一点脾气没有，\n因为是合法的\n所以，不理财就没事了吗？\n不理财亏的更惨\n不理财亏的更惨\n不理财亏的更惨\n只要你的理财收益率低于10%，你就是在亏钱\n你的钱就在贬值\n如果你比其他人聪明一点，买了余额宝之类的理财产品。\n那么你的实际每年亏损大概是7%左右。\n假如你现在有10万元，按照年化实际亏损7%计算，20年后会贬值多少呢？\n理财计算器：www.yaocaiwuziyou.com/calculator.html\n收益率是 -7%\n大家计算一下\n2.3万\n是的，假如你现在有10万元存银行或买余额宝，从购买力的角度来看，20年后实际亏损7.7万，还剩2.3万。\n如果你现在有10万元，退休时（按35年计算）会贬值多少呢？\n35年后 10万块钱，只剩7千块了。\n恐怖吧\n实际亏损比例高达92.1%\n现在回头想想报纸里的那位女士，可以确定这些计算并不是假设，而是现实。\n由于通货膨胀的存在，不理财注定是逃脱不了被通货膨胀割韭菜的命运的。\n如果一个人理财年化收益率低于10%，他肯定是亏钱的\n在中国，如果你的年化收益率低于10%，你对的起辛苦赚钱的自己和家人吗？\n通俗的讲，你的赚钱的速度低于钱贬值的速度，跑不赢它，本质就是在亏钱\n我们理财两个目的，首先就是跑赢通胀，其次是再挣点钱。挣得越多越好\n那我们如何不被通货膨胀割韭菜呢？\n不想做韭菜，那么看看韭菜都做错了什么事，我们不做就是了\n⭐韭菜的第一大特点：韭菜是投机者而不是投资者\n【投资】以赚现金流为主，赚差价为辅；【投机】以赚差价为主\n【投资】是赚确定性很高的现金流，在现金收益率高的时候买入，\n比如投资者会买进高股息率的好股票、高现金分红率的REITs。\n即使价格不涨甚至下跌，每年也有7%—15%的现金分红收益。\n【投机】是通过预测价格变动来赚价差。这有很大的不确定性。\n因为价格的涨跌是无法预测的，投机其实就是赌博\n⭐韭菜的第二大特点：追求短期收益，高频交易，而不是长期投资\n频繁的交易，基本上判了你被割韭菜的命运\n历史上没有一位投资大师是靠预测价格涨跌变富有的。\n\n全世界有记录做投资赚钱最多的都是做价值投资的，都是用同学们所学习的方法赚钱的，\n无论是巴菲特，格雷厄姆，查理芒格，戴维斯，彼得林奇，这些最成功的投资者，他们都是做价值投资的\n频繁的看k线预测涨跌\n这和赌博有什么区别？\n⭐韭菜的第三大特点：不愿学习或不深入学习，盲目乱投资\n这个就不言自明，不用多说了,不学习就入市，就是在给别人送钱\n富人都有坚持学习的习惯\n不论是马云还是俞敏洪\n不学习乱投资，肯定会亏的惨不忍睹\n大家赚钱都不容易，希望都能认真对待自己赚的每一分钱\n你不会理财，你就只能被通货膨胀把你稀释的越来越穷，越来越买不起东西。\n有理财技能的同学则可以通过生钱资产，通过复利的力量，加上时间的魔力，跑赢通货膨胀，使自己辛苦积累的财富指数级增长。\n下面，又到了今天关键富人思维环节了\n如何才能掌握收益率高的理财工具？\n【方法一】：很多人刚刚知道有一个高收益的工具，恨不得马上就买一个，然后就自我憧憬能赚多少。\n我称之为焦虑的“【烧钱尝试法】”。\n简称，有钱烧的\n【方法二】：是看书吗？\n如果看书能够实现财务自由，那么很多人早就财务自由了，\n因为看书最大的弊端就是没有反馈，没有人告诉你学的对还是学的错。\n尽信书则不如无书\n【方法三】：最快的学习方法是【巨人同行法】，跟着已经长期成功的投资者学习，\n巴菲特的老师是投资之神格雷厄姆，\n我们前天早读课中8岁的投资神童，他的父亲是成功投资家。\n我们现在学习的是封老师财务自由的经验\n一边勤奋学习理论，一边在老师的指导下纠正错误，一直走在一条正确的努力之路上\n这就是看似缓慢，但实际最快的投资之路。\n这是一条少有人懂得的路，也是一条少有人走的路，\n所以真正赚钱的人才不多。\n总结一句话：站在巨人的肩膀上，在少有人走的投资学习之路上最快成长。\n大家准备要走哪条路呢？\n富人思维下一条\n有的投机者说自己也赚钱了，那么选择做投资者到底好在哪？\n我们投资理财到底是为了什么呢？赚钱！但进一步想，赚钱的同时不被钱绑架才行，能有时间做自己想做的事，能和家人快乐的生活。\n老师一直认为钱是服务我们的，我们要用钱过我们自己想要生活，而不是本末倒置，为了钱而天天犯愁\n【不懂就去投的人：投机者】，短期内碰上运气了，也能赚到钱，但是他们是怎么度过的呢？！每天把大量时间用来盯着走势，昼夜想着跌了还是涨了，精神总是高度紧张，甚至睡觉都在想明天价格涨跌的情况，因为他们选择了“赌博”\n历史证明，绝大多数投机者本来最应该乐观开心的两年，到头来却是在焦虑、闹心中度过的，因为他们没有真正的投资判断依据，这就是投机者的生活。\n【懂得投资的人】，通过一整套分析方法选出优质的投资目标，算出买入好价格，买入，持有，再算出卖出合理价格，卖出。剩下的时间该干什么干什么\n这几天有好多同学跟老师交流，之前买的什么股票\n老师问当初为什么买这支呀，又说朋友推荐的，感觉不错，结果都被套住啦\n价格跌了，心里知道这是表面的波动，不被其迷惑，拿得住；价格涨了，知道什么时候该卖出，不冲动，赚踏实稳当钱。\n更厉害的，长期持有，被分红的复利滋润着\n这就是学习科学方法的自然成果，这也是不学习像苍蝇撞大运的投机者，与踏实学习走正道的投资者的最大差别\n当然，既不投机，也不投资的人都感受不到这些，他们只能感受到钱越来越不值钱，而自己的生活好像越来越紧吧了。\n总结一句话：投资者获得的是金钱自由，时间自由，心灵自由，投机者就算撞运赚了点，却一直在焦虑与煎熬中。\n今天咱们讲了通货膨胀，老师再给你们举个简单的例子来说一下哈：30年前的1万从购买力上来看，已经相当于现在的100多万。购买力大幅贬值90%以上\n我们能做的只有提高自己的理财能力（收益率），让自己的年化收益率大于通胀率，这样才不会被通货膨胀割韭菜了，通货膨胀每天都在收割辛苦赚钱的老百姓。\n不然只能越攒钱越少啦，所以未来别人已经开始用积累的生钱资产滋润的享受生活，我们再辛苦的为了生计工作，那时候就很尴尬了\n老师再把课程发一下，好多同学还不知道进阶课程\n… 省略 …\n后面你会发现，其实咱们的课程本质是免费的。因为同学们学习英语，学车，各种技能，想想哪个技能比理财技能变现更快，而且持续一生的变现呢，学费在一生过手的钱比起来可以忽略了，但是却能带来一生的财富。\n实践班老师会持续分享好的投资机会，很多学员没毕业学费都赚回来了，并且非工资收入在不断增加中，那我们财富自由还会难吗？\n老师再分享一下进阶课上课的形式哈\n… 省略 …\n@所有人\n【第10天】晚间提醒\n【今晚分享】理财不被割韭菜\n【明日晨读好文】《对于年轻人，财务自由有多重要》\n⭐【重要链接】学习资源大汇总xxxxxxx\n【投资利器】商学院训练营专属课程优惠xxxxxxxx\n优惠名额用完即止~\n【晚间心语】要想不被通胀割韭菜，就要努力提高理财技能\n\n交完作业的总结\n\n同学，收到你的作业啦 ，你已经连续9次交作业了，群里将近200多名同学，你是40人里一直坚持的一员，非常棒你有想过为什么绝大部分人都必定会被割韭菜吗？\nX2、第10天\n12.1 晨读\n\n晨读文章\n\n\n对于年轻人，财务自由有多重要？：点击查看\n\n大家早上好，倒数第二次早读了。再不学习就没有了\n老师开始分享了哦，没看完的继续哈\n我看过大家的财务自由三大目标，其中实现财务自由本身就是大家非常重要的目标之一。\n我相信大家并不是拜金的人，与钱相比更看重的是自由。\n自由不是随心所欲，更不是为所欲为，而是可以拒绝不喜欢的人和不喜欢的事。\n不想在工作、交友、择偶这些人生重要的事情上考虑的第一因素是【钱】。可不想让钱影响我在这些方面的决策。\n怎么才能在做重要决策时不考虑钱呢？\n最重要的是你【不缺钱】️\n当然不缺钱并不是你有一大笔花不完的钱，而是指你拥有能够满足你日常生活的【现金流入】\n这个现金流入就是你的【非工资收入】\n非工资收入对于一个人的幸福意义重大。因为相比于工资收入，非工资收入【更稳定】【更持久】【更安全】。\n为什么这样说呢？我们来看一下人生收支曲线图。\n\n建议大家把这张图片收藏，整个一生你都会了然于胸的\n根据人生收支示意图，大部分人的工资类收入会在40-45岁左右达到人生顶峰，之后会开始下降，退休之后会进一步下降。这很容易理解。\n因为随着年龄的增大，45岁之后，大部分人的竞争力是会减弱，收入自然也会下降。🥶\n而人在退休之后的支出却会增加，这其中大部分是医疗费。【收入的减少】和【支出的增加】（B点）会消耗掉绝大部分存款，甚至还会出现负债。\n靠工资收入的家庭在退休之后很可能会面临【财务困境】或【财务危机】。这个时候能做的就只有“拼孩”了。\n40岁之前靠体力和智力赚钱\n40岁之后就要用钱赚钱了\n我们看到报道知道在香港、日本见到很多70多岁的老人还在辛苦工作，还是很感慨的。他们是退而不能休。\n中国现在已经开始延长退休年龄了，未来靠工资收入的大部分人很可能70多岁也必须要工作。\n因为由于通胀，你的退休金根本没法维持你的生活。你能想象你70多岁了还必须要去谋生的情形吗？\n依靠非工资收入的人就不一样了，\n依靠非工资收入的人即使没了以后，【非工资收入】依然会继续。因为他们的收入来自生钱资产，而生钱资产并不会消失。\n就像巴菲特一样，越老越有钱\n你的孩子会成为富二代，你会有一个美满的晚年生活\n你的生钱资产可以给你的孩子\n在一个法制健全的国家，几乎没有什么风险能让一个人的非工资收入中断。\n但是却有很多因素能让一个人的【工资收入中断】，比如【重大疾病】、【意外事故】、【失业】等\n比如现在的疫情，延期上班，很多人的工资收入都没有着落了\n可见【非工资收入】才是【最安全的收入】，【财务自由】才是最高等级的财务安全。\n大家一定要记住这句话😎\n我们在年青的时候就要学习增加自己的非工资收入，这样随着年龄的增长我们会越来越轻松，越来越幸福。🤓\n对于普通人来说，【非工资收入】主要就是【理财收入】。\n要获得稳定持续的理财收入，其实并不算难。只要把理财技能学好就可以了。\n增加【工资收入】需要提高【工资技能】；增加【非工资收入】，需要提高【理财技能】。这个道理再简单不过了。\n最后送给各位小伙伴一句老师非常喜欢的话。\n走到人生的某一个阶段时，我决心要成为一个【富有之人】。这并不是因为爱钱的缘故，而是为了追求那种【独立自主】的感觉。我喜欢能够自由地说出自己的想法，而不是受到他人意志的左右。——查理.芒格\n好了，老师的分享就到这里。欢迎各位小伙伴输出感悟。\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n对的，只要开始，就是好的，未来一定不会变差\n️要想拥有比现在多的钱，必先增值自己。\n️要想永恒有钱，必要永恒增值自己。\n️增值自己，让现在的自己配得上想要拥有的财富。\n老师给大家分享一个视频，不要认为我们不行，不可以，当我们真的遇到真的困境了，什么都会了\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n同学不要亏钱了，真的遇到困难了有损失才开始反省\n咱们班级好多同学遇到了中年危机，或者理财失败了开始醒悟，如果早些准备，我们可能的财富远远大于现在的情况\n人生不该如此\n人生本该有星辰大海，不要再安逸的穷下去\n那我么今天的早读就到这里啦\n加油，各位同学\n12.2 午读\n\n午读文章\n\n\n企业融资骗局：点击查看\n\n12.3 晚修\n\n晚修预习\n\n\n手把手教你查看常用理财工具：点击查看\n\n@所有人\n【第11天】晚间分享预告：手把手教你查看常用理财工具\n 要点：\n①手机上投资理财软件那么多，该选哪个？\n②怎样在这些软件上查股票、REITs分红等信息？\n③怎样在这些软件上操作货币基金、逆回购？\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n最后一节正式晚课了，大家一定要预习哈\n\n晚修讲解\n\n@所有人\n还没预习的同学抓紧时间啦，咱们20:30准时上课哈\n改变别人很难\n改变自己也很难\n但是改变自己才有希望……\n老师劝你学好理财，是外因，自己想改变财务状况增加收入，是主因。\n内因驱动才是关键。\n@所有人\n同学们，明天你们就从小白营毕业了，今晚是最后一节正式晚课。我们开始签到：机会永远只留给准备好的人\n这是12天最后一节正式晚课\n明晚是毕业晚会\n我无法跟进你们一辈子，但是你们是这十几天里的佼佼者，坚持是最宝贵的精神，这是用钱买不到的。\n结合正确的理财技能，你们就是人生的赢家，比半途而废的人要强很多倍。\n爱学习的人永远是少数\n所以富人永远是少数\n二八定律还在延续\n李嘉诚有一句名言：“30岁以前人要靠体力、智力赚钱，30岁之后要靠钱赚钱。”\n最后一节正式晚课开始\n第一件大事\n进阶课的同学，以后想要创业，可以来申请。最高可以获得微淼100万的投资\n\n第二件大事，在课后讲\n昨晚我们讲的通货膨胀，不理财被通胀亏掉的更多\n只要收益低于10%，你的钱就在贬值\n我们如何应对如此高的贬值？\n投资年化收益率大于10%的工具（好股票、好REITs、好指数基金），跑赢通货膨胀带来的亏损贬值\n不要让自己的钱被通货膨胀吃掉\n开始今天的课程\n第一个重点：前面的晚课中，我们就学过巧用国债逆回购和货币基金组合捡钱的小秘密。\n【捡钱小秘密】\n平时把钱买货币基金，每年可以获得4%左右的无风险收益。当国债逆回购收益高时，比如大于10%时，卖掉货币基金直接买入国债逆回购。这样就可以获得几天的高收益。等国债逆回购的钱回来后，当天买进货币基金。\n因为买卖货币基金没有手续费。这样组合操作就能获得较高的收益。在保证资金方便使用的情况下获得6%+的无风险年化收益率。\n比单纯放在余额宝和银行强多了\n看一下我录的视频\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n看完的吱一声\n其实，还有一个大秘密\n我们在假期前两天买一天期的【国债逆回购】，这样实际计息天数并不只是1天，而是算上整个假期的天数。\n然后假期前一天可以再买入上交所货币基金（建信添益），又可以享受整个假期货币基金的收益。\n建信添益代码 （511660）就是一支货币基金\n这样一笔资金，【同时】可以获得【逆回购】和【货币基金】收益。如果假期的时候逆回购的收益正好比较高，那简直就是白白捡钱。\n已经开户的同学，可以在涨乐财富通操作一下\n但是要注意的是，这个仅限于零花钱\n如果想拿这个来投资，实现财务自由是不可能的\n因为收益率还是跑不赢通货膨胀\n事实上你的钱还是在贬值\n想要自己的钱不贬值，收益至少要在10%以上\n我们看第二个重点：股票和REITS的分红如何查看。\n操作一下会理解的更好\n要想自己的收益超过10%，股票 reits 和指数基金是非常重要的工具\n两分钟大家看一下视频\n\n      \n      Your user agent does not support the HTML5 Video element.\n\n看完了扣1\n好，下边拿茅台举例\n\n\n贵州茅台2015年每股分红6.171元，\n而18年每股分红高达【14.539】元，\n贵州茅台的分红几乎每年都在增加，近5年的时间分红也翻了2倍多\n茅台2001年上市市值80亿，18年下来累计分红575亿。\n这代表什么呢？\n简单来说，如果你在茅台上市的时候买入10万块钱茅台，\n那么这些年即便不算茅台股票的上涨，都能收到70万现金。\n如果算上股价上涨带来的收益，你早就是千万富翁了\n光靠分红不仅收回了本金，还翻了6倍！这就是优质的生钱资产。\n我们商学院之前有位女同学亲身经历：男朋友看不起我学理财知识，说我被骗了，我上了两个月课用茅台赚了1万多，甩给他的时候，他就一声不吭了\n这位女同学把握的就是2019年1月份的买入时机，那时候茅台560元左右\n现在茅台翻了一倍多，1100多块钱了\n这才也就是一年的时间，\n茅台股价就涨了一倍多\n现在茅台已经不是好价格了\n但是\nA股市场肯定还存在下一个茅台\n掌握了理财技能，只需一次，就能改变自己的命运\n所以我劝大家好好学习理财技能，不要以为我在催你报名，我是在帮你\n我们再来看一下美国REITs——PSA（名字）\n\nPSA已经有20多年了，最低价13.5元，最高价在266.76元。\n从图中可以看到PSA几乎每年都在上涨。\n那PSA每年的分红怎么样呢？\n\n一年四次分红，每股2美元\n你要是买入1000股，一个季度就分给你2000美元，合12000多人民币\nPSA每个季度都在稳定的分红，而且分红持续增长\n2018年每股分红8美元，2008年的时候美国发生金融危机，PSA最低的时候跌到40多元\n如果我们在psa50元的价格买入10万元的PSA\n那么现在的价格涨到了221元，你赚了多少钱呢？\n变成44万，翻了4倍多\n而且以后每年光分红至少也能收到1.6万块钱！\n买入这样的reits\n这不就像是按月收房租吗？\n而且还不需要投资几百万买房子来收租\n这就是躺着赚钱\n进阶课老师会带大家手把手开通港股、美股账户，操作reits\n先学习，学好了，有的是机会赚钱\n我学习的时候，我的老师给我做过一个比喻\n你前边100米遍地是钱，\n就看你愿不愿意跑过去，\n把钱捡起来\n不愿意迈出这一步的人，就永远的错过了\n回到以前只靠工资生活\n一辈子可能碌碌无为\n一家人紧巴巴的过一生\n就像我们群，有超过一半的人半途而废 \n开营第一天我就说过，二八定律自己选择\n还真有人选择做那剩下的80%\n我是无能为力帮助这些人了\n7000块和你未来的财务自由相比，哪个重要？\n喵的？不买你7000的课就是半途而废、碌碌无为了？？？！\n我们一辈子会经手很多钱\n几十万，几百万都有\n我们缺的是钱吗？\n我们缺的不是钱，我们缺的是管理钱的技能\n很多人四五十了，为钱困扰四五十年了，还不明白这个道理\n年前就有一家超级好的公司。我9月带的班，那期学员现在学到了第八周了。有的学费挣回来了，给你们看\n… 图片省略，浪费流量 …\n最后再说一下申购新股\n这是一种获得【无风险高收益】的有效途径，特别适合刚学理财的同学。\n具体操作如下，在华泰证券APP涨乐财富通首页找到 “打新神器”\n\n点击“打新神器”进入以下页面\n\n点击“新股申购”就可以申购新股了。能不能申购到凭运气和额度，\n一般只要申购到就会赚钱，收益率高达100%-300%\n如果你运气好，申购到新股，新股第一天收益就可以达到44%.\n没注册也能看到\n不是天都有哈\n一天就有可能赚回6998的学费\n\n点击“新股申购”就可以申购新股了。能不能申购到凭运气和额度，\n\n学好了技能，赚钱的机会多得是\n国内不好，有国外；\n房子不好，有股票；\n股票不好，还能看看分级基金A，\n理财工具合理运用，到处是机会，财富也会越来越多。\n机会永远留给准备好的人\n好了，最后一条富人思维：我们最贵的东西是什么？\n我们最贵的东西是什么？\n我们最宝贵的是【时间】。\n财务自由最重要的是时间自由\n每个人的时间都有24小时，但是你是怎么度过的之前24小时，你自己心里有数\n因此，我们才反反复复强调要站在巨人的肩膀上，前人走过的弯路，我们就不要再走了。\n我们走过的弯路，就不要让孩子再走一遍\n独自学习、独自试错的人，他们需要付出三项成本：时间成本、机会成本、金钱成本。\n中国人均试错成本是16万\n站在巨人肩膀上学习才是脱贫致富的最佳途径\n这是送个大家的最后一条富人思维，大家请收藏好\n进阶课老师每周都会带大家实操\n第一周分享如何实践操作指数基金、\n第二周分享复利法则、\n第三周分享可转债如何操作、\n第四周分享股票精选、计算好价格、\n第五周分享企业护城河、\n第六周分享投资心态、\n第七周分享投资的四大基石、\n第八周分享房地产、\n第九周分享封老师的财务自由实践、\n第十周教大家判断公司好坏的框架流程\n@所有人\n下边讲我是如何精选股票的\n好，不在的人后悔去吧\n我开始讲了\n打开雪球app软件\n搜索贵州茅台\n\n\n看第一个指标：股票投资最重要的指标ROE\n就是净资产收益率，代表一家公司的盈利能力，也就是赚钱的能力。ROE连续5年大于15%的公司的盈利能力比较有竞争力！\n上图可以看出，贵州茅台的盈利能力非常强。\n接下来看第二个指标：毛利率。\n\n毛利率代表一家公司产品的竞争力。毛利率连续5年大于40%的产品的竞争力比较强。\n上图可以看出贵州茅台的毛利率非常高，竞争力很强。\n第三个指标是净利润\n\n\n净利润代表公司是否赚到了钱。净利润为正，并且逐年稳定增长的公司，比较优秀。\n上图可见贵州茅台的很符合要求。\n以上几个指标是精选股票的一些方法\n一家公司是否有盈利能力、产品是否有竞争力、是否安全、是否有成长性、是否有行业竞争力、是否人品好，就都可以一目了然了。\n声明：这个方法不是最终筛选好股票的方法！只可以用作初步精选股票！\n这几个指标可以简单地帮助我们初步诊断股票而已，我们后续的进阶课程会帮忙大家系统学习到更全面的投资技能。\n因为还没有系统的分析财报和企业\n也没有分析好价格，买入时机和卖出时机\n富人思维–\n理财思维–\n生钱资产股票海选–\n优秀生钱资产股票精选–\n财务报表分析–\n公司分析–\n计算买入好价格–\n制定持有标准–\n计算卖出价格。\n牢记我们投资的顺序\n进阶课是按照这个顺序教大家的\n老师用四句话来结束最后一次晚课。\n⭐1、当你是一个基层员工时，你一定要加倍努力创造更大的工作价值，你才能获得高收入\n⭐2、中低层员工要想升职到高层，掌握财报分析和企业知识会有很大的帮助。\n⭐3、无论想做好工作还是做好理财，相关知识都是必须的。知识就是金钱，知识改变命运！\n⭐4、投资自己的大脑是回报率最高的投资！\n好了，正式晚课到此结束\n12天短暂相聚，终须一别\n明晚小白营毕业晚会，大家小白营毕业啦\n明晚给大家讲讲我的故事\n优惠名额还有最后几个，有想报名学习进阶课程的，尽快搭上财务自由的末班车\n@所有人\n最后一课\n【今晚分享】手把手教你查看常用理财工具\n【明日晨读好文】《我的草根同学的财务自由之路》\n【重要链接】学习资料汇总xxxxxx\n【小白营课程专享优惠】xxxxxxx\n【晚间心语】如果你不去解决困难，困难就一直存在。30岁不解决，40岁问题还会来，40岁不解决，50岁还会来，50岁不解决，60岁它还会来。\n\n交作业后\n\n好的，收到作业了！现在课程学完了，还记得自己需要解决的财务问题吗？有答案了吗？\nX3、第11天\n13.1 晨读\n\n文章\n\n\n我的草根同学的财务自由之路：点击查看\n\n开始最后一次早读，没读完的同学继续读哈\n很喜欢这篇文章，因为大头很普通，他既不是富二代，也不是官二代，甚至他一点都不帅。\n成就他的不平凡是因为大头的心里一直有个目标，毕业后10年内赚够100万\n为了实现这个目标大头不断学习理财知识，而且还养成了定投的好习惯。\n大头通过定投A股让自己的生活费结余大幅增值，又通过买进REITs赚了10倍让自己的资金实现了跃升\n工作后又把工资持续的投资A股，提前实现了人生目标，赚了数百万\n大头的理财知识不但让他实现了财务自由，还在房价暴涨前买了房子，娶了一个好老婆。\n大头就是我们身边的甲乙丙，他是一个普通的大学生。走在路上都不会被人多看一眼。但是靠着一个明确的财务目标，不断学习，不断实践。大头在30出头就活成了自己想要的样子。🤗\n可能有人会说大头运气好，因为他毕业后正好遇到了中国股市最不好的几年，用最便宜的价格把所有钱投到了股市里。并且很幸运地遇到了一轮大牛市，又很幸运地在牛市里兑现了大部分利润。\n大头的经历里，毫无疑问是有运气成分的。可运气也好，方法也好，最终都需要一个人真的为了某件事做好了充分的准备和计划以后，好的运气才会从天而降\n比如现在A股，似乎也存在一次让草根逆袭的大机会。但是等机会出现的时候有几个人能改变自己的命运呢？\n我不相信一个缺乏理财技能，没有准备的人，只靠运气就能抓住未来的大机会发家致富。\n大家要记住：钱不会从天上掉下来，也不会从地缝里蹦出来！\n你准备的越充分，当机遇来临时才能把握的住！\n想要财富自由就要不断补充自己，投资自己，料够了，财富也随之而来了！\n你现在可以没钱，但是你不能让你的穷人思想主导你的行为\n正是因为你没钱，你才更需要学习摆脱贫穷！\n一个人财富的起点一定是知识储备的起点\n要改变自己的人生轨迹，相比于财务上生硬干瘪的计划，学习计划是首当其冲，迫切需要的。在现在的社会，“知识改变命运”一样有效\n学习对的方法，实现第一个1万\n第一个100万\n第一个1000万\n希望大家向大头学习，把【股市】、【REITs】当储蓄罐，为自己积攒第一桶金，第一个100万！股市用好就是富人的提款机\n你还记得刚进小白营写的三大财富目标吗？\n你离你的财富目标是越来越近了，还是越来越远了呢？\n大家加油，现在学好理财技能未来可以少奋斗几十年\n最危险的是什么呢\n最危险的不是你当前的月薪低  而是你十年了还和十年前一样  没有进步\n同学们可以想想我们还有几个十年来奋斗，来养鹅呢\n给大家分享一下【封老师】在微淼起步的时候写的【为梦想而战】，相信看了会有感触\n\n为梦想而活，为伟大而战.pdf：点击下载\n\nX4、第12天\n14.1 毕业晚会\n\n晚会文章\n\n\n晚会文章：点击查看\n\n@所有人\n同学们，晚上好，准备开始毕业典礼了，开始签到：毕业不散场，不做后悔的事\n毕业歌：https://musicesge.vmall.com/camp/246/000111.html?songId=19596987&amp;from=groupmessage&amp;isappinstalled=0\n大家听首歌\n聚散有时，12天一闪而过，不曾谋面，但彼此相伴至今\n12天，说长不长，说短不短，能坚持下来的同学们都是最棒的\n成年人的世界很少有人有大把的时间去学习，大家能挤出时间来坚持学习，这是最难能可贵的。\n很多同学都是半夜交作业\n你们努力改变自己财务困境的精神让我非常感动\n最后一晚我给大家一些理财上的忠告吧\n如果你希望成为一个有资产的人，终有一天不是只靠工资来生活，那请你牢牢记住我接下来说的话\n最后的忠告\n首先，就是储蓄，积少成多在任何领域都是成立的。\n无论你的收入是多少，我建议你每次拿到工资都需要至少存20%。\n哪怕你每个月收入只有1000元，你也应该先拿出200-300元去养你的鹅。\n少掉这20%或30%对你的生活不会有太大的影响。存下来的钱可以先放入货币基金。\n然后我们需要用适当的时间跟精力去学习一些理财知识，选择一些相对安全的投资方式把自己的钱投出去。\n然后就是好好工作，继续提升自己，多赚一点，然后多存点，多投资一点，如此形成良性循环，\n终有一天你会发现你的工资跟你的投资收益相比已经是微不足道了!\n复利的威力再怎么强调都不为过，早开始一年就会有非常大的不一样\n存钱，积少成多，越存越多，越投越多，你就会越来越富！\n第二点，就是尽早开始理财。\n你要记住现在早起步的每一天，有可能会让你在未来少奋斗很多年。\n年轻的同学请马上开始理财，\n而有了孩子的父母呢，请马上给孩子设立一个成长账户\n相信我，你做这些肯定不会后悔的！\n越早开始越好！早一年好一年！\n第三点，就是一定一定要注意风险。\n我以前说过，不投资有通货膨胀的风险，不懂就乱投资呢，有本金大幅亏损的风险。\n大家赚钱都不容易，千万不要把自己的钱轻易的打了水漂\n先学习再投资，不懂坚决不碰。\n那些长期无法拿回本金的投资，对于这样的投资一定要小心！\n一定要小心\n牢记投资第一原则：不懂不要投，懂了放心投\n尽早开始，别再为自己年轻，别再为自己没有钱找借口。\n注意风险，找到适合自己的投资方式，\n让投资变成一件快乐的事情，\n为了父母、为了孩子，也为了自己\n这是老师给大家最后的忠告\n大家记住了吗？\n感谢大家这么久坚持陪伴，很感激爱学习的各位，是不是这么长时间，也挺好奇逸鸣老师的一些事情呢\n跟大家讲讲我的故事\n大家请安静听完\n我大学刚毕业时，当时一个人住合租房的隔断里，还是阁楼，没有窗，进屋就是床，同学们可以想象吗，但是价格便宜240一个月，能省就多省一点了，谁让刚毕业没有钱呢，对吧？\n在上学的时候幻想工作之后的美好生活，但大学毕业后却发现不是那么回事，刚步入社会，一切都很迷茫，不知道自己应该做很么工作，自己能做好那份工作。\n但是毕业了，感觉自己不应该再向父母要钱了，如果还要钱会感觉很丢人，所以只能自己省着点，然后尽快找到工作。\n之后在天津找了一个信息员的工作，这个工作朝九晚六，比较安逸，赚的当然也不多，一直月光，总是紧巴巴的\n我想这样不行呀，听说同班同学谁谁谁做设计很好，工资高，还轻松。\n所以我决定改变，于是贷款花了1w多报了达内的UI设计，学了四个月之后在天津工找了一份5000一个月的美工的工作。\n但是最后只给我4000，说我没经验，其他人也是4000\n能怎么办呢？只能忍着干活呗，不然有上顿没下顿啊  ，还有贷款呢\n但是，逐渐发现4000已经不能像以前一样让我很满足了，还是不够花，于是有从天津来到了北京\n那时候UI很热门，很快找了一份网页设计的工作\n在国贸那边\n那年正好国庆期间，爸妈来看我，带爸妈去了天安门、鸟巢、颐和园\n当时爸妈肩并肩走在颐和园，我觉得很幸福\n但记得去北京站送爸妈回家的时候，我绷不住了，哭的稀里哗啦，\n之前上学、上班都是爸妈送我，这次反过来没想到居然这么难受\n不是因为不想让他们走，而是走了还担心我在这过得不好，怕自己舍不得花钱\n没赚到钱，没能给爸妈带来更好的生活，还让他们操心。\n从那以后，我暗自立志，一定要努力让爸妈过上好的生活。不让他们操心\n虽然一直有想法，但总是找不到方法，不知道怎么让自己更好。\n直到两年前，我下班坐地铁，出地铁站的时候，看到微淼工作人员在发传单，当时没注意，随手扔到了包里\n但回到家一翻，莫名的被生钱资产这个概念吸引了。\n我知道了一直没有钱的原因了\n我也知道该努力的方向了\n这是一次改变机会，我不改变就只能永远这么下去，永远不可能给父母好的生活。\n当时我手里还有一点钱，也有过报班学习经历，所以我决定尝试一下\n我一直向往的是：做我喜欢的，和我喜欢的一切在一起，财务自由不就是这样的吗？并且学完课程可以到微淼工作，何乐而不为呢？\n当时微淼还没有小白营，就是直接去学实践课\n也没有6998的优惠，就直接12998元\n一狠心，又花了12998开始学习课程。\n我一边做设计一边学习课程。月薪8000，我只花1500，房租2000，剩下都用来投资，边学习边投资。\n我朋友当时还嘲笑我花1万多学这个，是不是傻,还不如ui让你找一份高薪工作呢\n但是现在只有羡慕我的份，她现在还是在我老家那边当老师，一个月可能3000多块钱左右\n但我呢，慢慢的，开始有了非工资收入，学完课程也顺利的来到微淼上班。\n不仅如此还多次拿到了公司的分红股\n分红股的价格在微淼上市后会增长10倍\n而且去年在老家也给爸妈买了房\n自己和老公也在天津买了新房子，为了孩子以后有一个更好的教育起点\n这是样板间，我们买的是期房，需要明年才能下来，当时为了给家里人看特意让我老公录得\n有没有小伙伴和我是邻居呀\n没法过去呢\n即使是耗钱资产，我也会为了给家人，给爸妈更好的生活继续努力的\n因为我的起点太低了\n路远的孩子就要早点出发\n我不改变不努力不行，收入就是得工资收入+非工资收入并行，才可以！\n现在回过头来看\n这些私事我曾经一度难以启齿，害怕别人知道\n但是现在我毫不避讳，因为我一身本领，我的未来已经很清晰了\n这就是学习理财给我带来的改变\n真的可以改变一个人的命运，甚至改变一个家族的命运。\n我们奋斗一生，不就是为了给父母、给孩子、给自己一个更好的生活吗\n我的故事讲完了，也还在继续\n人生最遗憾的事，从来都不是失败，而是我本可以\n希望大家也能由此改变自己的命运\n最后一晚了，大家畅所欲言吧\n有毕业感言的可以尽情分享\n大家一起加油\n我宣布，20-3期1057班理财小白训练营全体同学正式毕业！！！！\n领毕业证：\nhttp://xiaobai.yaocaiwuziyou.com/index.php/Home/Index/Biye\n拿到结业证书记得发给我，我奖励一本《富爸爸系列之财务自由之路》电子书\n大家在报名的时候，真的不要犹豫未来会怎么样？我告诉你：你们只能变得更好，不会变的差，你现在欠多少钱都不是问题，问题是我们要把它还上，以后不再欠，就一定要有好的理财技能。\nX5、资料汇总下载\n\n点开可能是预览，ctrl+s即可保存\n\n15.1 电子书\n\n《小狗钱钱》：http://start.wdnpy.com/m/files/xgqq.pdf\n《富爸爸财务自由之路》：http://start.wdnpy.com/m/files/fbb1.pdf\n《博恩·崔西重塑自我  如何通过重塑自我实现幸福人生》：http://start.wdnpy.com/m/files/bon.pdf\n《富爸爸穷爸爸》：http://start.wdnpy.com/m/files/fbb2.pdf\n《巴菲特教你读财报》：http://start.wdnpy.com/m/files/buff.pdf\n《富爸爸提高你的财商》：http://start.wdnpy.com/m/files/fbb3.pdf\n《富爸爸投资指南》：http://start.wdnpy.com/m/files/fbb4.pdf\n\n15.2 资料\n\n财务自由纲领.pdf：http://start.wdnpy.com/m/files/cwzygl.pdf\n老板电器财报分析.docx：http://start.wdnpy.com/m/files/bossana.docx\n疫情之下的历史性行情机会.docx：http://start.wdnpy.com/m/files/chan.docx\n为梦想而活，为伟大而战.pdf：http://start.wdnpy.com/m/files/fordream.pdf\n富人思维14条.pdf：http://start.wdnpy.com/m/files/14s.pdf\n微淼小白训练营笔记.pdf：http://start.wdnpy.com/m/files/bobnote.pdf\n小白营思维导图.zip：http://start.wdnpy.com/m/files/dirpic.zip\n\nX6、进阶笔记下载\n\n点开可能是预览，ctrl+s即可保存\n\n\n第1周笔记-财务自由纲领(1-13)、太极图中财务自由智慧(1-2).pdf：点击下载\n第2周笔记-必定实现财务自由的十大步骤(1-10)、财务自由关键词汇(1-9).pdf：点击下载\n第3周笔记-通过财务报表读懂家庭(1-6)、通过财务报表读懂人生(1-10).pdf：点击下载\n第4周笔记-财务自由A股投资方法(1-17).pdf：点击下载\n第5周笔记-财务自由港股投资方法.pdf：点击下载\n第6周笔记-财务自由美股投资方法.pdf：点击下载\n第7周笔记-认识REITS、财务自由香港REITS、美国REITs投资方法：点击下载\n第8周笔记-认识房地产(1-5)、财务自由商品房投资方法(1-7)、房地产投资分析工具使用方法(1-2).pdf：点击下载\n第9周笔记-财务自由现金管理方法-逆回购(1-2)、货币基金(1-3)、分级基金A(1-8).pdf：点击下载\n第10周笔记-家庭保障体系构建方法(1-15)、家庭资产配置方法(1-9)、财务自由实现计划法(1).pdf：点击下载\n财务自由计划书.docx：点击下载\n家庭财务报表（财务自由版）.xlsx：点击下载\n房地产投资分析工具（中国）.xlsx：点击下载\n\nX7、进阶课6988（全）\n\n在百度网盘分享搜到的\n\n\n7天有效，免费分享 （2020/03/02）\n链接：https://pan.baidu.com/s/1F3PNZjm61NwwjxS_Z4_glQ\n提取码：miez\n","plink":"https://www.zzboy.cn/Learning/cd1f13f20864/"},{"title":"Laravel后端问题整理","date":"2020-02-05T11:13:51.000Z","date_formatted":{"ll":"Feb 5, 2020","L":"02/05/2020","MM-DD":"02-05"},"updated":"2021-02-27T13:50:14.086Z","content":"PHP常用命令\n12345678910php test.php          #运行文件php -r &quot;phpinfo();&quot;   #运行语句php -m                #内置和Zend加载模块php -i                #phpinfo()php -i | grep php.ini #查看php配置文件加载路径php -i | grep -i extension_dir  #查看扩展加载路径php –ini              #查看php配置文件加载路径 php -v                #查看php版本 php –versionphp –re xx            #查看是否安装相应的扩展：php –re gdphp –help             #更多命令\nComposer源替换\n1234composer config -gl  #查看composer全局设置# 替换源，以下几个任选一个composer config -g repo.packagist composer https://packagist.phpcomposer.comcomposer config -g repo.packagist composer https://mirrors.aliyun.com/composer\nLaravel自动维护时间字段\n123456789101112131415161718192021222324//MigrationSchema::create(&#x27;users&#x27;, function (Blueprint $table) &#123;    //...省略\t$table-&gt;timestamps();  //使关系表含有create_at和update_at字段&#125;)//Modelclass Users extends Model&#123;    // 可添加字段（白名单）    protected $fillable = [&#x27;name&#x27;, &#x27;sex&#x27;];    // 或者禁止某些字段（黑名单）    protected $guarded = [&#x27;uid&#x27;];&#125;//Controllerclass PublicController extends Controller&#123;    Users::insert();//这样是不会自动维护时间字段的    //以下可实现自动维护字段    $user = new Users(); //实例化user模型    $user-&gt;fillable([&#x27;name&#x27;, &#x27;sex&#x27;]); //给模型指定可填充的字段。（也可以在模型中实现，见Model）    $user-&gt;fill([&#x27;name&#x27;=&gt; &#x27;Tom&#x27;, &#x27;sex&#x27;=&gt;1]); //给实例填充数据，数据字段必须包含在fillable里    $user-&gt;save(); //保存到数据库    $user-&gt;id; //获取自增字段的id&#125;\nLaravel自定义全局公用函数\n\n首先在app下新建一个文件夹Lib，用于放公共函数的php文件，如我建的\n\n12345678910111213&lt;?php//当前路径：app\\Lib\\functions.php    /*** 格式化api返回*/function returnData($isSuccess, $msg, $data)&#123;    return [        &#x27;isSuccess&#x27; =&gt; $isSuccess,        &#x27;msg&#x27; =&gt; $msg,        &#x27;data&#x27; =&gt; $data    ];&#125;\n\n在根目录下，打开composer.json，找到autoload，在其中增加files，如：\n\n123456789101112&quot;autoload&quot;: &#123;    &quot;psr-4&quot;: &#123;        &quot;App\\\\&quot;: &quot;app/&quot;    &#125;,    &quot;classmap&quot;: [        &quot;database/seeds&quot;,        &quot;database/factories&quot;    ],    &quot;files&quot;: [        &quot;app/Lib/functions.php&quot;    ]&#125;,\n\n在终端，执行自动加载命令，即可生效在任何地方直接使用了\n\n1composer dump-autoload\nLaravel项目修改时区\n通常默认安装后，项目的时区不是中国的时区，导致自动维护字段等涉及到时间问题，总是和我们时间相差8小时，这里就需要配置时区了。\n\n打开app.php，找到’timezone’ =&gt; ‘UTC’\n\n12&#x27;timezone&#x27; =&gt; &#x27;UTC&#x27;,   //原来的默认设置&#x27;timezone&#x27; =&gt; env(&#x27;TIMEZONE&#x27;,&#x27;UTC&#x27;),   //修改为这样，通过.env文件配置\n\n打开.env，添加一行\n\n1TIMEZONE=Asia/Shanghai\nLaravel数据库事务\n\n自动：第一个参数为需要进行的数据库操作，第二个参数定义发生死锁时最大的重试次数\n\n12345DB::transaction(function () &#123;    //...    //需要执行的一系列数据库操作    //...&#125;, 5);\n\n手动使用事务\n\n1234567891011try&#123;    DB::beginTransaction();    //...    //需要执行的一系列数据库操作    //...    DB::commit();&#125;catch&#123;    DB::rollBack();&#125;\n","plink":"https://www.zzboy.cn/Learning/ab11027998a1/"},{"title":"EPIC SU-PQR3以及vc++ 2015找不到路径问题","date":"2020-01-30T03:16:59.000Z","date_formatted":{"ll":"Jan 30, 2020","L":"01/30/2020","MM-DD":"01-30"},"updated":"2021-02-27T13:50:09.383Z","content":"写前啰嗦\n之前在圣诞节，免费购买了人生中第一个需要购买才能玩的游戏，为了免费购买这个游戏，我还注册了EPIC这个平台。\n\n燃鹅燃鹅，安装EPIC这个平台失败了\n\nEPIC SU-PQR3解决\n通过点击EPIC提供的错误码，到官网屁都查不到，还是百度发现有人是更新了vc++就可以了\n到官网下载vc++ 2015：https://www.microsoft.com/en-us/download/details.aspx?id=48145\n安装vc++ 2015又出现问题了，提示找不到路径\nvc++ 2015安装找不到路径\n网上绝大部分通过情况ProgramData下的cache来解决，燃鹅在我的电脑上根本不起作用，最后通过笨方法，自己建一个文件夹呗，没想到这样就行了。\n","plink":"https://www.zzboy.cn/Learning/ba14fc1eccd2/"},{"title":"自定义组件-Modal","date":"2019-10-01T09:36:34.000Z","date_formatted":{"ll":"Oct 1, 2019","L":"10/01/2019","MM-DD":"10-01"},"updated":"2021-02-27T13:50:05.181Z","content":"组件功能及效果\n原来微信小程序有个modal标签可以使用，后来不知为何被舍去了。现在只还有一个wx.showModal的API可以使用。这个API是js控制，对于实际项目开发，很难在modal内写自己的视图显示。因此我自己对照wx.showMOdal写了一个组件，通过标签直接使用。以下就是显示效果：\n\n组件事件和属性\n\n\n事件\n说明\n\n\n\n\nbindconfirm\n点击确认按钮触发\n\n\nbindcancel\n点击取消按钮触发\n\n\n\n\n属性\n类型\n默认值\n必填\n说明\n\n\n\n\ntitle\nString\n\n是\n标题\n\n\nshow\nBoolean\nfalse\n否\n控制modal显示\n\n\ntitle-color\nString\nblack\n否\n标题颜色\n\n\ncontent-color\nString\nblack\n否\n内容颜色\n\n\nheight\nString\nauto\n否\nmodal固定高度时，超出内容y轴滑动\n\n\nno-cancel\nBoolean\nfalse\n否\n默认含取消按钮\n\n\ncancel-text\nString\n取消\n否\n取消按钮显示文字\n\n\ncancel-color\nString\nrgba(0,0,0,0.73)\n否\n取消按钮文字颜色\n\n\nno-confirm\nBoolean\nfalse\n否\n默认含确认按钮\n\n\nconfirm-text\nString\n确定\n否\n确认按钮显示文字\n\n\nconfirm-color\nString\n#1298CF\n否\n确认按钮文字颜色\n\n\n使用\n在需要使用的页面，先在该页面的json文件里进行导入，然后就可以使用了。\ndemo.json\n12345&#123;  &quot;usingComponents&quot;: &#123;    &quot;jun-modal&quot;: &quot;../../components/jun-modal/jun-modal&quot;  &#125;&#125;\ndemo.wxml\n123456789101112&lt;jun-modal    show=&quot;&#123;&#123;isShow&#125;&#125;&quot;    title=&quot;标题&quot;    confirm-text=&quot;确定&quot;    confirm-color=&quot;#1298CF&quot;    bindconfirm=&quot;confirm&quot;    content-color=&quot;#363636&quot;    no-cancel=&#x27;true&#x27;    bindconfirm=&quot;bindUserTapConfirm&quot;  &gt;  &lt;view&gt;显示内容&lt;/view&gt;&lt;/jun-modal&gt;\n源码\n右键新建一个Component，按文件后缀依次粘贴。本例为jun-modal：\njun-modal.js\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// components/jun-modal/jun-modal.jsComponent(&#123;  /**   * 组件的属性列表   */  properties: &#123;    // 标题    title: String,    // 是否显示modal    show: &#123;      type: Boolean,      value: false    &#125;,    // 标题颜色    titleColor: &#123;      type: String,      value: &quot;black&quot;    &#125;,    // 内容颜色    contentColor: &#123;      type: String,      value: &quot;black&quot;    &#125;,    // 视图高度    height: &#123;      type: String,      value: &quot;auto&quot;    &#125;,    // 是否显示取消按钮    noCancel: &#123;      type: Boolean,      value: false    &#125;,    // 取消按钮文字    cancelText: &#123;      type: String,      value: &quot;取消&quot;    &#125;,    // 取消按钮颜色    cancelColor: &#123;      type: String,      value: &quot;rgba(0,0,0,0.73)&quot;    &#125;,    // 是否显示确认按钮    noConfirm: &#123;      type: Boolean,      value: false    &#125;,    // 确定按钮文字    confirmText: &#123;      type: String,      value: &quot;确定&quot;    &#125;,    // 确定按钮颜色    confirmColor: &#123;      type: String,      value: &quot;#1298CF&quot;    &#125;  &#125;,  /**   * 组件的初始数据   */  data: &#123;  &#125;,  /**   * 组件的方法列表   */  methods: &#123;    cancel() &#123;      this.setData(&#123; show: false &#125;)      this.triggerEvent(&#x27;cancel&#x27;)    &#125;,    confirm() &#123;      this.setData(&#123; show: false &#125;)      this.triggerEvent(&#x27;confirm&#x27;)    &#125;  &#125;&#125;)\njun-modal.json\n1234&#123;  &quot;component&quot;: true,  &quot;usingComponents&quot;: &#123;&#125;&#125;\njun-modal.wxml\n12345678910111213&lt;!--components/jun-modal/jun-modal.wxml--&gt;&lt;view class=&#x27;jun-mask&#x27; wx:if=&#x27;&#123;&#123;show&#125;&#125;&#x27;&gt;  &lt;view class=&#x27;jun-modal-content&#x27; style=&#x27;height:&#123;&#123;height&#125;&#125;&#x27;&gt;    &lt;view class=&#x27;jun-modal-title&#x27; style=&quot;color:&#123;&#123;titleColor&#125;&#125;&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/view&gt;    &lt;scroll-view scroll-y class=&#x27;jun-main-content&#x27; style=&quot;color:&#123;&#123;contentColor&#125;&#125;&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/scroll-view&gt;    &lt;view class=&#x27;jun-modal-btn-wrapper&#x27;&gt;      &lt;view class=&#x27;jun-cancel-btn&#x27; wx:if=&quot;&#123;&#123;!noCancel&#125;&#125;&quot; style=&#x27;color:&#123;&#123;cancelColor&#125;&#125;&#x27; bindtap=&#x27;cancel&#x27;&gt;&#123;&#123;cancelText&#125;&#125;&lt;/view&gt;      &lt;view class=&#x27;jun-confirm-btn&#x27; wx:if=&quot;&#123;&#123;!noConfirm&#125;&#125;&quot; style=&#x27;color:&#123;&#123;confirmColor&#125;&#125;&#x27; bindtap=&#x27;confirm&#x27;&gt;&#123;&#123;confirmText&#125;&#125;&lt;/view&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;\njun-modal.wxss\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* components/jun-modal/jun-modal.wxss *//* 遮罩层 */.jun-mask&#123;  position: fixed;  left: 0;right: 0;top: 0;bottom: 0;  display: flex;  justify-content: center;  align-items: center;  background-color: rgba(0, 0, 0, 0.53);  z-index: 9999;&#125;/* 容器 */.jun-modal-content&#123;  display: flex;  flex-direction: column;  width: 90%;  background-color: #fff;  border-radius: 10rpx;&#125;/* 标题 */.jun-modal-title&#123;  font-size: 38rpx;  font-weight: 700;  text-align: center;  padding: 20rpx;  border-bottom: 2rpx solid rgba(7,17,27,0.1);&#125;/* 内容 */.jun-main-content&#123;  padding: 8rpx 20rpx;  flex: 1;  height: 100%;  overflow-y: hidden;&#125;scroll-view&#123;  display: block;  width: auto;&#125;/* 按钮 */.jun-modal-btn-wrapper&#123;  display: flex;  flex-direction: row;  height: 100rpx;  line-height: 100rpx;  border-top: 2rpx solid rgba(7,17,27,0.1);&#125;.jun-cancel-btn, .jun-confirm-btn&#123;  flex: 1;  height: 100rpx;  line-height: 100rpx;  text-align: center;  font-size: 34rpx;  font-weight: 700;&#125;.jun-cancel-btn&#123;  border-right: 2rpx solid rgba(7,17,27,0.1);&#125;\n","plink":"https://www.zzboy.cn/Learning/4071501d4be7/"},{"title":"Hexo安装并部署到Github","date":"2019-09-20T13:28:56.000Z","date_formatted":{"ll":"Sep 20, 2019","L":"09/20/2019","MM-DD":"09-20"},"updated":"2021-02-27T13:50:00.966Z","content":"简要说明\n这是搭建hexo博客的简要记录，供大家或者自己以后参考。最开始我是使用的github page托管的博客，但是后来发现github在国内使用经常有各种不流畅的现象。因此我最后采用的方案是同时将博客托管到自己的服务器和github，在域名解析时，将国外流量解析到github page，国内的流量就解析到自己的服务器。托管程序采用的是git。\n配置本地环境\n配置本地node\n\n\nnode下载 官网下载 ;\n\n\n\n将安装目录最好设置在其他目录，我设置的D盘；\n\n打开cmd查看node是否安装成功，通过查看版本即可验证；\n\n\n12node -vnpm -v\n\n\n配置全局变量\n进入安装目录，创建两个文件夹 node_global 和 node_cache，然后执行\n\n12npm config set prefix &quot;D:\\programming\\nodejs\\node_global&quot;npm config set cache &quot;D:\\programming\\nodejs\\node_cache&quot;\n然后给电脑新增环境变量 NODE_PATH 和 Path，这两个值都设置为 D:\\programming\\nodejs\\node_global\n\n\n\n\n安装hexo-cli\n\n","plink":"https://www.zzboy.cn/Learning/b12f390f50cb/"},{"title":"Nginx用certbot获取Let's Encrypt SSL证书","date":"2019-08-14T02:30:18.000Z","date_formatted":{"ll":"Aug 14, 2019","L":"08/14/2019","MM-DD":"08-14"},"updated":"2021-02-27T13:49:55.737Z","content":"一、本文环境\n\nLinux：Ubuntu 16.04\nNginx\n网站已经能http访问\n\n\n本文参考自Certbot官网 https://certbot.eff.org/lets-encrypt/ubuntuxenial-nginx\n\n\n二、关于Apache\n  之前弄过Apache，前面安装一切顺利，使用certbot时就出错，我修复这个错误，又冒出另外一个错误。然后又试了Let’s Encrypt原版安装，在Apache下也不行，也参考了许多文章，网上一大堆Apache下出现这样的问题的文章，怎么解决都不行，所以我放弃了。\n三、获取步骤\n3.1 确保网站能访问\n  浏览器能http访问，Let’s Encrypt下发证书时会验证的，不能访问是获取不了的。\n3.2 添加PPA源\n  依次执行下面命令，如遇到需要Y/N的就按Y，在第四条添加PPA时，需要按Enter键确认。\n\n命令均在root用户下执行，普通用户需前面加sudo指令\n\n12345apt-get updateapt-get install software-properties-commonadd-apt-repository universeadd-apt-repository ppa:certbot/certbotapt-get update\n3.3 安装Certbot\n  执行以下命令，遇到需要确认就Y确认。\n1apt-get install certbot python-certbot-nginx\n3.4 获取并安装证书\n\n执行命令 certbot --nginx ；\n执行过程中，需要输入你的邮箱，他们会向邮箱发一些更新和安全注意事件；\n之后就Agree/Yes吧；\nWhich names would you like to activate HTTPS for? 这里需要选择你要获取证书的域名，下面已经罗列出来了。\n\n选一个：输入域名对应数字；\n多选：输入对应数字，以逗号或者空格隔开；\n全选：不用输入，留空\n\n\nPlease choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.这一步是选择是否将http访问强制重定向到https，下面提供俩个选择，建议选择2 Redirect，下面输入数字2确认即可。选择2原因：曾经某次，我发现自己没用重定向https，当使用http访问网站时，php没解析，直接将源代码显示出来了。\nCongratulations! 恭喜，证书获取并安装完成了！证书有效期90天。\n最后，自己浏览器直接输域名试试吧。如果不能访问，请确认服务器安全规则443端口已打开。\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758certbot --nginxSaving debug log to /var/log/letsencrypt/letsencrypt.logPlugins selected: Authenticator nginx, Installer nginxEnter email address (used for urgent renewal and security notices) (Enter &#x27;c&#x27; tocancel): xxxxxx@qq.comStarting new HTTPS connection (1): acme-v02.api.letsencrypt.org- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Please read the Terms of Service athttps://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You mustagree in order to register with the ACME server athttps://acme-v02.api.letsencrypt.org/directory- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(A)gree/(C)ancel: a- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Would you be willing to share your email address with the Electronic FrontierFoundation, a founding partner of the Let&#x27;s Encrypt project and the non-profitorganization that develops Certbot? We&#x27;d like to send you email about our workencrypting the web, EFF news, campaigns, and ways to support digital freedom.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -(Y)es/(N)o: yStarting new HTTPS connection (1): supporters.eff.orgWhich names would you like to activate HTTPS for?- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: a.zzboy.cn2: b.zzboy.cn3: c.zzboy.cn4: d.zzboy.cn5: e.zzboy.cn6: f.zzboy.cn7: g.zzboy.cn- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Select the appropriate numbers separated by commas and/or spaces, or leave inputblank to select all options shown (Enter &#x27;c&#x27; to cancel): 5Obtaining a new certificatePerforming the following challenges:http-01 challenge for e.zzboy.cnWaiting for verification...Cleaning up challengesResetting dropped connection: acme-v02.api.letsencrypt.orgDeploying Certificate to VirtualHost /etc/nginx/conf.d/e.zzboy.cn.confPlease choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -1: No redirect - Make no further changes to the webserver configuration.2: Redirect - Make all requests redirect to secure HTTPS access. Choose this fornew sites, or if you&#x27;re confident your site works on HTTPS. You can undo thischange by editing your web server&#x27;s configuration.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Select the appropriate number [1-2] then [enter] (press &#x27;c&#x27; to cancel): 2Redirecting all traffic on port 80 to ssl in /etc/nginx/conf.d/e.zzboy.cn.conf- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -Congratulations! You have successfully enabled https://e.zzboy.cn.....\n四、多个域名使用同一证书\n命令：\nsudo certbot certonly --cert-name example.com -d www.example.com,m.example.com\n  cert-name是指定证书的名称，可不加。-d则是该证书包含有效的域名。\n  多个域名可逗号隔开，也可以添加多个-d。\n五、手动安装域名\n  通过certbot certonly命令是仅仅获取SSL证书，需要自己手动安装。在站点配置文件/etc/nginx/conf.d/youdomain.com.conf的server里加一段。其中证书位置在/etc/letsencrypt/live/youdomain.com/目录下，可以自己先确认，也可以将证书移到其他位置。\n  配置完成后重载nginx：systemctl reload nginx\n123456789101112131415server&#123;  #  #前面省略一大段  #  #监听443端口  listen 443 ssl;  #fullchain证书位置  ssl_certificate /etc/letsencrypt/live/youdomain.com/fullchain.pem;  #私钥  ssl_certificate_key /etc/letsencrypt/live/youdomain.com/privkey.pem;  #letsencrypt为nginx的配置  include /etc/letsencrypt/options-ssl-nginx.conf;  ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;&#125;\nfullchain.pem： 是cert.pem（服务器证书本身）和chain.pem（Web浏览器为验证服务器证书）的中间证书，它包含这两个证书。\n\nLet’s Encrypt engineer: fullchain.pem is a concatenation of cert.pem and chain.pem\n\n六、Nginx手动配置http转https\n\n将站点配置文件监听80端口那行去掉；\n在站点配置文件最下方额外加一个server，内容如下：将访问域名301重定向到https路径。同时监听80端口，有强制http访问的返回404；\n配置完成后重载nginx：systemctl reload nginx\n\n1234567891011##前面省略一大段：原站点配置#server &#123;    if ($host = youdomain.com) &#123;        return 301 https://$host$request_uri;    &#125;    listen 80;    server_name youdomain.com;    return 404;&#125;\n\n如果该配置文件有多个域名，if语句块中要加break，否者会报错。\n\n12345678910111213141516##前面省略一大段：原站点配置#server &#123;    if ($host = www.youdomain.com) &#123;        return 301 https://$host$request_uri;        break;    &#125;    if ($host = blog.youdomain.com) &#123;        return 301 https://$host$request_uri;        break;    &#125;    listen 80;    server_name www.youdomain.com blog.youdomain.com;    return 404;&#125;\n七、到期更新\n命令：\ncertbot renew\n  需要证书到期前30内更新。\n八、到期自动更新\n  需要使用shell脚本，给系统加定时任务，可以百度一大堆，以下是我自己写的，可以输出更新日志：\n第一步：找个目录新建一个shell脚本文件，我这里是在/home目录下，建了一个renewCert.sh\n12345#!/bin/sh# 更新证书并记录echo `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &gt;&gt; /home/renewCert.logcertbot renew | grep -A 20 &quot;The following&quot; &gt;&gt; /home/renewCert.logecho -e &quot;\\n&quot; &gt;&gt; /home/renewCert.log\n第二步：创建linux自动任务\n执行命令：crontab -e  (初次使用选择vim-basic)\n找一行空白处，添加：\n12# 每周6凌晨30分更新证书30 0 * * 6 bash /home/renewCert.sh\n日志renewCert.log：\n12345678910112020-02-08 00:30:01The following certs are not due for renewal yet:  path/to/fullchain.pem expires on 2020-03-11 (skipped)No renewals were attempted.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -2020-02-15 00:30:01The following certs are not due for renewal yet:  path/to/fullchain.pem expires on 2020-05-10 (skipped)No renewals were attempted.- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n九、附：Certbot命令\n\n参考自四个空格网：https://www.4spaces.org/certbot-command-line-tool-usage-document/\n\n9.1 用法\ncertbot [子命令] [选项] [-d 域名] [-d 域名]\n  Certbot工具用于获取和安装 HTTPS/TLS/SSL 证书。默认情况下，Certbot会尝试为本地网页服务器(如果不存在会默认安装一个到本地)获取并安装证书。最常用的子命令和选项如下:\n9.2 获取, 安装, 更新证书\n\n(默认) run：获取并安装证书到当前网页服务器；\ncertonly：获取或更新证书，但是不安装；\nrenew ：更新已经获取但快过期的所有证书；\n-d 域名列表：指定证书对应的域名列表，域名之间使用逗号分隔；\n–apache：使用Apache插件进行身份认证和安装\n–standalone：运行一个独立的网页服务器用于身份认证\n–nginx：用Nginx插件进行身份认证和安装\n–webroot：把身份认证文件放置在服务器的网页根目录下；\n–manual： 使用交互式或脚本钩子的方式获取证书；\n-n：非交互式运行；\n–test-cert：从预交付服务器上获取测试证书\n–dry-run：测试获取或更新证书，但是不存储到本地硬盘；\n\n9.3 证书管理\n\ncertificates:显示使用Certbot生成的所有证书的信息；\nrevoke：撤销证书(supply –cert-path)；\ndelete：删除证书；\n\n9.4 管理你的Let’s Encrypt账户\n\nregister：创建Let’s Encrypt ACME账户；\n–agree-tos：同意ACME服务器的订阅协议；\n-m EMAIL：接收有关账户的重要通知的邮箱地址；\n\n9.5 可选参数\n\n-h, –help： 显示帮助信息，然后退出；\n-c 配置文件, –config 配置文件：配置文件的路径 (默认: /etc/letsencrypt/cli.ini或 ~/.config/letsencrypt/cli.ini)；\n-v, –verbose：当前参数可以重复使用多次来增加输出信息的详细程度，例如 -vvv.(默认: -2)；\n-n, –non-interactive, –noninteractive：非交互式运行，即运行过程中不需要询问用户输入，但需要额外的命令行参数。当客户端发现参数缺失时会给出相应的说明。(默认: False)；\n–force-interactive：无论Certbot是否以命令行的方式运行，强制交互式运行。当前参数不能用于renew子命令。(默认: False)\n-d 域名列表, –domains 域名列表, –domain 域名列表：指定域名列表。如果有多个域名，可以多次使用-d参数，也可以在-d参数后使用逗号分隔的域名列表。(默认: 询问)；\n–cert-name 证书名称：指定证书名称。每次Certbot运行只使用一个证书名称。可以使用命令’certbot certificates’查看已生成的证书名称。当创建新的证书时，此选项用于指定证书的名称。(默认: 无)\n–dry-run：使用客户端执行一次试运行，获取测试证书(无效的证书)但不保存到磁盘。当前选项仅用于’certonly’和’renew’子命令。\n\n\n注: 尽管 –dry-run 选项试图阻止任何对系统的修改，但并不能做到完全避免: 如果使用类似apache或nginx网页服务器来认证插件，程序运行过程中，会尝试修改或恢复配置文件来获取测试证书，也会重启网页服务器来部署和回滚这些修改。如果定义了–pre-hook和–post-hook选项它们会被同时执行，这两个选项有助于更精确地模拟更新证书。–renew-hook 选项在这里不会被执行。(默认: False)\n\n\n–preferred-challenges PREF_CHALLS：A sorted, comma delimited list of the preferred challenge to use during authorization with the most preferred challenge listed first (Eg, “dns” or “tls-sni-01,http,dns”). Not all plugins support all challenges. See https://certbot.eff.org/docs/using.html#plugins for details. ACME Challenges are versioned, but if you pick “http” rather than “http-01”, Certbot will select the latest version automatically. (default: [])；\n–user-agent 用户代理：设置本客户端的用户代理信息。用户代理信息用于CA机构收集关于操作系统和插件的使用成功率。如果你希望隐藏此信息，设置此选项为””。(默认: CertbotACMEClient/0.12.0 (Ubuntu 16.04.2 LTS) Authenticator/XXX Installer/YYY)。\n\n","plink":"https://www.zzboy.cn/Learning/97cad6591dc5/"},{"title":"Nginx站点配置","date":"2019-08-13T01:11:42.000Z","date_formatted":{"ll":"Aug 13, 2019","L":"08/13/2019","MM-DD":"08-13"},"updated":"2021-02-27T13:49:52.454Z","content":"一、域名解析\n  在配置站点之前，先到自己购买的域名页面，将域名A解析到我们服务器的公网IP。\n二、找到默认配置文件\n  之前安装完成了LNMP环境，现在开始配置站点了。首先是找到nginx默认的配置文件default，在 /etc/nginx/sites-enabled/ 目录下。我们将它复制到 /etc/nginx/conf.d/ ，并更改名为 yousite.com.conf 。这样改名的好处就是以后一目了然那个站点对应那个配置文件。\n1cp /etc/nginx/sites-enabled/default /etc/nginx/conf.d/www.zzboy.cn.conf\n  另外我们还需要将nginx默认站点给去掉，编辑 /etc/nginx/nginx.conf 文件，找到 include /etc/nginx/sites-enabled/*; 将其注释掉。当然也可以选择忽略此步，不关闭这个apache2默认站点。我们可以注意到，这个配置文件中这两行可以加载conf.d目录下的所有以.conf为后缀的文件和sites-enabled下的所有配置文件。我们直接注释掉这个加载默认站点的语句，即可关闭默认站点。\n1234vim /etc/nginx/nginx.conf        include /etc/nginx/conf.d/*.conf;#       include /etc/nginx/sites-enabled/*;\n三、配置文件\n  打开我们的复制到conf.d目录下的配置文件，编辑它。以下就是默认配置文件的内容，我就在里面用注释简单说一下。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970### You should look at the following URL&#x27;s in order to grasp a solid understanding# .....此处忽略一大堆注释# Default server configuration#server &#123;        # 监听ipv4的80端口        listen 80 default_server;        # 监听ipv6的80端口        listen [::]:80 default_server;        #SSL证书配置，本段忽略，用Let&#x27;s Encrypt免费SSL证书可以自动配置        # SSL configuration        # .....此处忽略一大堆注释        # 站点目录：也就是你的网站源代码根目录        root /var/www/html;        # 入口页面，一般是index.html 或者 index.php，当然改成其他如home.php也行        # Add index.php to the list if you are using PHP        index index.html index.htm index.nginx-debian.html;        # 服务器名称，这里就是绑定域名，_表示不用域名，ip直接访问        server_name _;        # 网站404文件路径配置        location / &#123;                # First attempt to serve request as file, then                # as directory, then fall back to displaying a 404.                try_files $uri $uri/ =404;        &#125;        # php文件解析设置        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        # 我们用php就需要把下面注释去掉        #location ~ \\.php$ &#123;        #       include snippets/fastcgi-php.conf;        #       # 用原生php-cgi管理        #       # With php7.0-cgi alone:        #       fastcgi_pass 127.0.0.1:9000;        #       # 用php-fpm管理，两者只能选一        #       # With php7.0-fpm:        #       fastcgi_pass unix:/run/php/php7.0-fpm.sock;        #&#125;        # 阻止apache站点的配置文件.htaccess。        # deny access to .htaccess files, if Apache&#x27;s document root        # concurs with nginx&#x27;s one        # 我们这是nginx服务器，可能你上传的站点以前是apache的，这里是避免不必要的问题需要将下面注释去掉        #location ~ /\\.ht &#123;        #       deny all;        #&#125;&#125;# 这下面就是给的一个配置简单例子。# Virtual Host configuration for example.com## You can move that to a different file under sites-available/ and symlink that# to sites-enabled/ to enable it.##server &#123;#       listen 80;#       listen [::]:80;##       server_name example.com;##       root /var/www/example.com;#       index index.html;##       location / &#123;#               try_files $uri $uri/ =404;#       &#125;#&#125;\n四、我们的配置\n  上面不懂没关系，可以直接拿走下面的用，一下以站点www.zzboy.cn配置为例：\n1234567891011121314151617181920212223242526#config for www.zzboy.cnserver &#123;        listen 80;        # listen [::]:80; #服务器没有ipv6地址就不用监听了        root /home/www.zzboy.cn; #站点目录名www.zzboy.cn，方便管理        # 首页，入口页        index index.html index.htm index.php;        # 绑定域名        server_name www.zzboy.cn;        # 404 路径        location / &#123;                try_files $uri $uri/ =404;        &#125;        # php管理，我们是7.2，一般都是在/run/php/下        location ~ \\.php$ &#123;                include snippets/fastcgi-php.conf;        #       # With php7.0-cgi alone:        #       fastcgi_pass 127.0.0.1:9000;        #       # With php7.0-fpm:                fastcgi_pass unix:/run/php/php7.2-fpm.sock;        &#125;        # 阻止.htaccess        location ~ /\\.ht &#123;                deny all;        &#125;&#125;\n  配置完成后，保存退出。重新加载nginx，重载配置文件前，要确认存在站点目录，否者会报错。\n123systemctl reload nginx#如果报错，可用以下命令查看错误nginx -t\n  现在可以用在浏览器输入域名访问了。\n五、多站点配置\n  多站点配置很简单，下面我以第二个站点为blog.zzboy.cn进行配置。\n\n同样先将网站2的域名A解析到服务器公网IP。\n复制之前配置好的文件\n\n1cp /etc/nginx/conf.d/www.zzboy.cn.conf /etc/nginx/conf.d/blog.zzboy.cn.conf\n\n打开blog.zzboy.cn.conf，只需要改两处（站点目录和域名绑定）就行了：\n\n1234567891011121314151617181920212223242526#config for blog.zzboy.cnserver &#123;        listen 80;        # listen [::]:80; #服务器没有ipv6地址就不用监听了        root /home/blog.zzboy.cn; #站点目录名blog.zzboy.cn，方便管理        # 首页，入口页        index index.html index.htm index.php;        # 绑定域名        server_name blog.zzboy.cn;        # 404 路径        location / &#123;                try_files $uri $uri/ =404;        &#125;        # php管理，我们是7.2，一般都是在/run/php/下        location ~ \\.php$ &#123;                include snippets/fastcgi-php.conf;        #       # With php7.0-cgi alone:        #       fastcgi_pass 127.0.0.1:9000;        #       # With php7.0-fpm:                fastcgi_pass unix:/run/php/php7.2-fpm.sock;        &#125;        # 阻止.htaccess        location ~ /\\.ht &#123;                deny all;        &#125;&#125;\n  配置完成后，保存退出。重新加载nginx：\n1systemctl reload nginx\n  现在在浏览器访问第二个站点了。\n六、有个小疑问\n  配置多站点后，只能有一个站点可用default_server，为啥？\n","plink":"https://www.zzboy.cn/Learning/a6fb2798339e/"},{"title":"Ubuntu 16.04搭建lnmp环境","date":"2019-08-12T09:00:00.000Z","date_formatted":{"ll":"Aug 12, 2019","L":"08/12/2019","MM-DD":"08-12"},"updated":"2021-02-27T13:49:49.361Z","content":"一、环境说明\n\nLinux：阿里云轻量应用服务器Ubuntu16.04\nNginx：1.10.3\nMySQL：5.7.27\nPHP： 7.2.21\n\n\n二、写前吐槽\n  回想上次完全自己搭环境，还是大一的时候，啥也不会，linux基础命令都不会，买了个学生机，安装网上方法，lnmp搭建了三天，期间出问题不知重置了多少次服务器。后来我就直接用镜像市场的免费镜像了。\n  这次，因为项目需要，一不小心买了台阿里云轻量应用服务器，买完服务器更换系统镜像才发现阿里云轻量应用服务器，除了安装官方提供的几个应用镜像wordpress、lnmp啥的，此外只能用纯系统镜像了，应用市场用不了。于是我就选择了Ubuntu16.04，决定自己再搭一次！！\n三、安装步骤\n3.1 购买服务器\n  购买过程就免了，选系统的时候一定选Linux的Ubuntu，本文是针对Linux的，至于Ubuntu版本，没什么要求，可以和我选一样的，也可以选更高的19版本，低版本也是可以的。\n3.2 下载连接工具Putty\nPutty完整下载页\n推荐Putty.exe 不要1M的大小，也不用安装。下载后直接运行，输入你服务器的公网IP地址直接连接。\n3.3 使用root用户\n  如果不是root用户，建议切换的root用户下进行安装。现在服务器上也没有什么项目，一片空白，用root用户不怕出错，错了大不了重置系统重来嘛，反正现在也只是自己一个鼓捣。用root用户畅通无阻，方便！但是，今后对已有项目或者重要的服务器，慎用root用户，用普通用户操作，需要权限是再确认一下就Ok了。\n\n切换用户命令\n\n1su root\n3.4 安装nginx\n\n拿到新机器时，先进行apt-get更新，不然会出错。\n\n1apt-get update\n\n安装nginx\n\n1apt-get install nginx\n\n验证是否安装成功\n\n12nginx -vnginx version: nginx/1.10.3 (Ubuntu)\n3.5 安装MySQL\n\n安装MySQL\n\n1apt-get install mysql-server\n\n安装过程中会输入两次账号为root的密码，第二次为确认密码。\n验证是否成功\n\n12mysql --versionmysql  Ver 14.14 Distrib 5.7.27, for Linux (x86_64) using  EditLine wrapper\n\n设置密码\n\n123456mysql -uroot -puse mysql;update user set authentication_string=PASSWORD(&quot;密码&quot;) where user=&#x27;root&#x27;;update user set plugin=&quot;mysql_native_password&quot;;flush privileges;quit;\n\n开启远程连接\n\n注意：远程连接需要开启默认端口，需要到控制台安全组开启3306端口\n1/etc/mysql/mysql.conf.d/mysqld.cnf\n注释掉bind-address:\n1#bind-address           = 127.0.0.1\n然后重启mysql：\n1service mysql restart\n3.6 安装PHP\n\n正常执行install会找不到源，所以可以通过修改PPA源进行安装。第三条命令添加ppa源时，会让点击一次Enter键，点完若长时间不响应，可以Ctrl+C停止安装，再重新执行一次（我的经历）。\n\n12345apt-get install python-software-propertiesapt install software-properties-commonadd-apt-repository ppa:ondrej/phpapt-get updateapt-get install -y php7.2\n\n验证安装是否成功\n\n12345php -vPHP 7.2.21-1+ubuntu16.04.1+deb.sury.org+1 (cli) (built: Aug  7 2019 09:53:30) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.2.0, Copyright (c) 1998-2018 Zend Technologies    with Zend OPcache v7.2.21-1+ubuntu16.04.1+deb.sury.org+1, Copyright (c) 1999-2018, by Zend Technologies\n\n安装完PHP后，还要安装一些基础扩展model\n查询所有扩展\n\n1apt-cache search php7.2\n\n扩展安装\n\n1apt-get install php7.2-mysql php7.2-curl php7.2-json php7.2-cgi php7.2-xsl php7.2-bcmath php7.2-gmp php7.2-mbstring php7.2-zip\n\n安装php-fpm，为什么要用php-fpm\n\n1apt-get install php7.2-fpm\n3.7 nginx管理\n\n关闭nginx：\n\n1systemctl stop nginx\n\n开启nginx：\n\n1systemctl start nginx\n\n重启nginx：\n\n1systemctl restart nginx\n\n如果您只是进行配置更改，Nginx通常可以重新加载，可以使用此命令：\n\n1systemctl reload nginx\n\n关闭 Nginx随系统启动\n\n1systemctl disable nginx\n\n开启 Nginx 随系统一起启动\n\n1systemctl enable nginx\n3.8 参考文章\n  本文安装步骤是参考简书的一片文章，根据实际情况，稍有改变。\n  尊重原创：原文地址：沧海99\n四、站点访问\n  上面过程已经完成的环境搭建，现在可以在浏览器输入你服务器的公网IP地址访问了。你将会看到一片Apache2 Ubuntu Default Page的默认页面。此页面位于 /var/www/html/index.html, nginx配置文件位于 /etc/nginx/sites-enabled/default。至于如何配置nginx站点，可自行百度一下。\n","plink":"https://www.zzboy.cn/Learning/1e8a589a019b/"},{"title":"阿里云轻量应用服务器mysql命令找不到问题","date":"2019-08-12T06:40:00.000Z","date_formatted":{"ll":"Aug 12, 2019","L":"08/12/2019","MM-DD":"08-12"},"updated":"2021-02-27T13:49:45.862Z","content":"一、自己想的方法\n切换到mysql的bin目录，直接执行./mysql -u username\n12cd /usr/local/mysql/bin./mysql -u user\n二、设置系统环境变量\n网上找的方法，将bin路径添加到系统环境变量。\n1234567891011# 打开profile文件vim /etc/profile# 按 大写G，跳到最后一行G# i 插入一句export PATH=$PATH://usr/local/mysql/bin# Esc :wq 保存退出:wq# 重载文件 ，之后就可以在任何地方直接用 mysql命令了source /etc/profile\n三、还遇到一个奇怪问题\nmysql: [ERROR] unknown variable 'basedir=/usr/local/mysql'\n解决办法：编辑my.cnf文件，将[mysql]改为[mysqld]，改完保存就可以了，不用像网上说那样还要安全重启数据库。\n1234567# 把原来的mysql改为mysqld[mysqld]#sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES# 一般配置选项basedir = /usr/local/mysqldatadir = /usr/local/mysql/data\n","plink":"https://www.zzboy.cn/Learning/7d0967cf5d03/"},{"title":"JavaScript-axios","date":"2019-08-01T08:25:00.000Z","date_formatted":{"ll":"Aug 1, 2019","L":"08/01/2019","MM-DD":"08-01"},"updated":"2021-02-27T13:49:39.948Z","content":"一、特点\nAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。\n\n从浏览器中创建 XMLHttpRequests\n支持 Promise API\n拦截请求和响应\n转换请求数据和响应数据\n取消请求\n自动转换 JSON 数据\n客户端支持防御 XSRF\n\n二、安装\n使用npm：\n1npm install axios --save\n使用cdn：\n1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;\n三、使用\n3.1 通用API\naxios(config)\n12345678910// 发送 POST 请求axios(&#123;    method: &#x27;post&#x27;,    url: &#x27;&#x27;,    data: &#123;      key: value    &#125;  &#125;)  .then( function (res)&#123;&#125; )  .catch( function (err)&#123;&#125; );\n成功返回：\n1234567&#123;  data: &#123;&#125;,  status: 200,       //HTTP 状态码  statusText: &#x27;OK&#x27;,  //HTTP 状态信息  headers: &#123;&#125;,       //响应头  config: &#123;&#125;         //为请求提供的配置信息&#125;\n错误处理：\n123456789101112.catch(function (error) &#123;  if (error.response) &#123;    // 请求已发出，但服务器响应的状态码不在 2xx 范围内    console.log(error.response.data);    console.log(error.response.status);    console.log(error.response.headers);  &#125; else &#123;    // 因axios配置而导致的错误    console.log(&#x27;Error&#x27;, error.message);  &#125;  console.log(error.config);  &#125;);\n3.2 axios.get()\naxios.get(url[, config])\n1234567891011axios.get(&#x27;url&#x27;, &#123;    params: &#123;      key: value   //会处理成：url?key=value&amp;...    &#125;  &#125;)  .then(function (response) &#123;    console.log(response);  &#125;)  .catch(function (error) &#123;    console.log(error);  &#125;);\n3.3 axios.post()\naxios.post(url[, data[, config]])\n123456789axios.post(&#x27;url&#x27;, &#123;    key: value  &#125;)  .then(function (response) &#123;    console.log(response);  &#125;)  .catch(function (error) &#123;    console.log(error);  &#125;);\n四、并发请求\naxios.all(iterable)\naxios.spread(callback)\n123456789101112function getUserAccount() &#123;  return axios.get(&#x27;url1&#x27;);&#125;function getUserPermissions() &#123;  return axios.get(&#x27;url2&#x27;);&#125;axios.all([getUserAccount(), getUserPermissions()])  .then(axios.spread(function (acct, perms) &#123;    // 两个请求现在都执行完成  &#125;));\n五、其他别名请求\n在使用别名方法时， url、method、data 这些属性都不必在配置中指定。\naxios.request(config)\naxios.get(url[, config])\naxios.delete(url[, config])\naxios.head(url[, config])\naxios.post(url[, data[, config]])\naxios.put(url[, data[, config]])\naxios.patch(url[, data[, config]])\n六、config详细\n只有 url 是必需的，method默认使用 get 方法。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&#123;  // `url` 是用于请求的服务器 URL  url: &#x27;url&#x27;,  // `method` 是创建请求时使用的方法  method: &#x27;get&#x27;, // 默认是 get  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL  baseURL: &#x27;https://some-domain.com/api/&#x27;,  // `transformRequest` 允许在向服务器发送前，修改请求数据  // 只能用在 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream  transformRequest: [function (data) &#123;    // 对 data 进行任意转换处理    return data;  &#125;],  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据  transformResponse: [function (data) &#123;    // 对 data 进行任意转换处理    return data;  &#125;],  // `headers` 是即将被发送的自定义请求头  headers: &#123;&#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;&#125;,  // `params` 是即将与请求一起发送的 URL 参数  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象  params: &#123;    ID: 12345  &#125;,  // `paramsSerializer` 是一个负责 `params` 序列化的函数  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)  paramsSerializer: function(params) &#123;    return Qs.stringify(params, &#123;arrayFormat: &#x27;brackets&#x27;&#125;)  &#125;,  // `data` 是作为请求主体被发送的数据  // 只适用于这些请求方法 &#x27;PUT&#x27;, &#x27;POST&#x27;, 和 &#x27;PATCH&#x27;  // 在没有设置 `transformRequest` 时，必须是以下类型之一：  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams  // - 浏览器专属：FormData, File, Blob  // - Node 专属： Stream  data: &#123;    firstName: &#x27;Fred&#x27;  &#125;,  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)  // 如果请求话费了超过 `timeout` 的时间，请求将被中断  timeout: 1000,  // `withCredentials` 表示跨域请求时是否需要使用凭证  withCredentials: false, // 默认的  // `adapter` 允许自定义处理请求，以使测试更轻松  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).  adapter: function (config) &#123;    /* ... */  &#125;,  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头  auth: &#123;    username: &#x27;janedoe&#x27;,    password: &#x27;s00pers3cret&#x27;  &#125;,  // `responseType` 表示服务器响应的数据类型，可以是 &#x27;arraybuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;  responseType: &#x27;json&#x27;, // 默认的  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称  xsrfCookieName: &#x27;XSRF-TOKEN&#x27;, // default  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称  xsrfHeaderName: &#x27;X-XSRF-TOKEN&#x27;, // 默认的  // `onUploadProgress` 允许为上传处理进度事件  onUploadProgress: function (progressEvent) &#123;    // 对原生进度事件的处理  &#125;,  // `onDownloadProgress` 允许为下载处理进度事件  onDownloadProgress: function (progressEvent) &#123;    // 对原生进度事件的处理  &#125;,  // `maxContentLength` 定义允许的响应内容的最大尺寸  maxContentLength: 2000,  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte  validateStatus: function (status) &#123;    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的  &#125;,  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目  // 如果设置为0，将不会 follow 任何重定向  maxRedirects: 5, // 默认的  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：  // `keepAlive` 默认没有启用  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),  // &#x27;proxy&#x27; 定义代理服务器的主机名称和端口  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。  proxy: &#123;    host: &#x27;127.0.0.1&#x27;,    port: 9000,    auth: : &#123;      username: &#x27;mikeymike&#x27;,      password: &#x27;rapunz3l&#x27;    &#125;  &#125;,  // `cancelToken` 指定用于取消请求的 cancel token  // （查看后面的 Cancellation 这节了解更多）  cancelToken: new CancelToken(function (cancel) &#123;  &#125;)&#125;\n","plink":"https://www.zzboy.cn/Learning/3802578f2aa7/"},{"title":"微信小程序快速上手教程-3","date":"2019-07-29T05:45:00.000Z","date_formatted":{"ll":"Jul 29, 2019","L":"07/29/2019","MM-DD":"07-29"},"updated":"2021-02-27T15:17:14.560Z","content":"  这一节我们将实现个人课程表小程序开发！\n内容主要有：\n\n可滑动视图：scroll-view\n网络请求：wx.request\n滚动选择器：picker\n表单容器：form\n页面切换\n\n \n教程（三）-个人课程表实现\n一、本节简介\n  上节内容主要讲解了微信小程序几个常用API和引用框架。我发现干讲知识有点太枯燥，这节开始实战- 个人课程表 ，在项目编写过程中，顺带讲知识点，先把本节知识点列出来，看完教程希望多阅读阅读官方文档。下面知识点均链接到具体官方文档地址。\n\n可滑动视图scroll-view\n网络请求wx.request\n滚动选择器picker\n表单容器form\n\n二、先画课程表\n  我们直奔主题，先把课程表显示出来。在写之前，我们要先分析一下布局。想思考一下，我们的课程表横按周一至周日排列，纵按节次排列，那就是一个表格了，在微信小程序里，没有table，tr，td标签，我们可以通过flex布局自己来实现。\n\n2.1 先实现课程表布局\n\n12345678910111213141516171819202122&lt;!--index.wxml--&gt;&lt;view class=&#x27;app&#x27;&gt;  &lt;view class=&#x27;table&#x27;&gt;    &lt;view class=&#x27;tr&#x27;&gt;      &lt;view class=&#x27;td&#x27;&gt;我是高数&lt;/view&gt;      &lt;view class=&#x27;td&#x27;&gt;我是高数&lt;/view&gt;      &lt;view class=&#x27;td&#x27;&gt;我是高数&lt;/view&gt;      &lt;view class=&#x27;td&#x27;&gt;我是高数&lt;/view&gt;      &lt;view class=&#x27;td&#x27;&gt;我是高数&lt;/view&gt;    &lt;/view&gt;    &lt;view class=&#x27;tr&#x27;&gt;      &lt;view class=&#x27;td&#x27;&gt;我是高数&lt;/view&gt;      &lt;view class=&#x27;td&#x27;&gt;我是高数&lt;/view&gt;      &lt;view class=&#x27;td&#x27;&gt;我是高数&lt;/view&gt;      &lt;view class=&#x27;td&#x27;&gt;我是高数&lt;/view&gt;      &lt;view class=&#x27;td&#x27;&gt;我是高数&lt;/view&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;\n123456789101112131415161718192021/**index.wxss**/.app&#123;  margin: 0;  padding: 8rpx;&#125;.table&#123;  display: flex;  flex-direction: column;&#125;.tr&#123;  display: flex;  flex-direction: row;&#125;.td&#123;  background-color: red;  width: 120rpx;  height: 180rpx;  margin: 10rpx;  padding: 8rpx;  font-size: 28rpx;&#125;\n\n最外层加了.app的容器，一般建议做一个页面最外层都包裹起，在不清楚默认会是什么容器下，这种做法是最好的。然后让内边距距离边缘8rpx，为了让内容不是贴着边的，比较好看好看点。\n先前已经说了，微信小程序是没有表格标签的，我们通过flex布局自己实现了表格布局。最外层.table作为容器，让内部元素flex纵向排列，也就是让.tr容器纵向排列。\n然后.tr作为行容器，以flex布局，让内部.td横向排列。\n.td将作为我们课程表的每个课程的容器。开发时先设置了背景色便于我们观察。设置好宽高，设置margin是让各个.td之间隔开。padding同样是为了内部内容不贴边显得美观点。\n最后，我们可以将.tr复制成5行，就对应了1-2,3-4,5-6,7-8,9-10节课。好了，我们的布局大概这样实现了。还是挺容易地吧。之后我们就可以在.td里填入我们的课程信息了。\n\n2.2 思考？列表渲染\n  相信有人注意到了，我们前面其实很多重复代码，例如.tr行，.td单元格。而我们上一节刚刚将了列表渲染。那我们来思考一下，如何进行列表渲染。\n\n首先，.table是只有一个的，不用进行列表渲染；\n.tr行，这个我们需要5行（1-2，3-4，5-6，7-8，9-10）。而没个.tr内还要5个.td（暂不考虑周六周日课程）。那么我就需要一个二维数组格式的列表数据了。\n\n1234567kcb: [    [&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;],    [&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;],    [&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;],    [&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;],    [&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;,&quot;我是高数&quot;]]\n\n好像上面的数据格式已经可以满足我们的列表渲染了。但再仔细想想，我们的课程表好像还要显示其他的信息吧，教室？教师？等数据怎么安排？\n先看看如下格式：\n\n123456789101112131415kcb: [    [&#123;name: &quot;我是高数&quot;, room: &quot;A233&quot;, teacher: &quot;教师名&quot;&#125;,     &#123;name: &quot;我是高数&quot;, room: &quot;A233&quot;, teacher: &quot;教师名&quot;&#125;,     &#123;name: &quot;我是高数&quot;, room: &quot;A233&quot;, teacher: &quot;教师名&quot;&#125;,     &#123;name: &quot;我是高数&quot;, room: &quot;A233&quot;, teacher: &quot;教师名&quot;&#125;,     &#123;name: &quot;我是高数&quot;, room: &quot;A233&quot;, teacher: &quot;教师名&quot;&#125;],    [&#123;name: &quot;我是高数&quot;, room: &quot;A233&quot;, teacher: &quot;教师名&quot;&#125;,     &#123;name: &quot;我是高数&quot;, room: &quot;A233&quot;, teacher: &quot;教师名&quot;&#125;,     &#123;name: &quot;我是高数&quot;, room: &quot;A233&quot;, teacher: &quot;教师名&quot;&#125;,     &#123;name: &quot;我是高数&quot;, room: &quot;A233&quot;, teacher: &quot;教师名&quot;&#125;,     &#123;name: &quot;我是高数&quot;, room: &quot;A233&quot;, teacher: &quot;教师名&quot;&#125;],    [...],[...],[...] //篇幅有限，就不复制了吧]\n\n对！对象！使用对象，我们可以将每一个.td内容存为一个对象，然后渲染数据的时候，我们可以通过item.name获取课程名，item.room获取教室。\n\n2.3 列表渲染实现布局\n\n我们先将数据写进js中的data里，大家可以直接复制下面数据。数据就这样先用假的。\n\n123456789101112131415161718192021222324252627282930313233343536373839404142//index.jsPage(&#123;  data: &#123;    kcb: [      [        &#123; name: &quot;高数1&quot;, room: &quot;A231&quot;, teacher: &quot;吴老师&quot; &#125;,        &#123; name: &quot;&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,        &#123; name: &quot;大学英语&quot;, room: &quot;A512&quot;, teacher: &quot;刘老师&quot; &#125;,        &#123; name: &quot;计算机基础&quot;, room: &quot;B322&quot;, teacher: &quot;王老师&quot; &#125;,        &#123; name: &quot;&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,      ],      [        &#123; name: &quot;大学物理1&quot;, room: &quot;A211&quot;, teacher: &quot;陈老师&quot; &#125;,        &#123; name: &quot;体育&quot;, room: &quot;操场&quot;, teacher: &quot;赵老师&quot; &#125;,        &#123; name: &quot;大学物理1&quot;, room: &quot;A111&quot;, teacher: &quot;还老师&quot; &#125;,        &#123; name: &quot;线性代数&quot;, room: &quot;A432&quot;, teacher: &quot;姜老师&quot; &#125;,        &#123; name: &quot;高数1&quot;, room: &quot;A231&quot;, teacher: &quot;吴老师&quot; &#125;,      ],      [        &#123; name: &quot;日语基础&quot;, room: &quot;A152&quot;, teacher: &quot;忘老师&quot; &#125;,        &#123; name: &quot;Java开发&quot;, room: &quot;B111&quot;, teacher: &quot;乐老师&quot; &#125;,        &#123; name: &quot;大学英语&quot;, room: &quot;A512&quot;, teacher: &quot;刘老师&quot; &#125;,        &#123; name: &quot;计算机基础&quot;, room: &quot;B322&quot;, teacher: &quot;王老师&quot; &#125;,        &#123; name: &quot;&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,      ],      [        &#123; name: &quot;高数1&quot;, room: &quot;A231&quot;, teacher: &quot;吴老师&quot; &#125;,        &#123; name: &quot;&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,        &#123; name: &quot;大学英语&quot;, room: &quot;A512&quot;, teacher: &quot;刘老师&quot; &#125;,        &#123; name: &quot;计算机基础&quot;, room: &quot;B322&quot;, teacher: &quot;王老师&quot; &#125;,        &#123; name: &quot;高数1&quot;, room: &quot;A231&quot;, teacher: &quot;吴老师&quot; &#125;,      ],      [        &#123; name: &quot;&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,        &#123; name: &quot;&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,        &#123; name: &quot;大物1重修&quot;, room: &quot;A123&quot;, teacher: &quot;好老师&quot; &#125;,        &#123; name: &quot;&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,        &#123; name: &quot;&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,      ],    ]  &#125;,&#125;)\n\n列表渲染\n\n12345678910111213141516171819202122&lt;!--index.wxml--&gt;&lt;view class=&#x27;app&#x27;&gt;  &lt;view class=&#x27;table&#x27;&gt;    &lt;view class=&#x27;tr&#x27;      wx:for=&quot;&#123;&#123;kcb&#125;&#125;&quot;      wx:for-index=&quot;i&quot;      wx:for-item=&quot;trItem&quot;      wx:key=&quot;i&quot; &gt;      &lt;view class=&#x27;td&#x27;          wx:for=&quot;&#123;&#123;trItem&#125;&#125;&quot;           wx:for-index=&quot;j&quot;        wx:for-item=&quot;tdItem&quot;        wx:key=&quot;j&quot; &gt;        &lt;text&gt;&#123;&#123;tdItem.name&#125;&#125;\\n&#123;&#123;tdItem.teacher&#125;&#125;\\n&#123;&#123;tdItem.room&#125;&#125;&lt;/text&gt;      &lt;/view&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;\n\n我们先来分析一下，数据格式前面已经分析了，这里用的假数据，课程表中没有课的，name，room，teacher当然也应该是空的“”。\n这里用的嵌套渲染，外层通过循环kcb数组，获取到每行trItem的子数组，子层通过循环子数组trItem，获取里面的每个对象tdItem。\n最后通过tdItem对象显示课程的课程表名，教室和教师信息。\n来看看效果：\n\n布局就将到这了。\n这里留下一个思考：部分没有课的内容，如何让其不显示？且保证后面课程不向前串？\n再根据以下提示，写出加上周六周日课程的可滑动视图：\n\n数据：应该怎样添加？\n可滑动视图：参考一下官网文档\n\n123&lt;scroll-view scroll-x=&quot;true&quot; style=&quot;width: ?rpx;&quot; &gt;  可滑动内容&lt;/scroll-view&gt;\n\n\n三、思考答案\n\n1.通过wx-if判断tdItem.name是否为空，将背景颜色设置成白色。\n\n123456789&lt;view class=&#x27;td&#x27;        wx:for=&quot;&#123;&#123;trItem&#125;&#125;&quot;         wx:for-index=&quot;j&quot;      wx:for-item=&quot;tdItem&quot;      wx:key=&quot;j&quot;      style=&#x27;background-color:&#123;&#123;tdItem.name==&quot;&quot;?&quot;white&quot;:&quot;red&quot;&#125;&#125;&#x27;      &gt;      &lt;text&gt;&#123;&#123;tdItem.name&#125;&#125;\\n&#123;&#123;tdItem.teacher&#125;&#125;\\n&#123;&#123;tdItem.room&#125;&#125;&lt;/text&gt;&lt;/view&gt;\n在｛｛｝｝里可以进行简单的逻辑判断计算，这里是通过三元运算计算出该显示的颜色。之后课程表根据课程不同显示不同颜色，会先进行数据处理，再这样设置颜色。这里暂时先理解理解如何控制样式。\n\n2.周六周日数据在每个子数组后面加两个对象，分别是周六和周日。\n\n1234567891011[  [    &#123; name: &quot;高数1&quot;, room: &quot;A231&quot;, teacher: &quot;吴老师&quot; &#125;,    &#123; name: &quot;&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,    &#123; name: &quot;大学英语&quot;, room: &quot;A512&quot;, teacher: &quot;刘老师&quot; &#125;,    &#123; name: &quot;计算机基础&quot;, room: &quot;B322&quot;, teacher: &quot;王老师&quot; &#125;,    &#123; name: &quot;&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,    &#123; name: &quot;周六的课&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;,    &#123; name: &quot;周日的课&quot;, room: &quot;&quot;, teacher: &quot;&quot; &#125;  ],//以下省略\n\n3.可滑动视图 width = 120x7 + 20x6 + 10x2 = 980rpx\n一行7个课程：120x7，课程间距：20x6，左右边界：10x2。\n可滑动视图可能在开发工具上体现不出效果，可以在手机上预览。\n至于想要一屏幕显示5个课程，而周六那不冒出来，需要自己计算出每个课程的宽度，大概是128rpx。先不着急计算这个，之后还需要在课程表左侧加1-2，3-4的课程提示，上方还要加周次选择和头部周一至周日显示。\n\n四、网络请求\n  前面已经把如何显示写好了，但利用的假数据，这里我将提供给大家一个网络接口，大家通过这个接口节可以获取自己的课程表信息了。多说一句，其实开发过程就是这样的，前端人员先通过自己写假数据先用于写页面，最后再通过网络接口连接后台整合项目。这样假数据不依赖网络，既提高了前端开发的速度，也减少了服务器资源。\n\n接口说明：\n\n\n接口地址：https://server-1.isdz.cn/api/kcb.dev.php\n\n\n传输方式：POST\n\n\n请求参数：见下方表格\n\n\n返回参数：\n格式：JSON\n失败返回：Object：{“state”:“error”}\n成功返回：\n\nArray(6): [Array(7),Array(7),…]\n-内层：Array(7)=[Object,Object,…]\n-Object：{“name”: “课程名”,“room”:“教室”,“teacher”: “教师(职称)”,“index”: “”}\n\n\n\n解释说明：失败原因可能是学号密码等参数有错。成功返回的是一个二维数组，外层数组表示1-2，3-4，5-6，7-8，9-10，11-12节课，内层数组表示周一至周日，例 obj = array[0][1] 表示第1-2节课中周二的课程信息，最后通过 obj.name 就可以取出课程名了。\n\n\n\n\n\n\n字段名\n类型\n是否必需\n说明\n\n\n\n\nsno\nString\n是\n个人学号\n\n\npwd\nString\n是\n教务处密码\n\n\nitem\nString\n是\n查询学期，例：“2018-2019-2”\n\n\nweek\nNumber\n是\n查询周次，例：1\n\n\n  看完上面接口是不是还一脸懵逼，没关系，我们现在就开始学习网络请求，在网络请求中使用它，大家就会慢慢理解了。\n  网络请求微信提供给的接口是 wx.request，在使用它之前，我们必须要上微信小程序后台设置：\n\n登录微信小程序后台：https://mp.weixin.qq.com\n点左侧 开发 , 进入后点 开发设置 , 找到下面服务器域名\n配置 request合法域名 为：https://server-1.isdz.cn\n完成后回到开发工具\n点击右上角 详情，找到下面点 域名信息查看是否配置成功\n\n我先将程序写出来，大家先自己理解理解：\n12345678910111213141516171819202122232425262728293031323334//index.jsPage(&#123;  data: &#123;    kcb: []  &#125;,  //生命周期函数：当页面加载的时候执行  onLoad: function()　&#123;    this.refreshKCB();  &#125;,  //请求课程表  refreshKCB: function () &#123;    let that = this;    wx.request(&#123;      url: &#x27;https://server-1.isdz.cn/api/kcb.dev.php&#x27;,      method: &#x27;POST&#x27;,      data: &#123;        sno: &#x27;你的学号&#x27;,        pwd: &#x27;你的教务处密码&#x27;,        item: &#x27;2018-2019-1&#x27;,        week: 1      &#125;,      header: &#123; &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125;,      success:  function (e) &#123;        console.log(e);//查看控制台关于e的格式        that.setData(&#123;          kcb: e.data        &#125;)      &#125;,      fail: function () &#123;        wx.showToast(&#123;title: &#x27;网络开小差了&#x27;,&#125;)      &#125;    &#125;)  &#125;&#125;)\n  这段代码是很简单一个网络请求，最后将返回数据通过setData()设置本地的kcb数组，与此同时，页面就随数据的变更而重新渲染了。\n\n先看总体结构上，我是将课程表请求封装在一个方法里，在页面的启动时，调用该方法。这样写的好处是，方便随时可以复用该请求。因为以后触发课程表请求还有很多方式，比如下拉刷新、周次选择等。本次触发的方式就是页面加载时触发请求。\n再看看请求，前面给出的接口，可能不明白，结合官网关于wx.request的文档（简介里有链接），我们需要给wx.request设置请求地址url，请求方式设置成POST，设置请求的数据data，然后设置的请求的打包类型，这个是我提供的接口需要这样的格式。\n最后有一个请求成功的回调函数success，其中的传入参数e就是请求返回的数据。这个e是被微信小程序底层重新打包过的，我们通过e.data可获取到接口返回的数据。\n\n效果：\n\n五、可选周次查询\n  前面请求查询传输的数据都是写死的，比如week传输的1，查询的第一周的课程信息。我们需要从外面传入变量，动态改变这些值，实现页面可交互，用户可选择。这里介绍一个组件picker：\n  这是一个比较复杂的组件，需要配合js进行使用。\n\n首先查看官方文档，发现内容介绍很多，这说明这个组件功能很强大；\n我们将使用普通选择器：mode = selector，也就是mode的默认值，可以不设置；\n我们将使用其中range、value和bindchange。\nrange：设置可选的全部数据\nvalue：控制和接收选中数据的下标\nbindchange：选中数据的改变触发事件\n\n在课程表前面加一段代码：\n\n12345678&lt;view&gt;    &lt;picker        range=&quot;&#123;&#123;arrayZC&#125;&#125;&quot;        value=&quot;&#123;&#123;indexZC&#125;&#125;&quot;        bindchange=&#x27;zcChange&#x27; &gt;        &lt;view&gt;第 &#123;&#123;arrayZC[indexZC]&#125;&#125; 周&lt;/view&gt;    &lt;/picker&gt;&lt;/view&gt;\n\n在js中加入两个数据：\n\n1234567data: &#123;    kcb: [],    indexZC: 0,    arrayZC: [      1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18    ]&#125;,\n\n在js中加入一个事件：\n\n1234//周次选择zcChange: function (e)&#123;    this.setData(&#123; indexZC: e.detail.value &#125;)&#125;\n\n现在才算是将组件picker实现完毕。这几步缺一不可。现在可以进行周次的选择了，但是选择了周次并不会使下方课程表更新。\n想一想，我们可以在zzChange事件中获取当前选中的周次，那么，我们可以在这个事件里给refreshKCB事件传入一个周次数据，让其请求指定周的课程数据。如何做呢？传参！\n我们需要先将refreshKCB进行改造一下：\n\n1234567891011121314//请求课程表  refreshKCB: function (week) &#123;      //省略一大段代码      //.....      method: &#x27;POST&#x27;,      data: &#123;        sno: &#x27;你的学号&#x27;,        pwd: &#x27;你的密码&#x27;,        item: &#x27;2018-2019-1&#x27;,        week: week      &#125;,      //.....      //省略一大段代码  &#125;\n其中我们传入一个参数周次，week字段传输的值是我们的传入的参数。可能大家现在有点疑惑，week: week是什么鬼？其实，冒号前面的week并不是变量，后面的week才是我们传入的参数。这样虽然名是一样，但底层处理时它能分辨的，加入我们传入的周次是2，那么最后解析成应该是week: 2。\n\n然后再在zcChange事件末尾调用请求课程表：\n\n12345678//周次选择zcChange: function (e)&#123;  this.setData(&#123; indexZC: e.detail.value &#125;)  this.refreshKCB(this.data.arrayZC[this.data.indexZC]);  //还可以写成：  //this.refreshKCB( e.detail.value + 1 );  //解释：利用下标计算周次&#125;,\n\n最后还要改一下onLoad中的refreshKCB，先前写的事件，没有传值是会报错的。\n\n123onLoad: function()　&#123;    this.refreshKCB(this.data.arrayZC[this.data.indexZC]);&#125;\n\n现在可以点击选择周次刷新课程表了！\n\n完结撒花！\n\n六、课程表完善\n  未完，待续\n七、思维发散\n","plink":"https://www.zzboy.cn/Learning/15a3161286d7/"},{"title":"Vue学习-组件","date":"2019-07-24T09:30:00.000Z","date_formatted":{"ll":"Jul 24, 2019","L":"07/24/2019","MM-DD":"07-24"},"updated":"2021-02-27T13:49:32.013Z","content":"1、组件注册\n全局注册：Vue.component(‘component-name’, { /* … */ })，使用时直接使用。\n局部注册：var ComponentA = { /* … */ }，使用前现在components里声明。\n单文件组件：使用import ComponentA from ‘./ComponentA’，再在components里声明。\n2、prop声明\n命名和定义：根据vue代码规范B级建议，prop应该使用驼峰写法，且最好给prop说明数据类型。\n3、父子组件间传值\n父-&gt;子：用prop\n子-&gt;父：在methods内使用this.$emit(event, value)事件触发传出\n4、自定义事件\n事件名：this.$emit(‘kebab-case’)\n自定义v-model：\n12345678910111213141516Vue.component(&#x27;base-checkbox&#x27;, &#123;  model: &#123;    prop: &#x27;checked&#x27;,    event: &#x27;change&#x27;  &#125;,  props: &#123;    checked: Boolean  &#125;,  template: `    &lt;input      type=&quot;checkbox&quot;      v-bind:checked=&quot;checked&quot;      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;    &gt;  `&#125;)\n使用：\n1&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;\n5、在组件上使用原生事件\n1v-on:click.native\n6、组件实践\n根据组件学习，完成了一个组件：添加标签\n组件作用：给一个事物添加标签\n组件使用：在输入框输入内容（限制长度4字符），回车或按钮添加；单击关闭图标删除一个，双击标签同样也可以删除。\n\n\n\n属性\n类型\n默认值\n作用\n\n\n\n\ncloseIcon\nBoolean\n\n标签显示删除图标，不加不显示\n\n\ninitList\nArray\n\n初始化显示标签\n\n\ncolor\nString\nblue\n标签颜色，可选red、green、blue\n\n\nmax\nNumber\n5\n标签个数限制\n\n\n\n\n事件\n返回值\n作用\n\n\n\n\non-change\nArray\n返回当前标签数组\n\n\n导入步骤：\n12345//导入import SettingTags from &#x27;../components/SettingTags.vue&#x27;//示例中引用，这里简化了components: &#123; SettingTags &#125;\n12&lt;setting-tags close-icon @on-changed=&quot;getarr&quot; color=&quot;red&quot; :initList=&quot;list&quot;&gt;&lt;/setting-tags&gt;\n源码：SettingTags.vue\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;template&gt;  &lt;div class&#x3D;&quot;container&quot;&gt;    &lt;input class&#x3D;&quot;input&quot; type&#x3D;&quot;text&quot; maxlength&#x3D;&quot;4&quot;  placeholder&#x3D;&quot;添加标签&quot; v-model&#x3D;&quot;val&quot; @keyup.enter&#x3D;&quot;handEnterClick()&quot; &#x2F;&gt;    &lt;Button class&#x3D;&quot;btn-add&quot; type&#x3D;&quot;primary&quot; @click&#x3D;&quot;handEnterClick()&quot; shape&#x3D;&quot;circle&quot; icon&#x3D;&quot;md-return-left&quot;&gt;&lt;&#x2F;Button&gt;    &lt;br&gt;    &lt;div class&#x3D;&quot;tags&quot;&gt;      &lt;div class&#x3D;&quot;tag-content&quot; @dblclick&#x3D;&quot;handDeleteTag(index)&quot; v-for&#x3D;&quot;(item,index) of lists&quot; :key&#x3D;&quot;index&quot; &gt;        &lt;div :class&#x3D;&quot;[&#39;tag&#39;,color]&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;div&gt;        &lt;Icon type&#x3D;&quot;md-close&quot; v-if&#x3D;&quot;closeIcon&quot; @click&#x3D;&quot;handDeleteTag(index)&quot;&#x2F;&gt;      &lt;&#x2F;div&gt;    &lt;&#x2F;div&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name: &#39;SettingTags&#39;,  props:&#123;    color: &#123;      type: String,      default: &#39;blue&#39;    &#125;,    closeIcon: Boolean,    initList: Array,    max: &#123;      type: Number,      default: 5    &#125;,  &#125;,  data () &#123;    return &#123;      lists: this.initList,      val: &#39;&#39;,      colors: [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]    &#125;  &#125;,  methods: &#123;    handEnterClick () &#123;      if(this.lists.length &#x3D;&#x3D; this.max)&#123;        this.$Message.error(&quot;超过标签个数限制&quot;)        return      &#125;      this.val &#x3D;&#x3D;&#x3D; &#39;&#39; ? &#39;&#39; : this.lists.push(this.val)      this.val &#x3D; &#39;&#39;      this.$emit(&#39;on-changed&#39;, this.lists)    &#125;,    handDeleteTag (index) &#123;      this.lists.splice(index, 1)      this.$emit(&#39;on-changed&#39;, this.lists)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;&lt;style scoped&gt;  .container&#123;    margin: 8px;  &#125;  .input&#123;    width: 100px;    display: inline-block;    height: 28px;    line-height: 1.5;    padding: 2px 7px;    font-size: 12px;    border: 1px solid #dcdee2;    border-radius: 4px;    color: #515a6e;    background-color: #fff;    background-image: none;    position: relative;    cursor: text;    transition: border .2s ease-in-out,background .2s ease-in-out,box-shadow .2s ease-in-out;    outline: #57a3f3;  &#125;  .input:focus&#123;    border-color: #57a3f3;    box-shadow: #57a3f3 0px 0px 4px;  &#125;  .btn-add&#123;    margin-left: 5px;    height: 26px !important;    width: 26px !important;    margin-bottom: 3px;  &#125;  .tags&#123;    color: #515a6e;    display: flex;    margin-top: 2px;    width: 100%;    flex-wrap: wrap;  &#125;  .tag-content&#123;    display: flex;    margin: 4px 2px;  &#125;  .tag&#123;    width: fit-content;    padding: 2px;    font-size: 12px;    line-height: 14px;    border-radius: 3px;  &#125;  .green&#123;    border: 1px solid #b7eb8f;    background: #f6ffed;    color: #52c41a!important;;  &#125;  .blue&#123;    border: 1px solid #91d5ff;    background: #e6f7ff;    color: #1890ff!important;  &#125;  .red&#123;    border: 1px solid #ffa39e;    background: #fff1f0;    color: #f5222d!important;  &#125;  i&#123;    margin-top: -5px;    display: inline-block;    height: fit-content;  &#125;&lt;&#x2F;style&gt;\n","plink":"https://www.zzboy.cn/Learning/ba1793c0983f/"},{"title":"Vue学习-代码规范","date":"2019-07-23T09:30:00.000Z","date_formatted":{"ll":"Jul 23, 2019","L":"07/23/2019","MM-DD":"07-23"},"updated":"2021-02-27T13:49:28.666Z","content":"\n\n组件名：应该以多个单词进行命名；\n\n\n单文件组件的文件名：应该始终是单词大写开头；\n\n\n基础组件名：应用特定样式和约定的基础组件，应该全部以一个特定的前缀开头；\n\n\n单例组件名：只应用于单个活跃实例的组件，应以The前缀命名，以示唯一性；\n\n\n紧密耦合组件名：和父组件紧密耦合的子组件，应以父组件名作为前缀命名；\n\n\n组件名中的单词顺序：应以高级别单词开头，以描述性的修饰词结尾；\n\n\n完整单词的组件名：组件名应该倾向于完整单词而不是缩写；\n\n\n模板中组件名大小写：单文件组件和字符串模板中组件名应该总是PascalCase的，但是在DOM模板中总是kebab-case的；\n\n\nJS/JSX中的组件：应该始终是PascalCase的；\n\n\n组件数据：组件的data必须是一个函数；\n\n\nProp定义：Prop定义应该尽量详细；\n\n\nProp名大小写：在声明prop的时候，其命名始终应该驼峰写法，在模板和JSX中应始终kebab-case；\n\n\n为v-for设置键值：总是用key配合v-for；\n\n\n避免v-if和v-for用在一起：永远不要吧v-if和v-for同时用在一个元素上；\n\n\n为组件样式设置作用域：对于顶级App组件和布局组件中的样式可以是全局的，但其他所有组件都有应该是有作用域的，用scoped特性；\n\n\n私有属性名：使用模块作用保持不允许外部访问的函数的私有性，用$_；\n\n\n自闭合组件：在单文件、字符串、JSX组件中用PascalCase单标记，在DOM模板中用kebab-case双标记；\n\n\n多个特性的元素：多个特性的元素应该多行撰写，每个属性一行；\n\n\n模板中简单的表达式：在组件模板中只应包含简单表达式，复杂表达式应该重构为计算属性和方法；\n\n\n简单的计算属性：应该吧复杂计算属性，分割为尽可能多的简单的属性；\n\n\n带引号的特性值：:style=“{ width: sidebarWidth + ‘px’ }”；\n\n\n指令缩写：(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:) 应该要么都用要么都不用；\n\n\n","plink":"https://www.zzboy.cn/Learning/fb3bb04d6643/"},{"title":"Vue学习-项目搭建","date":"2019-07-22T09:00:00.000Z","date_formatted":{"ll":"Jul 22, 2019","L":"07/22/2019","MM-DD":"07-22"},"updated":"2021-02-27T13:49:25.064Z","content":"计算属性和监听器\nwatch监听器写法：\n1变量名：function( new_value, old_value)&#123;&#125;\ncomputed计算属性写法：\n1新变量名：function()&#123;this.变量&#125;\n区别：watch监听单个变量变化就执行内部逻辑，而computed可以检测一个或同时多个变化，将执行内部逻辑结果返回给此计算名（新变量）。\n一句话：watch(异步场景):单个变量；computed(数据联动):实例内多个变量\nvue-cli、vue-router和vuex\n三种创建项目方法：\n① vue-cli：vue create newProject\n② UI图形界面：vue ui\n③ WebStorm新建项目，也是基于vue-cli的vue-router: 路由管理工具\n组件懒加载：\n1component: () =&gt; import(/* webpackChunkName: &quot;list&quot; */ &#x27;./views/List.vue&#x27;)\n组件跳转：\n1&lt;router-link :to=&quot;&#123;name: &#x27;list&#x27;&#125;&quot;&gt;新闻列表&lt;/router-link&gt;\nvuex：为vue开发提供组件状态集中管理模式\n12345678910import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123;      state: &#123;            lists: []      &#125;,      mutations: &#123;&#125;,      actions: &#123;&#125;&#125;)\n其他页面使用vuex：\n12import store from ‘@/store.js’methods: &#123; store.commit (mutations方法, 传参)&#125;","plink":"https://www.zzboy.cn/Learning/0942d62fb0f3/"},{"title":"Vue学习-组件data和render","date":"2019-07-19T09:00:00.000Z","date_formatted":{"ll":"Jul 19, 2019","L":"07/19/2019","MM-DD":"07-19"},"updated":"2021-02-27T13:49:21.322Z","content":"Vue组件data\n在之前我使用vue.js时，实例Vue中的data是直接赋值一个对象的。但是，在看过公司项目的Vue项目时，发现data是用函数返回的。\n12345data: function () &#123;  return &#123;    count: 0  &#125;&#125;\n查看学习官方文档后，理解了在组件使用中，组件的data必须是一个函数。因为在使用组件时，一个页面可能有多个组件同时使用，改变组件Vue实例data，时，其他组件data会同时受到影响。但通过data使用匿名函数，可以保证页面内每一个实例是独立的data。\nVue render\nVue在绝大多数情况下是使用 template，然而在某些特定的场景中，我们需要JavaScript创建一些简单html。比如公司项目的表格最后一列编辑选项按钮，是用一个div突出固定显示在表格右侧的。render基本用法：\n12345render: function (createElement) &#123;  return createElement(&#x27;div&#x27;, [\tcreateElement (&#x27;Button&#x27;, &#123;props: &#123; &#125;, style: &#123; &#125;, on: &#123; &#125;&#125;&#125;, &#x27;文字&#x27;),])&#125;\n一般render创建的html不是静态的，需要在传入一个参数对象，对新建的html进行设计。\n","plink":"https://www.zzboy.cn/Learning/8d0cb17b0653/"},{"title":"canvas学习","date":"2019-07-18T06:33:00.000Z","date_formatted":{"ll":"Jul 18, 2019","L":"07/18/2019","MM-DD":"07-18"},"updated":"2021-02-27T13:49:10.229Z","content":"canvas是HTML5新出的标记，是可以通过api绘制图形。使用之前必须的创建一块可用的canvas画布，之后的操作都是基于这画布上进行操作绘制。canvas是基于状态绘图的，先设定状态，通过方法执行。\n\n获取画布：\n\n12let canvas = document.getElementById(&quot;canvas&quot;);let context = canvas.getContext(&quot;2d&quot;);\n可通过canvas.width和canvas.height设置画布宽高。\n\n其他方法\n\n1234567891011121314151617moveTo() //将笔触移至指定点beginPath() //起始一条路径closePath() //闭合至起始点lineTo() //新建一个起点arc() //绘制一条曲线stroke() //绘制已定义路径fill() //填充当前绘图fillStyle //设置填充样式strokeStyle //设置笔触样式shadowColor //设置阴影颜色shadowBlur //设置阴影模糊级别clearRect() //清除指定像素（动画去重影）fillText() //设置文本font //设置文本字体属性textAlign //设置文本对齐方式strokeText() //绘制文本drawImage() //绘制图象\n学习成果\n\n源码\nhttps://github.com/Patrick-Jun/canvas-Clock\n","plink":"https://www.zzboy.cn/Learning/973f37045c68/"},{"title":"JavaScript-事件","date":"2019-07-18T03:33:00.000Z","date_formatted":{"ll":"Jul 18, 2019","L":"07/18/2019","MM-DD":"07-18"},"updated":"2021-02-27T13:49:13.794Z","content":"事件流\n事件流：描述的是从页面中接收事件的顺序。其中有两种概览，分别是事件冒泡流和事件捕获流。\n事件冒泡流，是IE开发团队提出的，现在浏览器都支持冒泡流事件。冒泡流事件是事件从具体的的元素接收，然后逐级上传到较为不具体的节点（button-&gt;div-&gt;body-&gt;html-&gt;document）\n事件捕获流，是NC团队提出的，思想是最先由不具体节点接收事件，然后逐级下传到具体元素，恰好和冒泡流相对（document-&gt;html-&gt;body-&gt;div-&gt;button）。\n事件处理\n事件是用户或浏览器执行的动作，以on开头，有如onclick、onload、onmouceover等。\n事件处理分为5种情况：HTML事件处理、DOM0级事件、DOM2级事件、IE事件和跨浏览器事件。\nHTML事件是直接绑定某个元素上的，通过在元素属性上直接加事件处理名称。DOM0级是通过JavaScript获取节点，在通过节点属性判断是否做相应动作。DOM2级是通过节点addEventListener或removeEventListener给节点绑定或移除事件。IE事件和DOM2类似，通过attachEvent()和 detachEvent()给节点绑定和移除事件。跨浏览器事件是通过EventUtil对象的addHandler()方法绑定时间处理。\n事件对象\n兼容 DOM 的浏览器会将一个 event对象传入到事件处理程序中。event对象含bubbles、currentTarget、detail、target、type等常用属性和方法。IE中的对象事件可以通过window.event获取。而跨浏览器的事件对象可以通过EventUtil对象的getEvent()方法获取。\n事件类型\n\nUI事件：DOMActivate、load、unload、abort、error、select、resize、scroll；\n焦点事件：blur、DOMFocusIn、DOMFocusOut、focus、focusin、focusout；\n鼠标事件：click、dblclick、mousedown、mouseenter、mouseleave、mousemove、mouseout、mouseover、mouseup；\n键盘事件：keydown、keypress、keyup；\n设备事件：orientationchange、MozOrientation、deviceorientation、devicemotion；\n另外还有：复合事件、变动事件、触摸和手势事件。\n\n事件委托\n对“事件处理程序过多”问题的解决方案就是事件委托。事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。通常在DOM 树中尽量最高的层次上添加一个事件处理程序，通过传入event对象，有event对象的target来区别不同事件响应。\n","plink":"https://www.zzboy.cn/Learning/1444d05a63dc/"},{"title":"JavaScript获取URL参数","date":"2019-07-17T05:53:00.000Z","date_formatted":{"ll":"Jul 17, 2019","L":"07/17/2019","MM-DD":"07-17"},"updated":"2021-02-27T13:49:06.821Z","content":"获取单个参数\n12345678910111213/** * 根据键获取url单个参数值 * @param  String name 键 * @return String       */function getUrlParam(name) &#123;  //建立正则匹配规则\tlet reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);  //从？开始匹配\tlet r = window.location.search.substr(1).match(reg);  //解码返回\tif (r != null) return unescape(r[2]); return null;&#125;\n获取全部参数\n12345678910111213141516171819202122232425/** * 获取当前页Url所有参数 * @return Object */function getUrlParams()&#123; //取得查询字符串并去掉开头的问号 let qs = (location.search.length &gt; 0 ? location.search.substring(1) : &quot;&quot;), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split(&quot;&amp;&quot;) : [], item = null,name = null,value = null, len = items.length; //逐个将每一项添加到 args 对象中 for (let i=0; i &lt; len; i++)&#123;   item = items[i].split(&quot;=&quot;);   name = decodeURIComponent(item[0]);   value = decodeURIComponent(item[1]);   if (name.length) &#123;     args[name] = value;   &#125; &#125; return args;&#125;\n","plink":"https://www.zzboy.cn/Learning/c23845560169/"},{"title":"JavaScript-对象创建","date":"2019-07-17T03:33:00.000Z","date_formatted":{"ll":"Jul 17, 2019","L":"07/17/2019","MM-DD":"07-17"},"updated":"2021-02-27T13:49:00.062Z","content":"工厂模式\n123456789function createPerson(name, age)&#123;      var o = new Object();      o.name = name;      o.age = age;      o.sayName = function()&#123;            alert(this.name);      &#125;;      return o; &#125;\n通过函数createPerson可以无限次的创建新的对象，工厂模式解决了创建多个相似对象的问题，但没有解决对象的标识问题（怎么知道对象的类型）。\n构造函数模式\n12345678function Person(name, age)&#123;      this.name = name;      this.age = age;      this.sayName = function()&#123;            alert(this.name);      &#125;; &#125; var person2 = new Person(&quot;Tom&quot;, 27);\n构造函数模式没有显式地创建对象，而直接将方法和属性直接赋值给了this，且没有返回语句。在使用构造函数方法创建对象时，是用过new关键字使用的。构造函数模式解决了工厂模式无法标识对象的问题，但也存在一个问题就是每个方法都是实例上重新创建的，即没有实现方法的复用。其中一种解决方法是将对象方法在全局声明，在构造函数中引用。另一种解决方法是原型模式。\n原型模式\n1234567function Person()&#123; &#125;     Person.prototype.name = &quot;Tom&quot;;     Person.prototype.age = 29;     Person.prototype.sayName = function()&#123;          alert(this.name);     &#125;; var person1 = new Person();\n每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，即可以让所有对象实例共享它所包含的属性和方法。\n","plink":"https://www.zzboy.cn/Learning/308102780ef2/"},{"title":"JavaScript-数据操作","date":"2019-07-17T03:33:00.000Z","date_formatted":{"ll":"Jul 17, 2019","L":"07/17/2019","MM-DD":"07-17"},"updated":"2021-02-27T13:49:03.282Z","content":"类型检测\n\ntypeof 检测数据类型\ninstanceof 检测是哪个对象的实例\nArray.isArray(value) 检测数组\n\n数组操作\n\njoin() 重现方法toString() 使输出分隔字符替换为传入参数\npush() 末尾加项，return length\npop() 末尾移除一项，return 移除项\nshift() 首部移除一项，return 移除项\n堆栈实现：push() + pop()\n队列实现：push() + shift()\nreverse() 反序\nsort() 按字符类型排序，可传入自定义函数实现升序降序排列\nslice(start,[end+1])截取数组\nsplice(start,n,value…) 插入值\nevery(f(item,index,array){}) 均满足返回true\nsome(f(item,index,array){}) 存在一项满足就返回true\nfitter(f(item,index,array){}) 返回数组满足项\nforeach(f) 迭代\nreduce(f(pre,cur,index,array){}) 函数f返回值传入下一项操作\nreduceRight(f) 反方向reduce()\n\n字符串操作\n\nstr.charAt(n) 取字符\nstr.concat() 连接字符串（+）\nstr.slice(start,[edn+1]) 区间截取\nstr.substring(start,[end+1])等同于slice\nstr.substr(start,n) 从start开始截取n长\nstr.split() 分割字符串为数组\n\nMath\n\nMath.ceil() 向上舍入\nMath.floor() 向下舍入\nMath.round() 四舍五入\nMath.random() 大于等于0，小于1\n从某个整数范围任选值\n值 = Math.floor(Math.random()*总数 + 起始值)\n\n","plink":"https://www.zzboy.cn/Learning/dfc654fe685e/"},{"title":"JavaScript函数问题","date":"2019-07-16T03:33:00.000Z","date_formatted":{"ll":"Jul 16, 2019","L":"07/16/2019","MM-DD":"07-16"},"updated":"2021-02-27T13:48:56.862Z","content":"Function类型创建\n  以下三种方法创建的函数作用相同，在使用上几乎也没有区别。区别在最后一章: 函数声明与函数表达式 。\n使用函数声明\n123function sum (num1, num2) &#123; return num1 + num2;&#125;\n使用函数表达式\n123var sum = function(num1, num2)&#123; return num1 + num2;&#125;;\nFunction构造函数(不推荐)\n1var sum = new Function(&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);\n没有重载\n  将函数名理解为指针，就很容易理解为什么没有重载了。再次定义函数将覆盖之前定义的函数。\n1234567function addSomeNumber(num)&#123;  return num + 100;&#125;function addSomeNumber(num) &#123;  return num + 200;&#125;var result = addSomeNumber(100); //300\n等同于（将函数名理解为指针）：\n1234567var addSomeNumber = function (num)&#123; return num + 100;&#125;;addSomeNumber = function (num) &#123; return num + 200;&#125;;var result = addSomeNumber(100); //300\n函数声明与函数表达式\n先看例子：\n12345678910// 例1：正常执行alert(sum(1,1));function sum(num1, num2)&#123; return num1 + num2;&#125;// 例2：报错 unexpected identifieralert(sum2(1,1));var sum2 = function(num1, num2)&#123; return num1 + num2;&#125;;\n函数声明和函数表达式定义后的作用无区别，但解析器对函数声明和函数表达式并非一视同仁。解析器会先读取所有函数声明，并使这些函数在执行\n任何代码之前可用。至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释。例2中如果把var sum2表达式放在前面则就不会报错了。\n","plink":"https://www.zzboy.cn/Learning/95bd22fa5cef/"},{"title":"ES6学习-数组","date":"2019-07-15T09:00:00.000Z","date_formatted":{"ll":"Jul 15, 2019","L":"07/15/2019","MM-DD":"07-15"},"updated":"2021-02-27T13:48:50.306Z","content":"数组创建\nArray.of()\n将所有参数转化生成数组。\n123Array.of(1, 2, 3, 4);  // [1,2,3,4]Array.of(1, &#x27;2&#x27;, true);  // [1,&#x27;2&#x27;,true]Array.of(); // []\nArray.from()\n将可迭代的类数组对象转为数组。\n1234Array.from([1, 2]; // [1, 2]Array.from([1, , 3]); // [1, undefined, 3]Array.from([1, 2, 3], (n) =&gt; n * 2); // [2, 4, 6]Array.from(&quot;abc&quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n查找\nfind()\n查找数组中符合条件的元素，返回第一个元素。\n12let arr = [1, 2, 1, 3];arr.find(item =&gt; item &gt; 2); //3\nfindIndex()\n查找数组中符合条件的元素索引，返回第一个元素索引。\n12let arr = [1, 2, 1, 3];arr.findIndex(item =&gt; item = 1); //0\n遍历\nentries()\n123let entries = [&#x27;a&#x27;, &#x27;b&#x27;].entries();console.log(entries.next().value); // [0, &quot;a&quot;]console.log(entries.next().value); // [1, &quot;b&quot;]\nkeys()\n1[&#x27;a&#x27;, &#x27;b&#x27;].keys(); // [0, 1]\nvalues()\n1[&#x27;a&#x27;, &#x27;b&#x27;].values(); // [&quot;a&quot;, &quot;b&quot;]\n填充\nfill()\n将指定索引范围内数组元素替换为单个指定值\n\n参数1：用来填充的值\n参数2：被填充的起始索引\n参数3(可选)：被填充的结束索引，默认为数组末尾\n\n1234let arr = [1, 2, 3, 4];//fill(value,start[,end=length-1])arr.fill(9,1,2); // [1,9,3,4]arr.fill(8,1);  //[1,8,8,8]\ncopyWithin()\n将取指定范围的数据覆盖在从指定位置的数据上\n\n参数1：被修改的起始索引\n参数2：被用来覆盖的数据的起始索引\n参数3(可选)：被用来覆盖的数据的结束索引，默认为数组末尾\n\n123456789//将 3 取出来覆盖 索引1处的值arr = [1,2,3,4,5];arr.copyWithin(1,2,3); //[ 1, 3, 3, 4, 5 ]//将3,4,5取出来覆盖索引 1,2,3处的值let arr = [1,2,3,4,5];arr.copyWithin(1,2,5); //[ 1, 3, 4, 5, 5 ]//默认数组末尾 效果同上一例arr = [1,2,3,4,5];arr.copyWithin(1,2); //[ 1, 3, 4, 5, 5 ]\n其它\nincludes()\n数组是否包含指定值\n\n参数1：包含的指定值\n参数2：可选，搜索的起始索引，默认为0\n\n123[1, 2, 3].includes(1);    // true[1, 2, 3].includes(1, 2); // false[1, NaN, 3].includes(NaN); // true\nflat()\n嵌套数组转低维数组\n123456// 基本用法[1 ,[2, 3]].flat(); // [1, 2, 3]// 指定转换的嵌套层数[1, [2, [3, [4, 5]]]].flat(2); // [1, 2, 3, [4, 5]]// 不管嵌套多少层[1, [2, [3, [4, 5]]]].flat(Infinity); // [1, 2, 3, 4, 5]\nflatMap()\n先对数组中每个元素进行了的处理，再对数组执行 flat() 方法\n\n参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组\n参数2：指定遍历函数中 this 的指向\n\n1[1, 2, 3].flatMap(n =&gt; [n * 2]); // [2, 4, 6]\n扩展运算符…\n1234567let arr = [1, 2];//复制数组用法arr1 = [...arr]; // [1,2]//合并数组用法arr2 = [...arr,...arr1]; // [1,2,1,2]//嵌套数组arr2 = [...arr,arr1]; // [ 1, 2, [ 1, 2 ] ]\n","plink":"https://www.zzboy.cn/Learning/4a5a66b21e29/"},{"title":"ES6学习-Symbol类型、字符串、Maps与Objects","date":"2019-07-15T02:41:00.000Z","date_formatted":{"ll":"Jul 15, 2019","L":"07/15/2019","MM-DD":"07-15"},"updated":"2021-02-27T13:48:53.462Z","content":"Symbol数据类型\nES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。独一无二的意思就是即使两个传入的key是一样，但Symbol(“abc”)是不等于Symbol(“abc”)的。\n12345let sy1 = Symbol(&quot;abc&quot;);let sy2 = Symbol(&quot;abc&quot;);console.log(sy1); //Symbol(abc)console.log(sy2); //Symbol(abc)console.log(sy1 == sy2); //false\n字符串\n  以前判断字符串中是否含子串是通过indexOf方法，ES6新增了几种：\n\nbool includes(Sring); 判断是否找到参数字符串；\nbool startsWith(String,[int]); 判断参数字符串是否在原字符串的头部；\nbool endsWith(String,[int]); 判断参数字符串是否在原字符串的尾部；\nString repeat(int); 将字符串重复指定次数返回；\nString padStart(int, String); 用参数字符串从原串的前面补全直至参数Int个数；\nString padEnd(int, String); 用参数字符串从原串的后面补全直至参数Int个数；\n模板字符串 `字符串内容或表达式` ：可以在字符串中加入变量或者表达式；\ni18n `字符串${变量}` ：自动将内容转国际化语言；\n\nMaps和Objects\n\nObject的键只能是字符串或者Symbols，但Map键可以是任意值；\nMap中的键值是有序的（FIFO先进先出原则），而对象中的键是无序的；\nMap中的键值对个数可通过size属性获取，而对象的键值对个数只能通过遍历计算；\n\n","plink":"https://www.zzboy.cn/Learning/7d5b1eb5af6f/"},{"title":"ES6学习-变量常量的声明与解构赋值","date":"2019-07-08T03:05:00.000Z","date_formatted":{"ll":"Jul 8, 2019","L":"07/08/2019","MM-DD":"07-08"},"updated":"2021-02-27T13:48:43.345Z","content":"变量声明：let\n基本用法\n1let a = 123;  //let声明\n特点\n\n\n块内有效\n123456&#123;let a = 0;  // a块内有效：只能在该代码块内使用var b = 1;  // b全局有效：声明后可在任意地方使用&#125;a  // ReferenceError: a is not definedb  // 1\n\n\n不能重复声明\n123456let a = 1;  //let只能声明一次let a = 2;var b = 3;  //var可以多次声明var b = 4;a  // Identifier &#x27;a&#x27; has already been declaredb  // 4\n\n\n不存在变量提升\n12345console.log(a);  //ReferenceError: a is not definedlet a = 1;console.log(b);  //undefinedvar b = 2;\n\n变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined。\n变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。\n\n\n\n顶层对象\n1234var a = 1;window.a // 1let b = 1;window.b // undefined\n\nvar和function的全局声明会自动绑定到window或global对象，而let和const不会。\n\n\n\nlet与var案例\nlet很适合做循环变量\n123456789101112for (var i = 0; i &lt; 10; i++) &#123;  setTimeout(function()&#123;    console.log(i);  &#125;)&#125;// 输出十个 10for (let j = 0; j &lt; 10; j++) &#123;  setTimeout(function()&#123;    console.log(j);  &#125;)&#125;// 输出 0123456789\n\n\n变量 i 是用 var 声明的，在全局范围内有效，所以全局中只有一个变量 i, 每次循环时，setTimeout 定时器里面的 i 指的是全局变量 i ，而循环里的十个 setTimeout 是在循环结束后才执行，所以此时的 i 都是 10。\n\n\n变量 j 是用 let 声明的，当前的 j 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出12345。（若每次循环的变量 j 都是重新声明的，如何知道前一个循环的值？这是因为 JavaScript 引擎内部会记住前一个循环的值）。\n\n\n常量声明：const\n基本用法\n12const PI = &quot;3.1415926&quot;;const DIR;  // SyntaxError: Missing initializer in const declaration\n  const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。\n原理与注意事项\n  const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。对于简单类型（数值 number、字符串 string 、布尔值 boolean）,值就保存在变量指向的那个内存地址。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。\n解构赋值\n什么是解构赋值？\n  解构赋值是对赋值运算符的扩展,是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。\n类似数组写法的解构（Array）\n123456789101112131415161718192021222324252627282930313233let [a, b, c] = [1, 2, 3];  //基础用法// a = 1// b = 2// c = 3let [a, [[b], c]] = [1, [[2], 3]];  //嵌套解构// a = 1// b = 2// c = 3let [a, , b] = [1, 2, 3];  //忽略解构// a = 1// b = 3let [a = 1, b] = [];  //不完全解构// a = 1, b = undefinedlet [a, ...b] = [1, 2, 3]; //剩余运算符“...”：将余下的数据以数组形式全赋值给b//a = 1//b = [2, 3]let [a, b, c, d, e] = &#x27;hello&#x27;;//在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。// a = &#x27;h&#x27;// b = &#x27;e&#x27;// c = &#x27;l&#x27;// d = &#x27;l&#x27;// e = &#x27;o&#x27;let [a = 2] = [undefined]; //默认值解构// a = 2let [a = 3, b = a] = [];     // a = 3, b = 3let [a = 3, b = a] = [1];    // a = 1, b = 1let [a = 3, b = a] = [1, 2]; // a = 1, b = 2\n类似对象写法的解构（Object）\n12345678910111213141516171819202122232425262728293031323334//1.基本用法：按照属性名进行匹配赋值let &#123; foo, bar &#125; = &#123; bar: &#x27;bbb&#x27;, foo: &#x27;aaa&#x27; &#125;;// foo = &#x27;aaa&#x27;// bar = &#x27;bbb&#x27;let &#123; baz : foo &#125; = &#123; baz : &#x27;ddd&#x27; &#125;; //指定属性名匹配赋值// foo = &#x27;ddd&#x27;//2.可嵌套忽略（较少使用）let obj = &#123;p: [&#x27;hello&#x27;, &#123;y: &#x27;world&#x27;&#125;] &#125;;let &#123;p: [x, &#123; y &#125;] &#125; = obj;// x = &#x27;hello&#x27;// y = &#x27;world&#x27;let obj = &#123;p: [&#x27;hello&#x27;, &#123;y: &#x27;world&#x27;&#125;] &#125;;let &#123;p: [x, &#123;  &#125;] &#125; = obj;// x = &#x27;hello&#x27;//3.不完全解构（较少使用）let obj = &#123;p: [&#123;y: &#x27;world&#x27;&#125;] &#125;;let &#123;p: [&#123; y &#125;, x ] &#125; = obj;// x = undefined// y = &#x27;world&#x27;//4.剩余运算符：将余下的数据以对象形式赋值给restlet &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;;// a = 10// b = 20// rest = &#123;c: 30, d: 40&#125;//5.默认值解构let &#123;a = 10, b = 5&#125; = &#123;a: 3&#125;;// a = 3; b = 5;let &#123;a: aa = 10, b: bb = 5&#125; = &#123;a: 3&#125;;// aa = 3; bb = 5;\n写在最后\n  今天是实习第一天，上午就填完一些材料，就让自己学学。经理往群里发了java学习的资料，而我作为一个“前端开发实习生”，没有资料。那我就自己在菜鸟上看了看ES6吧\n","plink":"https://www.zzboy.cn/Learning/90da1569d69e/"},{"title":"RN学习-实习","date":"2019-07-08T03:05:00.000Z","date_formatted":{"ll":"Jul 8, 2019","L":"07/08/2019","MM-DD":"07-08"},"updated":"2021-02-27T13:48:46.364Z","content":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; Text, View &#125; from &#x27;react-native&#x27;;/** * 1.组件与其props定义 * @extends Component */class Greeting extends Component &#123;  render() &#123;    return (      &lt;View style=&#123;&#123;alignItems: &#x27;center&#x27;, marginTop: 50&#125;&#125;&gt;        &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt;      &lt;/View&gt;    );  &#125;&#125;//使用export default class LotsOfGreetings extends Component &#123;  render() &#123;    return (      &lt;View style=&#123;&#123;alignItems: &#x27;center&#x27;&#125;&#125;&gt;        &lt;Greeting name=&#x27;Rexxar&#x27; /&gt;        &lt;Greeting name=&#x27;Jaina&#x27; /&gt;        &lt;Greeting name=&#x27;Valeera&#x27; /&gt;      &lt;/View&gt;    );  &#125;&#125;/** * 2.组件state使用 * @extends Component */// 一切界面变化都是状态state变化// state的修改必须通过setState()方法//   this.state.likes = 100; // 这样的直接赋值修改无效！//   setState 是一个 merge 合并操作，只修改指定属性，不影响其他属性//   setState 是异步操作，修改不会马上生效class Blink extends Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; isShowingText: true &#125;;    setInterval(() =&gt; &#123;      this.setState(previousState =&gt; &#123;        return &#123; isShowingText: !previousState.isShowingText &#125;;      &#125;);    &#125;, 1000);  &#125;  render() &#123;    if (!this.state.isShowingText) &#123;      return null;    &#125;    return (      &lt;Text&gt;&#123;this.props.text&#125;&lt;/Text&gt;    );  &#125;&#125;//使用export default class BlinkApp extends Component &#123;  render() &#123;    return (      &lt;View&gt;        &lt;Blink text=&#x27;I love to blink&#x27; /&gt;      &lt;/View&gt;    );  &#125;&#125;/** * 3.样式的使用  []分别使用 * @type &#123;Object&#125; */export default class LotsOfStyles extends Component &#123;  render() &#123;    return (      &lt;View&gt;        &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt;        &lt;Text style=&#123;styles.bigBlue&#125;&gt;just bigBlue&lt;/Text&gt;        &lt;Text style=&#123;[styles.bigBlue, styles.red]&#125;&gt;bigBlue, then red&lt;/Text&gt;        &lt;Text style=&#123;[styles.red, styles.bigBlue]&#125;&gt;red, then bigBlue&lt;/Text&gt;      &lt;/View&gt;    );  &#125;&#125;//样式定义const styles = StyleSheet.create(&#123;  bigBlue: &#123;    color: &#x27;blue&#x27;,    fontWeight: &#x27;bold&#x27;,    fontSize: 30,  &#125;,  red: &#123;    color: &#x27;red&#x27;,  &#125;,&#125;);\n","plink":"https://www.zzboy.cn/Learning/2a8bd95062b1/"},{"title":"微信小程序快速上手教程-2","date":"2019-06-27T03:49:00.000Z","date_formatted":{"ll":"Jun 27, 2019","L":"06/27/2019","MM-DD":"06-27"},"updated":"2021-02-27T15:17:06.860Z","content":"  第二节内容主要为微信小程序中的基本事件处理以及常用API使用。\n本节学习内容主要有：\n\n点击事件\nwx.showToast()\n列表渲染、条件渲染\nsetData()\nwx.showModal()\nwx.setClipboardData()\nweui框架简单学习\n\n \n教程（二）-事件处理及API学习\n一、本期简介\n  上一期教程为大家打开了微信小程序入坑的大门，主要停留在原生视图层（wxml，wxss），这一期我们开始学习小程序中的事件处理，以及微信提供的几个常用API学习，也就是js了。最后再简单讲讲如何使用小程序UI框架之weui。\n  学习事件处理的过程中，我会将视图层的高级用法一并讲了：列表渲染和条件渲染；\n  对于这几个基础API的学习，我都会讲如何去读官方文档，授人以渔嘛，以后自己学其他的框架或者什么技术，尽量去读官方文档，官方文档才是最准确的。\n二、点击事件+wx.showToast()\n\n举栗子\n直接看点击事件代码。该程序作用点击按钮显示一个Toast提示。\n\n1234&lt;!--index.wxml--&gt;&lt;view&gt;  &lt;button bindtap=&#x27;show&#x27;&gt;添加&lt;/button&gt;&lt;/view&gt;\n1234/**index.wxss**/button &#123;  width: 50%;&#125;\n123456789101112//index.jsPage(&#123;  data: &#123;  &#125;,  //事件处理函数  show: function() &#123;    wx.showToast(&#123;      title: &#x27;按钮被点击了&#x27;,    &#125;)  &#125;&#125;)\n\n\n效果 ：\n\n\n\n代码解析\n\n\n页面很简单，就一个按钮，宽度是页面的50%。通过 bindtap 绑定了一个点击事件 show 。\n\n\n由代码可见，事件的定义的格式是 事件名：function(参数){ 事件处理 }\n\n\nwx.showToast()：显示消息提示框。\n  官方文档地址：https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showToast.html\n  打开官方文档，我们左侧可以看见wx.showToast属于界面交互API。右侧则是对该API的详细介绍：作用、参数。showToast的参数是一个对象，还记得我们上一期提过的对象怎么写吗？就是一对大括号，内写一对对的属性和值。如本栗子 { title: ‘按钮被点击了’ } 。\n  再看看下面就是这个参数对象规定了有哪些详细的属性，以及这些属性的类型、默认值、是不是必须得以及作用。其中title属性是必须的，而且title的类型是字符串，作用就是用于显示的内容。本栗子也只用了这一个必需属性。其他没用到的属性有些是有默认值的，如icon属性，是显示提示的图标，默认是显示success图标（√），提示显示的时长duration是1500毫秒。本栗子可以改成 { title: ‘按钮被点击了’ , duration: 2000} ，这样提示信息就回显示2秒。\n\n文档下方还有其他介绍，如参数属性的特定值、实例代码和注意事项。实例代码就是用来复制粘贴的haha^-^\n\n\n\n注意 ：官方文档是用来参考的，一些参数不用特意去记，很多参数平时都用不到，只要记住有这么个API可用，当然记不住也没关系，用度娘问问就是了。一些常用的API多用几次自然能记点点用法。\n\n\n\n\n扩展\n长按事件：bindlongtap\n\n\n三、列表渲染、条件渲染\n\n上栗子\n\n1234567891011121314151617181920212223&lt;!--index.wxml--&gt;&lt;view&gt;  &lt;!-- 列表渲染示例 --&gt;  &lt;view class=&#x27;h1&#x27;&gt;列表渲染&lt;/view&gt;  &lt;view wx:for=&quot;&#123;&#123;name&#125;&#125;&quot; wx:for-index=&quot;i&quot; wx:for-item=&quot;item&quot; wx:key=&quot;i&quot;&gt;    这是第&#123;&#123;i&#125;&#125;个名字：&lt;text&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt;  &lt;/view&gt;  &lt;!-- 嵌套渲染示例 --&gt;  &lt;view class=&#x27;h1&#x27;&gt;列表嵌套渲染&lt;/view&gt;  &lt;view wx:for=&quot;&#123;&#123;user&#125;&#125;&quot; wx:for-index=&quot;i&quot; wx:for-item=&quot;item&quot; wx:key=&quot;i&quot;&gt;    &lt;view class=&#x27;h2&#x27;&gt;这是第 &#123;&#123;i&#125;&#125; 个数组&lt;/view&gt;    &lt;view wx:for=&quot;&#123;&#123;item&#125;&#125;&quot; wx:for-index=&quot;j&quot; wx:for-item=&quot;inItem&quot; wx:key=&quot;j&quot;&gt;      &lt;view class=&#x27;inItem&#x27;&gt;内层第 &#123;&#123;j&#125;&#125; 个名字：&lt;text&gt;&#123;&#123;inItem&#125;&#125;&lt;/text&gt;&lt;/view&gt;    &lt;/view&gt;  &lt;/view&gt;  &lt;!-- 条件渲染示例 --&gt;  &lt;view class=&#x27;h1&#x27;&gt;条件渲染&lt;/view&gt;  &lt;view wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;1111111111111111&lt;/view&gt;  &lt;view wx:if=&quot;&#123;&#123;false&#125;&#125;&quot;&gt;222222222222222&lt;/view&gt;  &lt;view hidden=&quot;&#123;&#123;true&#125;&#125;&quot;&gt;333333333333333&lt;/view&gt;  &lt;view hidden=&quot;&#123;&#123;false&#125;&#125;&quot;&gt;444444444444444&lt;/view&gt;&lt;/view&gt;\n1234567891011121314//index.jsPage(&#123;  data: &#123;    //列表渲染演示数据    name: [&quot;张三&quot;, &quot;汤姆&quot;, &quot;程咬金&quot;],    //嵌套渲染演示数据    user: [      [&quot;张三1&quot;, &quot;汤姆1&quot;, &quot;程咬金1&quot;],      [&quot;张三2&quot;, &quot;汤姆2&quot;, &quot;程咬金2&quot;],      [&quot;张三3&quot;, &quot;汤姆3&quot;, &quot;程咬金3&quot;]    ],  &#125;,&#125;)\n1234567891011121314151617/**index.wxss**/.h1&#123;  font-size: 48rpx;  line-height: 80rpx;  font-weight: 700;&#125;.h2&#123;  font-size: 38rpx;  line-height: 60rpx;  font-weight: 600;&#125;view text&#123;  color: red;&#125;.inItem&#123;  margin-left: 50rpx;&#125;\n\n\n效果 ：\n\n\n\n代码解析\n\n首先打开列表渲染官方文档：https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/list.html\n列表渲染可理解为对数组的遍历（可说成是for循环），将数据遍历到视图代码里并有视图渲染出来。wx:for指定要遍历的数据，wx:for-index用于指定每次遍历的下标（可以理解为for(i=0;i&lt;10;i++){num[i]}中的 i ），wx:for-item用于描述每次遍历出来的变量（可理解 num[i] ），如果不指定，分别的默认值是index和item。最后wx:key是用于标识每条渲染结果的不同，其实可以不用指定，但运行时程序会有警告而不报错，一般可指定为index或者item。\n列表渲染的范围，是wx:for所在的容器及其内部，将本身容器及其内部元素复制。本栗子中&lt;view wx:for=“”…渲染出的结果应该是：\n\n123456789&lt;view  wx:key=&quot;0&quot;&gt;    这是第0个名字：&lt;text&gt;张三&lt;/text&gt;&lt;/view&gt;&lt;view  wx:key=&quot;1&quot;&gt;    这是第1个名字：&lt;text&gt;汤姆&lt;/text&gt;&lt;/view&gt;&lt;view  wx:key=&quot;2&quot;&gt;    这是第2个名字：&lt;text&gt;程咬金&lt;/text&gt;&lt;/view&gt;\n\n理解了列表渲染，说它for循环，再看看嵌套渲染，那么这就是多重循环了。自己理解代码，最终的渲染结果应该是：\n\n123456789101112131415161718192021222324252627282930313233343536&lt;view wx:key=&quot;0&quot;&gt;  &lt;view class=&#x27;h2&#x27;&gt;这是第 0 个数组&lt;/view&gt;  &lt;view wx:key=&quot;0&quot;&gt;    &lt;view class=&#x27;inItem&#x27;&gt;内层第 0 个名字：&lt;text&gt;张三1&lt;/text&gt;&lt;/view&gt;  &lt;/view&gt;  &lt;view wx:key=&quot;1&quot;&gt;    &lt;view class=&#x27;inItem&#x27;&gt;内层第 1 个名字：&lt;text&gt;汤姆1&lt;/text&gt;&lt;/view&gt;  &lt;/view&gt;  &lt;view wx:key=&quot;2&quot;&gt;    &lt;view class=&#x27;inItem&#x27;&gt;内层第 2 个名字：&lt;text&gt;程咬金1&lt;/text&gt;&lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;&lt;view wx:key=&quot;1&quot;&gt;  &lt;view class=&#x27;h2&#x27;&gt;这是第 1 个数组&lt;/view&gt;  &lt;view wx:key=&quot;0&quot;&gt;    &lt;view class=&#x27;inItem&#x27;&gt;内层第 0 个名字：&lt;text&gt;张三2&lt;/text&gt;&lt;/view&gt;  &lt;/view&gt;  &lt;view wx:key=&quot;1&quot;&gt;    &lt;view class=&#x27;inItem&#x27;&gt;内层第 1 个名字：&lt;text&gt;汤姆2&lt;/text&gt;&lt;/view&gt;  &lt;/view&gt;  &lt;view wx:key=&quot;2&quot;&gt;    &lt;view class=&#x27;inItem&#x27;&gt;内层第 2 个名字：&lt;text&gt;程咬金2&lt;/text&gt;&lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;&lt;view wx:key=&quot;2&quot;&gt;  &lt;view class=&#x27;h2&#x27;&gt;这是第 2 个数组&lt;/view&gt;  &lt;view wx:key=&quot;0&quot;&gt;    &lt;view class=&#x27;inItem&#x27;&gt;内层第 0 个名字：&lt;text&gt;张三3&lt;/text&gt;&lt;/view&gt;  &lt;/view&gt;  &lt;view wx:key=&quot;1&quot;&gt;    &lt;view class=&#x27;inItem&#x27;&gt;内层第 1 个名字：&lt;text&gt;汤姆3&lt;/text&gt;&lt;/view&gt;  &lt;/view&gt;  &lt;view wx:key=&quot;2&quot;&gt;    &lt;view class=&#x27;inItem&#x27;&gt;内层第 2 个名字：&lt;text&gt;程咬金3&lt;/text&gt;&lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;\n\n哎呀，看到上面渲染结果代码，知道列表渲染的作用有多大了吗？要是没有列表渲染，我们得自己手动复制粘贴，写很大一堆重复代码。\n最后再看一下条件渲染，官方文档地址 https://developers.weixin.qq.com/miniprogram/dev/reference/wxml/conditional.html\n条件渲染：通过判断条件是否满足，从而对视图进行是否显示进行控制，这样就可以在一个页面中书写更多的业务逻辑。比如注册登录，我们可以注册登录两个界面分别写在两个view里，默认显示登录view，点击注册按钮时，将注册view显示出来，登录view隐藏。\n条件渲染用法很简单，通过看代码就可以看懂，结合官网文档自己看看。条件渲染也要可以嵌套条件，用法 wx:if=“条件1” … wx:elif=“条件2” … wx:else … ：如果满足条件1就执行里面的，之后不执行，否者再判断条件2。\n最后有个hidden也可以控制视图是否显示，它和wx:if的区别可以看条件渲染文档最底部区别介绍，通常 业务复杂用wx:if，业务单一用hidden。\n\n\n\n四、setData()\n\n又上栗子了\n\n12345678910111213141516&lt;!--index.wxml--&gt;&lt;view&gt;  &lt;!-- 列表渲染示例 --&gt;  &lt;view class=&#x27;h1&#x27;&gt;列表渲染&lt;/view&gt;  &lt;view wx:for=&quot;&#123;&#123;name&#125;&#125;&quot; wx:for-index=&quot;i&quot; wx:for-item=&quot;item&quot; wx:key=&quot;i&quot;&gt;    这是第&#123;&#123;i&#125;&#125;个名字：&lt;text&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt;  &lt;/view&gt;  &lt;!-- 条件渲染示例 --&gt;  &lt;view class=&#x27;h1&#x27;&gt;条件渲染&lt;/view&gt;  &lt;view wx:if=&quot;&#123;&#123;isIf&#125;&#125;&quot;&gt;1111111111111111&lt;/view&gt;  &lt;view hidden=&quot;&#123;&#123;isHidden&#125;&#125;&quot;&gt;444444444444444&lt;/view&gt;  &lt;!-- 控制按钮 --&gt;  &lt;button bindtap=&#x27;add&#x27;&gt;添加数据&lt;/button&gt;  &lt;button bindtap=&#x27;changeIf&#x27;&gt;改变if&lt;/button&gt;  &lt;button bindtap=&#x27;changeHidden&#x27;&gt;改变hidden&lt;/button&gt;&lt;/view&gt;\n123456789101112131415161718192021222324252627282930//index.jsPage(&#123;  data: &#123;    //列表渲染演示数据    name: [&quot;张三&quot;, &quot;汤姆&quot;, &quot;程咬金&quot;],    isIf: true,    isHidden: true,  &#125;,  //添加数据  add()&#123;    let cname = this.data.name;    cname.push(&quot;强子&quot;);    this.setData(&#123;      name: cname,    &#125;);  &#125;,  //改变isIf值  changeIf()&#123;    let getisIf = this.data.isIf;    this.setData(&#123;      isIf: !getisIf    &#125;);  &#125;,  //改变isHidden值  changeHidden()&#123;    this.setData(&#123;      isHidden: !this.data.isHidden,    &#125;);  &#125;&#125;)\n12345678910111213/**index.wxss**/.h1&#123;  font-size: 48rpx;  line-height: 80rpx;  font-weight: 700;&#125;view text&#123;  color: red;&#125;button&#123;  width: 50%;  margin-top: 10rpx;&#125;\n\n\n效果：\n\n\n\n代码解析\n\n\n官方文档 https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html\n\n\n\nsetData()是Page对象中的一个方法，这是在微信小程序写业务逻辑用得比较多，比如我们一个网络请求获取一个新闻列表数据，我们需要把获取到数据渲染到页面上去，我就可以通过setData()将数据传个this.data中的新闻列表，页面检测到this.data变更后，会自动将页面重新渲染。\n\n\n本例中，是直接写了一个数据“强子”，将这个数据通过js数组的push方法，在数组尾部加入一个元素。add方法的解释：\n\n\n1234567891011//添加数据add()&#123;  //声明一个变量cname，并将this.data.name的值赋值给它  let cname = this.data.name;// cname = [&quot;张三&quot;, &quot;汤姆&quot;, &quot;程咬金&quot;]  //尾部加入一个元素  cname.push(&quot;强子&quot;);// cname = [&quot;张三&quot;, &quot;汤姆&quot;, &quot;程咬金&quot;, &quot;强子&quot;]  //调用setData方法，将this.data.name 替换成 cname  this.setData(&#123;    name: cname,   //name（要替换的数据名）: cname （新的值）  &#125;);&#125;\n\nlet 是js的ES6语法，用法与var差不多，都是声明变量，具体区别可以看我博客关于这个的文章。setData()一般传入一个参数即可，这个参数是一个对象，对象内可以写多个属性（键值对），也就是说可以同时改变多个this.data的中的值。\n之后的改变isIf值的例子，和上面add例子差不多，只是isIf值是布尔值，改变真假的运算（！取反运算）在setData()内部计算的。一般而言，简单表达式计算可以这样做，显得简洁，但复杂的运算不能这样做，容易出错。点击改变if的按钮，“11111”的字符串会隐藏，再点一次出现。\n最后改变isHidden值，和改变isIf的例子一样，把中间变量也省了。作用也是一样的。\n\n\n\n五、wx.showModal()、wx.setClipboardData()\n\n栗子又来\n\n12345678910111213141516&lt;!--index.wxml--&gt;&lt;view&gt;  &lt;!-- 列表渲染示例 --&gt;  &lt;view class=&#x27;h1&#x27;&gt;列表渲染&lt;/view&gt;  &lt;view wx:for=&quot;&#123;&#123;name&#125;&#125;&quot; wx:for-index=&quot;i&quot; wx:for-item=&quot;item&quot; wx:key=&quot;i&quot;&gt;    这是第&#123;&#123;i&#125;&#125;个名字：&lt;text&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt;  &lt;/view&gt;  &lt;!-- 控制按钮 --&gt;  &lt;button bindtap=&#x27;doModal&#x27;&gt;Modal&lt;/button&gt;  &lt;!-- 复制演示 --&gt;  &lt;view    bindtap=&#x27;copyEmail&#x27;    style=&#x27;margin-top:50rpx;text-align:center;&#x27;&gt;    邮箱：abc@example.com（点击复制）  &lt;/view&gt;&lt;/view&gt;\n12345678910111213141516171819202122232425262728//index.jsPage(&#123;  data: &#123;    //列表渲染演示数据    name: [&quot;张三&quot;, &quot;汤姆&quot;, &quot;程咬金&quot;],    isIf: true,    isHidden: true,  &#125;,  //显示modal  doModal()&#123;    wx.showModal(&#123;      title: &#x27;用户组&#x27;,      content: this.data.name.toString(),      showCancel: false    &#125;)  &#125;,  //复制邮箱到粘贴板  copyEmail()&#123;    wx.setClipboardData(&#123;      data: &#x27;abc@example.com&#x27;,      success: function()&#123;        wx.showToast(&#123;          title: &#x27;复制成功！&#x27;,        &#125;)      &#125;    &#125;)  &#125;&#125;)\n\n\n效果：\n\n\n\n代码解析\n\n\n官方文档：\n1.wx.showModal()：https://developers.weixin.qq.com/miniprogram/dev/api/ui/interaction/wx.showModal.html\n2.wx.setClipboardData()：https://developers.weixin.qq.com/miniprogram/dev/api/device/clipboard/wx.setClipboardData.html\n\n\n看到官方文档，这个API的使用和wx.showToast差不多，都是传入一个对象参数。看下面对象规定的介绍，我们可以控制显示的标题、内容、按钮等内容。其中常用的就是红框内的和success回调函数。具体怎么用，看完本例子，相信大家都应该能会了。唯一需要解释的就是，content属性必须是string类型，本例子中让其显示数组，则需要进行转换，就用了js数组的toString()方法，将数组转换成以逗号隔开的字符串。切记：看文档主要就是看字段名和规定类型，调用失败时首先检查的就是字段名有没有写错，数值类型对不对。 最后，关于success回调函数的使用，参考官方文档下面的示例。\n\n\n\nwx.setClipboardData()是设备API类里的，可见左侧，我们可以通过此类API获取用户设备的信息，如手机电量信息，具体底层微信团队是怎么实现的我们不用管，我们学会怎么用他们提供的API就行了。本次介绍的控制用户设备剪贴板的API也是比较常用的，我们可以让用户点击某些东西，直接将数据写到用户的剪贴板，这样用户就不用来回切换程序手动记录，比如联系信息类的。本例子的作用是点击复制邮箱，结合了showToast一起，用于提示。传入值依然是一个对象，其中data字段是必须的，这是复制过去的数据。另外还有个API是获取用户剪贴板内容，wx.getClipboardData()，自学。\n\n\n\n\n\n六、weui框架简单学习\n  weui框架是微信的一套UI框架，也就是我们在微信里常见到的“微信绿”。这是我学习的第一个微信小程序框架，比较熟悉一点，就先用这个给大家介绍如何在小程序里使用框架。另外还有iview、colorUI、taro、minUI、wux等好看的UI框架。，一般一个项目只用一个框架，多个框架一起使用 很容易出错，出一些莫名奇妙的错，建议大家以后分别看看每个框架的样式，觉得哪个好看就学哪个吧，自学嘻嘻嘻。\n  框架学习我们还是要看官方文档的，他们会写好怎么引用，还有很多例子。\n\n\nweui样例示范：\n\n\nweui介绍文档：https://github.com/Tencent/weui-wxss/\n\n\n6.1 框架下载和配置\n  打开weui的github项目地址https://github.com/Tencent/weui-wxss/，点击Download ZIP。\n\n解压下载的zip文件，打开目录weui-wxss-master/dist/style，复制weui.wxss到我们的微信小程序根目录下。\n\n打开开发工具，并在app.wxss中添加一行，引weui.wxss。\n\n6.2 框架的使用\n\n\n用开发工具，导入项目，项目目录选择weui-wxss-master/dist，appid点测试号就行，等待导入编译成功；\n\n\n我们可以在左侧点击表单，点击button看看weui提供的按钮样式（也可以用手机扫上面小程序预览）；\n\n\n项目example目录下找到button/button.wxml，查看代码；\n\n\n\n选择我们想要的样式，复制到我们的项目里；\n\n\n\n这样就算是我们成功用上了框架提供的样式了，对于这些样式，我们如果不满意，我们还可以在其基础上进行修改。如按钮默认宽度几乎与页面一样宽了，我们可以在本页面所属的wxss里进行样式重写，因为本页面的wxss是优先级是高于外部引入的weui.wxss，所以我们不必担心会不会与原样式会不会冲突。如上图，由于我们之前演示例子是，将按钮宽度定义为了50%，所以上面Modal按钮并没有那么宽。\n\n\n七、结束语\n  本期讲的容有点多，但花一天时间慢慢鼓捣，应该都能弄懂。这些都是小程序常用，对于速成很实用。下面我将列一些其他常用API，希望大家能通过官方文档先自学，下一期我会选择性的讲。\n\nwx.setStorage\nwx.getStorage\nwx.setStorageSync\nwx.getStorageSync\nwx.redirectTo\nwx.navigateTo\nwx.request\n\n链接：微信小程序快速上手教程-3\n","plink":"https://www.zzboy.cn/Learning/27b3d8660c17/"},{"title":"微信小程序快速上手教程-1","date":"2019-04-22T08:14:00.000Z","date_formatted":{"ll":"Apr 22, 2019","L":"04/22/2019","MM-DD":"04-22"},"updated":"2021-02-27T15:17:00.453Z","content":"  这是微信小程序开发入门程序第一节。在学习前，你需要具备一定的html、css和js基础，没有基础当然也可以勇于尝试阅读。\n本节学习内容主要有：\n\n小程序注册、开发工具使用\n编写并剖析一个简单程序\napp.* 介绍\nrpx单位\nflex布局\n常用简单标签\n\n \n教程（一）-快速入坑\n一、前言\n  这是我写给研究所学弟学妹们的，快速入坑小程序教程，能利用小程序快速开发一些项目去参加比赛。教程完全根据自己学习经验编写，涉及小程序知识浅薄，但易懂，易快速习惯小程序开发思维，也容易开发自己想要的功能。\n  教程针对有一定Html+CSS+JavaScript基础的同学，因为微信小程序页面文件主要由wxml, wxss, js, json文件构成，其中wxml类似html，只是标签比html少很多；wxss其实就是css层叠样式表；js就是JavaScript文件；json是以json格式写的配置文件。\n二、入坑准备\n2.1 注册小程序\n  注册小程序我不想介绍，这个只要前往微信公众平台，点击小程序注册就能一步步往下进行，完成注册了。注册期间我认为唯一值得注意的是“小程序名称”，这个后期是可以更改的，但每次更改是有时间限制和名称更改记录。如果不在意这些，可以任意注册。\n  注册完成后，填写小程序信息，然后需要做的一件事是：记下AppID\n\n操作提示：点击设置-&gt;基本设置的最下方-&gt;复制APPID(小程序ID)\n官方教程：https://developers.weixin.qq.com/miniprogram/dev/quickstart/basic/getstart.html#申请账号\n\n2.2 安装微信开发工具\n\n下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html\n下载：选择稳定版，然后选择对应系统下载。\n安装：省略…\n安装完成后：可以自己打开开发工具先鼓捣鼓捣一会儿…\n\n三、第一个小程序\n3.1 新建项目\n\n扫码登录，新建项目；\n项目名称 以及 目录 自己定\nAppID填写你注册的小程序AppID，也就是上一步记下的；\n后端服务和语言默认：不使用云服务和JavaScript\n创建！\n\n3.2 编写程序\n3.2.1 开发页面简介\n  在上一步点击新建项目后，哇！屏幕一下就大了，欢迎来到小程序开发页面！（欢迎来到王者荣耀）。\n  初次使用页面分为5大块：最上面的菜单、左侧模拟器、下方控制台（和浏览器F12差不多）、中间项目文件目录和代码编辑区。\n\n3.2.2 跟我一起做！\n\n在项目目录上，点开 pages 目录，再点开 index 目录；\n双击 index.html，然后在代码编辑器，全选代码，删除！代码全删了！；\n双击 index.wxss，全选代码，删除！；\n双击 index.js，全选代码，删除！；\n双击 index.json，全选代码，全删！；\n删了这么多代码，是不是很痛快！嘿\n双击 index.wxml，复制以下代码，粘贴，然后Ctrl+S保存，观察左侧模拟器显示内容：\n\n123&lt;view class=&quot;body&quot;&gt;    &lt;text&gt;欢迎 &#123;&#123;name&#125;&#125; 学习小程序!&lt;/text&gt;&lt;/view&gt;\n\n双击 index.wxss，复制粘贴以下代码，然后保存，观察左侧模拟器显示内容：\n\n1234567.body&#123;    text-align: center;&#125;.body text&#123;    display: block;    margin-top: 300rpx;&#125;\n\n双击 index.js，复制粘贴以下代码，将代码中的中文“你的名字”改成 你的名字，保存观察：\n\n12345Page(&#123;    data: &#123;        name: &quot;你的名字&quot;,   //将内容替换为你的名字    &#125;&#125;)\n\n双击 index.json，复制粘贴以下代码，保存观察：\n\n123&#123;    &quot;navigationBarTitleText&quot;: &quot;首页&quot;&#125;\n3.2.3 预览\n  找到上方正中间位置处，有个 小眼睛 （预览），点击它，然后用微信扫以下，就可以在手机上看效果了。\n3.3 简要分析\n\n分析：\n  在上一步，可能大家边复制粘贴，边保存观察可能已经看出来很多了。有Html基础，是不是感觉微信小程序很简单？首先看index.wxml文件，是不是很像html里的标签，只是名称不一样，&lt;view&gt;标签可以理解为html里的 &lt;div&gt;，&lt;text&gt;可以理解为&lt;span&gt;。\n  再看view标签里，加了一个 class=“body”，这个不就和html里给标签加类名一样的嘛，既然这引用了body这个样式，那我们双击 index.wxss，这里面是不是给body定义了样式！文本居中，对吧。看到这是不是有点感觉了？再看看下面还给body内的text标签写了样式，让它以块级元素显示，并距离顶部300rpx的距离，先不讨论rpx这个单位，是不是有一种感觉，wxml就是html，wxss就是css？是的，没错！只是wxml里标签很少，名称也是微信团队规定的。但wxss就完全是css了，只是文件名不一样而已。\n  接下来，我们看看index.js代码，这个可以说完全就是JavaScript代码，连后缀名也是一样的。区别是，在微信小程序里，一个js文件 只能存在一个Page()方法，其它所有函数方法都只能在Page()里写，而且，Page()这个方法仅有唯一参数，对象，特点就是一个属性对应一个值，这个值也可以是一个新的对象。看我们的代码，Page方法内有一个对象，对象内有一个属性（data），它对应的值一个新的对象，而新的对象内又有一个属性（name）,对应的值是一段字符串。\n  最后再来看看index.json代码，很明显，这直接就是一个 对象 或者称 json串，只有一个键navigationBarTitleText，对应一个值字符串：首页。这个效果可以从小程序顶部中间可以看出来，标题显示的内容就是在这定义的，因此这个文件就是对这么一个页面配置，以及后面在页面内使用自定义组件时进行声明。\n关系：\n\n  如图，小程序每新建一个页面，都会生成这四个文件。它们之间的关系也就这样，wxml是直接的视图显示，wxss就是对wxml内容进行修饰排版美化的，js则是给wxml提供数据支持，以及对用户在wxml里的操作进行处理的，json则是对整个页面进行配置。\n\n四、小程序部分基础介绍\n4.1 新建页面\n  通过前面第一个小程序可以了解到，一个完整的小程序页面包含4个同名不同后缀的文件，分别是：wxml、wxss、js和json文件。为了规范化，我们通常为每个页面创建一个文件夹，文件夹内包含该页面的4个文件。这四个文件在微信开发工具里，不需要我们一一新建，我们可以一键新建好4个文件，请按照以下步骤执行：\n\n找到 pages ，右键新建一个文件夹，文件名自定义。\n在刚才新建的文件夹上右键，新建page，然后输入页面名，为了规范，通常此名同文件夹名\n完成！\n\n4.2 app.* 介绍\n  大家是不是很奇怪，小程序根目录下有3个文件和我们小程序页面的4个文件很像，它们分别是app.js、app.json、app.wxss。它们内部的代码其实和小程序页面没什么区别，不过，我们在这几个文件写的代码将会影响整个小程序，可以理解为对整个小程序的业务逻辑、小程序配置和样式配置。\n\n在app.js中，我们通常写一些在小程序其他页面能常用到的业务逻辑，如获取用户信息、日志记录\napp.json：是对整个小程序的配置，如小程序启动首页，小程序图标、显示名称等。这些内容之后在编写多页面时进行介绍\napp.wxss：这里面通常写一些全局样式，以及引用一些其他小程序框架的样式文件\n\n4.3 rpx单位\n  因为小程序是面向移动端的程序，移动端的屏幕大小是多种多样的，所以我们很有必要选好尺度单位。前面讲过wxss就相当于css，在wxsss里可以直接使用css里的单位如：px、pt、em等，但是在微信小程序内，推荐全部统一使用rpx单位。\n  rpx（responsive pixel）为达到屏幕宽度自适应的目的，小程序规定所有屏幕，无论大小，宽度均为 750rpx 。换句话说，不管你用什么手机，都把你手机宽度等分成750份，这就相当于所有手机宽度都是确定的，我们开发者就非常容易开发程序，至于适应不同屏幕的手机就交由微信小程序底层去实现。\n4.4 flex布局\n  flex布局是一种按比例进行布局的布局方式。在wxss里编写，flex布局同样适用于网页css样式。要使用Flex布局得设置以下步骤：\n\n设置容器显示方式为Flex：display: flex;\n设置容器内部组件排列方向：flex-direction: column或row;\n在内部组件设置flex占比：flex: n;(可不写，默认按照自身大小排列)\n\n  下面举几个例子说明，其中蓝色容器class=box，其余class见图\n\nflex纵向布局1234567891011.box&#123;  display: flex;  flex-direction: column;&#125;/* item1:item2:item3 = 1:2:1  将box纵向按1:2:1划分 */.item1,.item3&#123;  flex: 1;&#125;.item2&#123;  flex: 2;&#125;\n\nflex横向布局12345678.item1&#123;  display: flex;  flex-direction: row;&#125;/* left:right = 1:1  将item1横向按1:1划分 */.left,.right&#123;  flex: 1;  /* 可以写成2,3,4等其他数， 按照2:2或3:3划分，也就是1:1啦 */&#125;\n\n\n\n\nflex综合布局1234567891011121314151617.item1&#123;  display: flex;  flex-direction: column;&#125;/* top:bottom = 1:1  将item1纵向按1:1划分 */.top&#123;  flex: 1;&#125;.bottom&#123;  flex: 1;    display: flex;  flex-direction: row;&#125;/* btn:btn:btn = 1:1:1  将bottom横向按1:1:1划分 */.btn&#123;  flex: 1;&#125;\n\n\n五、任务\n  参考官方文档，学习以下wxml标签（加*的暂时不用掌握，部分涉及js较复杂）、掌握flex布局、熟悉rpx单位，完成一个内容较丰富的展示页面。\n\n官方文档组件地址：https://developers.weixin.qq.com/miniprogram/dev/component/\n\n\n视图容器类：\n\nview\nswiper\nscroll-view*\n\n\n基础类\n\nicon\ntext\nprogress*\n\n\n表单类\n\nbutton\ninput\nlabel\ntextarea\nradio*\ncheckbox*\npicker*\npicker-view*\nswitch*\nform*\n\n\n导航类\n\nnavigator*\n\n\n媒体组件类\n\nimage\naudio*\nvideo*\n\n\n地图\n\nmap*\n\n\n画布\n\ncanvas*\n\n\n客服对话\n\ncontact-button*\n\n\n\n链接：微信小程序快速上手教程-2\n","thumbnail":"/images/wechatminiprogram.jpg","color":"#111","plink":"https://www.zzboy.cn/Learning/ab53316b58b4/"},{"title":"Spring MVC配置","date":"2019-04-01T14:01:00.000Z","date_formatted":{"ll":"Apr 1, 2019","L":"04/01/2019","MM-DD":"04-01"},"updated":"2021-02-27T13:48:33.015Z","content":"导入库\n\n首先新建一个Java Web项目，最后一步选择框架时，此步不选任何框架，点击完成；\n然后再新建的项目 “库” 上右键 添加库 ,找到其中的Spring Framework、Spring Web MVC 、JSTL进行添加，前两个Spring库版本号需要一致；\n\n网站设置\n\n在项目的 源包（src） 目录下, 新建Java类：ApplicationInitializer和AppConfig，包：conf，其中类名和包名都可以自己任意起；\n在实现WebApplicationInitializer 的类中对网站进行配置. 这种硬编码的配置方式可以通过编写web.xml进行替换掉, 也就是web.xml优先起作用.\n\nsrc/conf/ApplicationInitializer.java：\n1234567891011121314151617181920package conf;import javax.servlet.ServletContext;import javax.servlet.ServletException;import javax.servlet.ServletRegistration;import org.springframework.web.WebApplicationInitializer;import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;import org.springframework.web.servlet.DispatcherServlet;public class ApplicationInitializer implements WebApplicationInitializer &#123;  //实现这个接口是关键, 与类名无关.    @Override    public void onStartup(ServletContext servletContext) throws ServletException &#123;        AnnotationConfigWebApplicationContext annotationConfigWebApplicationContext = new AnnotationConfigWebApplicationContext();        annotationConfigWebApplicationContext.register(AppConfig.class); //注册自己定义的AppConfig类.        annotationConfigWebApplicationContext.setServletContext(servletContext);        ServletRegistration.Dynamic servlet = servletContext.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(annotationConfigWebApplicationContext));        servlet.addMapping(&quot;/&quot;); //此Servlet负责处理(mapping)除了对Servlet/JSP外的所有(URL)访问        servlet.setLoadOnStartup(1); //第1个加载这个Servlet. 最先加载的是第0个.     &#125;&#125;\nsrc/conf/AppConfig.java：\n1234567891011121314151617181920212223package conf;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;import org.springframework.web.servlet.view.JstlView;@Configuration  //配置如下@EnableWebMvc   //允许使用springMVC@ComponentScan(basePackages = &#123;&quot;controller&quot;&#125;)  //扫描controller包中的组件(类)public class AppConfig extends WebMvcConfigurerAdapter &#123; //类名随意    @Bean  //下面的方法产生一个bean    public InternalResourceViewResolver createViewResolver() &#123; //方法名随意        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();        viewResolver.setPrefix(&quot;/WEB-INF/view/&quot;); //前缀        viewResolver.setSuffix(&quot;.jsp&quot;); //后缀        viewResolver.setViewClass(JstlView.class); //使用JSTL视图        return viewResolver;    &#125;&#125;\n\n对于index.html的请求, 返回的是index加上前后缀. 如上配置的前缀为/WEB-INF/view/, 后缀为.jsp. 最终的视图文件为/WEB-INF/view/index.jsp.\n\n控制器源程序\n\n在项目的src目录下, 创建Java源程序文件/controller/mainController.java\n\nsrc/controller/mainController.java：\n12345678910111213141516package controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class mainController &#123;    @RequestMapping(&quot;/index&quot;)    public String hello()&#123;        return &quot;index&quot;;    &#125;    @RequestMapping(&quot;/login&quot;)    public String login()&#123;        return &quot;login&quot;;    &#125;&#125;\n视图\n\n项目的web目录 /WEB-INF/view/ ，可由前面的AppConfig进行配置。在该目录下，创建index.jsp和login.jsp文件。\n\n/WEB-INF/view/index.jsp：\n123456789101112&lt;%@page contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;        &lt;title&gt;Index page&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;This is RequestMapping(&quot;/index&quot;) page!!!&lt;/h1&gt;        &lt;a href=&quot;login&quot;&gt;登录&lt;/a&gt;    &lt;/body&gt;&lt;/html&gt;\n/WEB-INF/view/login.jsp：\n123456789101112131415&lt;%@page contentType=&quot;text/html&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;        &lt;title&gt;login page&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;h1&gt;This is RequestMapping(&quot;/login&quot;) page!!!&lt;/h1&gt;        &lt;center&gt;            账号：&lt;input type=&quot;text&quot;&gt;            密码：&lt;input type=&quot;text&quot;&gt;        &lt;/center&gt;    &lt;/body&gt;&lt;/html&gt;\n整体结构\n\nspringmvc项目必须添加spring framework的包. 此项目中AppConfig指定使用JSTL视图JstlView.class, 因此还需要添加JSTL的包。项目结构如下：\n\n\n运行结果\n\n暂时没有，因为我的tomcat服务器出问题了，我还没有解决。运行不出来呀，蓝瘦、、\n\n","plink":"https://www.zzboy.cn/Learning/280ed29779d2/"},{"title":"幸福？","date":"2019-02-27T09:10:00.000Z","date_formatted":{"ll":"Feb 27, 2019","L":"02/27/2019","MM-DD":"02-27"},"updated":"2021-02-27T13:51:06.085Z","content":"  原来作文里经常有写有关“幸福是什么”的话题。幸福是什么？我到现在也不知道。我只知道，当幸福离你而去的时候，你肯定会有很多的遗憾和后悔。\n \n  幸福她知道我爱吃的不是多贵多稀奇的，而是那清香的蘑菇汤、一锅炖冬瓜、盐渍的生苦瓜…当幸福快要离去的那一年，我迷蒙地好像懂了，那一年，我常陪着幸福，和她一起去广场打牌，去逛公园。她也知道快要离去，那一年她恨不得把所有的爱留下来，每周每天都准备好我喜欢的，等我放学。虽然我还是不懂幸福，但我十分确定，那一年，我很幸福。\n \n  几年过去了，我似乎从幸福离开的阴影走出来了。现在，虽然我感受不出我身边是不是还有幸福，但我知道，我身边肯定是有幸福的。因为当幸福离去的时候，我才能强烈地感受到。今天整理一些旧物，想起了原来的同桌：有喜欢在我手上留下牙印的，有喜欢斯牛奶盒帮助我英语的，有喜欢和我一起奇葩一起傻的，有国庆长假和我一起白天睡觉晚上通宵做作业的，还有偷偷往我桌里塞苹果的…我想这些同桌都是我所拥有过的幸福。现在我不知道我身边的幸福是什么，也许是那上课一起坐第一排的室友，也许是那一起包宿的“战友”，也许是那一起喝酒诉忧的红颜…\n \n  幸福是什么无关紧要，珍惜当前，善待身边每个人，莫要等幸福失去才后悔莫及。\n \n  那刻骨熟悉而再没有唤过的“婆哟”，我想 see you again！\n \n \n2019年2月27，有感而抒。\n——此文致爱我19载的奶奶！\n","plink":"https://www.zzboy.cn/Life/6ce798ebd529/"},{"title":"Vue更新data后没有渲染html问题","date":"2019-01-02T03:19:00.000Z","date_formatted":{"ll":"Jan 2, 2019","L":"01/02/2019","MM-DD":"01-02"},"updated":"2021-02-27T13:48:27.266Z","content":"问题源码\n  这是我做课程设计时遇到的一个让我抓狂的问题，本来元旦三天的，我花了两天写前端。然后写完前端那天晚上就开始配置后端SSM框架，额，一直报错，找不到控制器controller，然后各种抓狂心态爆炸的去查这改那，知道第二天晚上（昨天晚上）在大佬 Hashq 帮我找到原因，缺少一个**@ Controller**。然后后端问题终于解决了嘛，我就怀着愉快的心情奋奋地想在昨天晚上多写点接口。但是！但是！我测试的时候，前端页面能获取到数据，但是就是没有渲染出来，具体代码如下：\nJavaScript:\n1234567891011121314151617new Vue(&#123;\t\t\tel: &quot;#vueroot&quot;,      //vue控制挂载点\t\t\tdata: &#123;       //数据\t\t\t\thotFlowers: []\t\t\t&#125;,\t\t\tmethods:&#123;\t\t\t\tgetHotFlowers:function () &#123;\t\t\t\t\t$.getJSON(&quot;getHotFlowers&quot;,function(data)&#123;\t\t\t\t\t\tthis.hotFlowers = data;\t\t\t\t\t&#125;)\t\t\t\t&#125;\t\t\t&#125;,\t\t\t//生命周期函数\t\t\tcreated:function()&#123;\t\t\t\tthis.$options.methods.getHotFlowers();\t\t\t&#125;\t\t&#125;)\nHtml:\n12345&lt;div class=&quot;bd-con-hot-item&quot; v-for=&quot;item in hotFlowers&quot; &gt;\t&lt;div class=&quot;bd-con-hot-item-pic&quot;&gt;&lt;img v-bind:src=&quot;[&#x27;img/flower/&#x27;+item.picture]&quot; /&gt;&lt;/div&gt;\t&lt;div class=&quot;bd-con-hot-item-name&quot;&gt;&lt;span&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt;&lt;/div&gt;\t&lt;div class=&quot;bd-con-hot-item-price&quot;&gt;&lt;span&gt;¥&#123;&#123;item.price&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;\n解决过程\n  然后就是死活就是渲染不出来，真是心态爆炸，我起先怀疑是json格式问题，我尝试了json.parse()；然后怀疑是vue的生命周期函数问题，我尝试了mounted,updated；问题还是没有解决，看网上有人像如下这样写：\n12345678 $.getJSON(&quot;getHotFlowers&quot;,function(data)&#123;\t new Vue(&#123;\t \tel: &quot;#vueroot&quot;,\t \tdata:&#123;\t\t hotFlowers : data\t \t&#125;\t &#125;)&#125;);\n  这样写就可以渲染出来，然后我就在想我原来的写法肯定没有将data更新成功，后来我想起了我写微信小程序的时候经常用var that = this，我好像有点思路了，本来对这个理解有点似懂非懂。然后我将代码改成：\n12345678//前面代码省略...//生命周期函数\tcreated:function()&#123;\t\tvar that = this;\t\t$.getJSON(&quot;getHotFlowers&quot;,function(data)&#123;\t\t\tthat.hotFlowers = data;\t\t&#125;);\t&#125;\n  竟然好使了，然后我就懂了，这次错误还是错在细节问题上。应该在vue实例里用的this作用域是整个vue实例，但是，如果是在其内部使用的方法中，再使用this，那个this是指代的那个具体方法，也就是内部this和外部this不是同一个指代。所以，我们要提前区分一下，通过将外部作用的this转移，也就是像我上面那样赋值给that进行转移。然后在内部函数中，that就代表vue实例，此时this就代表$.getJSON。既然问题解决了，我就重新再优化了一下代码，将获取后台数据的方法封装到methods里，然后通过传参that进行vue实例数据更新，详细实现如下：\n123456789101112131415161718new Vue(&#123;\t\t\tel: &quot;#vueroot&quot;,      //vue控制挂载点\t\t\tdata: &#123;       //数据\t\t\t\thotFlowers: []\t\t\t&#125;,\t\t\tmethods:&#123;\t\t\t\tgetHotFlowers:function (that) &#123;\t\t\t\t\t$.getJSON(&quot;getHotFlowers&quot;,function(data)&#123;\t\t\t\t\t\tthat.hotFlowers = data;\t\t\t\t\t&#125;)\t\t\t\t&#125;,\t\t\t&#125;,\t\t\t//生命周期函数\t\t\tcreated:function()&#123;\t\t\t\tvar that = this;\t\t\t\tthat.$options.methods.getHotFlowers(that);//传递that\t\t\t&#125;\t\t&#125;)\n总结\n  都是 细节 问题，本来很简单的问题，因为不熟悉，因为缺少经验，但经过撕心裂肺后，这就是经验，学习不止步。\n","plink":"https://www.zzboy.cn/Learning/077017a6a342/"},{"title":"Vue.js学习笔记","date":"2018-12-28T12:25:00.000Z","date_formatted":{"ll":"Dec 28, 2018","L":"12/28/2018","MM-DD":"12-28"},"updated":"2021-02-27T13:48:23.510Z","content":"先话\n  因为这周Java Web课程设计，自己对原生js操作也不是很熟练，想着用一下这个强大的vue框架，让自己做的课设更快一点，并且给老师一种高大尚的感觉。所以今天考试完后，就花了3个多小时，看vue官网文档（还是国人出的框架文档看起来快），并结合慕课网和 Bug昊 大佬很久以前就给我的vue视频，把基本的使用学了，并总结出一份笔记，我觉得这些足够应对我现在的小型项目了。\n\n笔记在此，日后参考，也供大家参考\n\n干货笔记\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;script src=&quot;./js/vue.js&quot;&gt;&lt;/script&gt;   &lt;!-- 引入js --&gt;&lt;script src=&quot;./js/jquery.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;root&quot;&gt;\t&lt;div v-on:click=&quot;handleClick&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;\t&lt;div @:click=&quot;handleClick&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;   &lt;!-- 缩写形式 --&gt;\t\t&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; css1 &#125;&quot;&gt;&lt;/div&gt;\t&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; css1 : isActive1 , &#x27;css2&#x27;: isActive2 &#125;&quot;&gt;&lt;/div&gt;\t&lt;div class=&quot;static&quot; :class=&quot;&#123; css1 : isActive1 , &#x27;css2&#x27;: isActive2 &#125;&quot;&gt;&lt;/div&gt;     &lt;!-- 缩写形式 --&gt;\t&lt;div class=&quot;static&quot; :class=&quot;[css1, css2]&quot;&gt;&lt;/div&gt;      &lt;!-- 数组形式 --&gt;\t&lt;div v-if=&quot;条件1&quot;&gt;A&lt;/div&gt;     &lt;!-- 条件判断是否显示 --&gt;\t&lt;div v-else-if=&quot;条件2&quot;&gt;B&lt;/div&gt;\t&lt;div v-else&gt;C&lt;/div&gt;\t\t&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;      &lt;!-- 可见控制 --&gt;\t&lt;li v-for=&quot;(item, index) in items&quot;&gt;&#123;&#123; index &#125;&#125; - &#123;&#123; item.aa &#125;&#125;&lt;/li&gt;     &lt;!-- 循环渲染，index不必要 --&gt;\t\t&lt;div v-for=&quot;(value, key, index) in object&quot;&gt;&#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;      &lt;!-- 渲染对象 --&gt;\t\t&lt;input type=&quot;text&quot; v-model=&quot;message&quot; &gt;               &lt;!-- v-model进行表单值获取 --&gt;\t&lt;input type=&quot;checkbox&quot;  value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt; \t&lt;input type=&quot;checkbox&quot;  value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;\t&lt;input type=&quot;radio&quot;  value=&quot;One&quot; v-model=&quot;picked&quot;&gt;\t &lt;select v-model=&quot;selected&quot;&gt; ... &lt;/select&gt;\t&lt;select v-model=&quot;selected&quot;&gt;     &lt;!-- option循环渲染案例 --&gt;  \t\t&lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;\t&lt;/select&gt;&lt;/div&gt;&lt;script&gt;\tnew Vue(&#123;\t\tel: &quot;#root&quot;,      //vue控制挂载点\t\tdata: &#123;       //数据\t\t\tcontent : &quot;hello&quot;,\t\t\tisActive1 : true,\t\t\tisActive2 : false,\t\t\tcss1: &quot;css1name&quot;,\t\t\tcss2: &quot;css2name&quot;,\t\t\titems: [&#123;aa: &quot;value1&quot;&#125;, &#123;aa: &quot;value2&quot;&#125;],\t\t\tobject: &#123; firstName: &#x27;John&#x27;,  lastName: &#x27;Doe&#x27;, age: 30 &#125;,\t\t\t\t\t\tmessage: &quot;&quot;,\t\t\tcheckedNames: [ ],\t\t\tpicked: &quot;&quot;,\t\t\tselected: &quot;&quot;,\t\t\toptions: [ &#123; text: &#x27;One&#x27;, value: &#x27;A&#x27; &#125;,  &#123; text: &#x27;Two&#x27;, value: &#x27;B&#x27; &#125;,   &#123; text: &#x27;Three&#x27;, value: &#x27;C&#x27; &#125; ],\t\t&#125;,\t\t//方法集合，供其他调用：this.$options.methods.handleClick();\t\tmethods: &#123;  \t\t\thandleClick: function()&#123;\t\t\t\tthis.content = &quot;world&quot;\t\t\t&#125;,\t\t\tgetData:function () &#123;   //结合jquery进行ajax的get请求\t\t\t\t$.ajax(&#123;\t\t\t\t\turl: &quot;&quot;,\t\t\t\t\ttype: &#x27;get&#x27;,\t\t\t\t\tdataType:&quot;json&quot;,\t\t\t\t\tsuccess: function (data) &#123; ...data是已格式好的...  &#125;,\t\t\t\t\terror: function() &#123; ... &#125;,\t\t\t\t\tcomplete: function() &#123; ... &#125;\t\t\t\t&#125;)          \t\t\t&#125;,\t\t\tpostData:function () &#123;   //结合jquery进行ajax的post请求\t\t\t\t$.ajax(&#123;\t\t\t\t\turl: &quot;&quot;\t\t\t\t\ttype: &#x27;post&#x27;,\t\t\t\t\tdataType:&quot;json&quot;,\t\t\t\t\tsuccess: function (data) &#123; ... &#125;,\t\t\t\t\terror: function() &#123; ... &#125;,\t\t\t\t\tcomplete: function() &#123; ... &#125;\t\t\t\t&#125;)          \t\t\t&#125;,\t\t&#125;, \t\tcreated: function()&#123; this.$options.methods.getData(); //初始化完成调用methods内的函数 &#125;\t\t//生命周期函数\t\tbeforeCreate: function()&#123; ...实例创建前... &#125;,\t\tcreated: function()&#123; ...实例创建后... &#125;,\t\tbeforeMount: function()&#123; ...HTML渲染前... &#125;,\t\tmounted: function()&#123; ...HTML渲染后... &#125;,\t\tbeforeUpdate: function()&#123; ...data更新渲染前... &#125;,\t\tupdated: function()&#123; ...data更新渲染后... &#125;,\t\tbeforeDestroy: function()&#123; ...实例摧毁前... &#125;,\t\tdestroyed: function()&#123; ...实例摧毁后... &#125;,\t\t\t&#125;)&lt;/script&gt;\n","plink":"https://www.zzboy.cn/Learning/bc07c5f099c1/"},{"title":"阿里云lnmp更换预装mysql遇到的坑","date":"2018-12-05T11:00:00.000Z","date_formatted":{"ll":"Dec 5, 2018","L":"12/05/2018","MM-DD":"12-05"},"updated":"2021-02-27T13:48:19.554Z","content":"坑1：MySQL server PID file could not be found!\n  这是阿里云轻应用服务器的一个坑，提示PID文件找不到。这是预装的lnmp的问题，他们修改了配置文件。我们需要重新修改一下，具体步骤如下：\nvim 打开 /etc/my.cnf\n修改其中的pid路径，具体路径在：\n/usr/local/mysql/data/阿里应用名.pid\n坑2：Can’t connect to local MySQL server…\n  提示：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ ，这个也是无法找到sock文件导致的。我找到那个目录，确实也没有发现.sock文件，sock丢失。具体解决方法如下：\n  先杀死所有mysqld进程，然后重新生成sock文件。最后再重启mysqld服务\n1234killall mysqld/usr/local/mysql/bin/mysql_install_db/usr/local/mysql/bin/mysqld_safe &amp;    service mysqld start\n","plink":"https://www.zzboy.cn/Learning/fd412be05567/"},{"title":"生活","date":"2018-11-28T00:20:25.000Z","date_formatted":{"ll":"Nov 28, 2018","L":"11/28/2018","MM-DD":"11-28"},"updated":"2021-02-18T03:42:31.064Z","content":" \n** 偶尔羡慕，努力让自己拥有！**\n \n  \n \n \n \n \n","plink":"https://www.zzboy.cn/Life/bbab7a528c08/"},{"title":"mysql user无password字段以及authentication_string更新失败","date":"2018-09-20T07:47:09.000Z","date_formatted":{"ll":"Sep 20, 2018","L":"09/20/2018","MM-DD":"09-20"},"updated":"2021-02-27T13:48:16.075Z","content":"\nmysql传统改密码方式发现没有 password这个字段?\n网上查了一下据说5.7 版本password 字段改成authentication_string password函数还是原来的password函数; 我们可以查看一下当前user结构：\n1mysql&gt; desc user; \n发现确实没有password字段，只有authentication_string；\n然后尝试：\n12mysql&gt; update user set authentication_string=password(&#x27;123&#x27;) where user=&#x27;root&#x27;; ERROR 1175 (HY000): You are using safe update mode and you tried to update a table without a WHERE that uses a KEY column\n竟然有不能修改，最后又得知原因是：mysql有个叫SQL_SAFE_UPDATES的变量，为了数据库更新操作的安全性，此值默认为1，所以才会出现更新失败的情况。\n查看设置：\n1234567mysql&gt; show variables like &#x27;sql_safe%&#x27;; +------------------+-------+ | Variable_name | Value | +------------------+-------+ | sql_safe_updates | ON | +------------------+-------+ 1 row in set (0.00 sec) \n下面是SQL_SAFE_UPDATES变量为0和1时的取值说明：\nSQL_SAFE_UPDATES有两个取值0和1， 或ON 和OFF;\nSQL_SAFE_UPDATES = 1，ON时，不带where和limit条件的update和delete操作语句是无法执行的，即使是有where和limit条件但不带key column的update和delete也不能执行。\nSQL_SAFE_UPDATES =0，OFF时，update和delete操作将会顺利执行。那么很显然，此变量的默认值是1。\n所以，出现1175错误的时候，可以先设置SQL_SAFE_UPDATES的值为0 OFF，然后再执行更新;\n执行以下命令：\n12mysql&gt; set sql_safe_updates=off; Query OK, 0 rows affected (0.00 sec) \n再次修改密码：\n12mysql&gt; update user set authentication_string=password(&#x27;123&#x27;) where user=&#x27;root&#x27;; Query OK, 1 row affected, 1 warning (0.00 sec) \n最后再刷新一下权限：\n12mysql&gt; FLUSH PRIVILEGES; Query OK, 0 rows affected (0.00 sec)","plink":"https://www.zzboy.cn/Learning/b86e568bc034/"},{"title":"阿里轻量云服务器ssl证书部署","date":"2018-09-18T15:19:40.000Z","date_formatted":{"ll":"Sep 18, 2018","L":"09/18/2018","MM-DD":"09-18"},"updated":"2021-02-27T13:48:12.278Z","content":"\n在阿里购买了一个免费的一年ssl证书，下载下来后按照阿里给的教程没有安装成功，之后自己在网上找的一个方法，这里做个记录一下。\n第一步，上传证书文件到服务器\n保存在/usr/local/apache/cert/目录下，cert目录是自己创建的，可以自己取其他名字。\n第二步，配置http-vhosts.conf文件\n12345678910ServerAdmin webmaster@serveradmin.com DocumentRoot &quot;/home/www/htdocs/dc&quot; ServerName 你的域名 SSLEngine on SSLProtocol all -SSLv2 -SSLv3 SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM SSLCertificateFile cert/public.pem #三个证书文件 SSLCertificateKeyFile cert/214*********453.key #三个证书文件 SSLCertificateChainFile cert/chain.pem #三个证书文件 ProxyPassMatch ^/(.*\\.php(/.*)?)$ unix:/home/www/logs/php-fpm.sock|fcgi://127.0.0.1/home/www/htdocs/dc/  \n\n注：重点是端口一定要把原来的80改为443。\n\n第三步、重启\n1apache /usr/local/apache/bin/apachectl restart","plink":"https://www.zzboy.cn/Learning/d97b541a2c03/"},{"title":"mysql数据库备份导出.sql文件","date":"2018-09-01T14:47:08.000Z","date_formatted":{"ll":"Sep 1, 2018","L":"09/01/2018","MM-DD":"09-01"},"updated":"2021-02-27T13:48:02.724Z","content":"备份命令\n1mysqldump ` mysqldump -hlocalhost -P3306 -uroot -p密码 –database 数据库名 &gt; 文件名.sql \n\n-h后为数据库server，一般都为localhost；\n-P为端口，一般数据库端口为3306；\n-u后为数据库管理员账号，一般为root；\n-p后为数据库管理密码；\n最后导出的sql文件可以加指定路径。\n\n导入数据库source命令\n\n用use进入到某个数据库，如果是新安装的先创建要还原的mysql数据库，use进入后\n\n1mysql&gt;source d:\\test.sql \nphpnmyadmin备份与还原\n备份：\n\n选中需要备份的数据库，点上面导出；\n\n还原：\n\n选中需要还原的数据库，没有则创建，然后点上面的导入，选择.sql文件。\n\n","plink":"https://www.zzboy.cn/Learning/59395ce40a3d/"},{"title":"phpmyadmin导入sql文件错误#1046 - No database selected","date":"2018-09-01T14:26:19.000Z","date_formatted":{"ll":"Sep 1, 2018","L":"09/01/2018","MM-DD":"09-01"},"updated":"2021-02-27T13:48:07.174Z","content":"\n** 这种情况是因为你在数据库中没有这个数据库， 你需要新建一个你要导入的数据库名字的数据库， 然后选中该数据库，再进行导入。**\n","plink":"https://www.zzboy.cn/Learning/0dd73d06ceeb/"},{"title":"ubuntu下安装和彻底删除mysql5.7","date":"2018-08-31T06:12:43.000Z","date_formatted":{"ll":"Aug 31, 2018","L":"08/31/2018","MM-DD":"08-31"},"updated":"2021-02-27T13:47:58.484Z","content":"彻底删除mysql5.7\n1sudo rm /var/lib/mysql/ -R \n- 删除数据库目录\n1sudo rm /etc/mysql/ -R \n- 删除启动脚本、配置文件等\n1sudo apt-get autoremove mysql* --purge \n- 卸载mysql所有文件\n1sudo apt-get remove apparmor \n\n这个apparmor是在装mysql-server时装上的，和安全有关\n\n1dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P \n\n清理残余mysql文件\n\nmysql5.7的安装\n1sudo apt-get install mysql-server-5.7 mysql-client-5.7\n\n安装过程会提示设置mysql root用户的密码，设置完成后等待自动安装即可。默认安装完成就启动了mysql。\n\n安装好后，查看是否安装成功：\n1sudo netstat -tap | grep mysql\n\n如果看到有mysql 的socket处于 listen 状态则表示安装成功。\n\n登录mysql检查和退出mysql\n登录：\n1mysql -uroot -p密码\n退出：\n1quit;\n常见命令：\n123service mysql start #启动mysql service mysql stop #关闭mysql service mysql restart #重启mysql \n更改mysql管理密码\n先进入mysql程序：\n1mysql -uroot -p密码\n然后修改mysql数据库中的user表\n123mysql&gt;use mysql; mysql&gt;update user set password=password(&quot;新密码&quot;) where user=&#x27;root&#x27;; mysql&gt;FLUSH PRIVILEGES; #刷新权限","plink":"https://www.zzboy.cn/Learning/01437af1786e/"},{"title":"php版本5.*升级7.0","date":"2018-08-31T06:01:14.000Z","date_formatted":{"ll":"Aug 31, 2018","L":"08/31/2018","MM-DD":"08-31"},"updated":"2021-02-27T13:47:54.468Z","content":"安装ppa\n123sudo apt-get install python-software-properties software-properties-common sudo add-apt-repository ppa:ondrej/php sudo apt-get update \n删除php5\n12345678910111213141516171819sudo apt-get purge php5-fpm php5-mysql php5-common sudo apt-get --purge autoremove ## 安装php7 ```bashsudo apt-get install php7.0-fpm php7.0-mysql php7.0-common php7.0-curl ## 修改nginx站点配置*.conf把nginx站点配置*.conf 里的fastcgi\\_pass配置改成：```bashfastcgi\\_pass unix:/run/php/php7.0-fpm.sock; ## 重启```bashnginx sudo service nginx reload \n完成.\n","plink":"https://www.zzboy.cn/Learning/cd9209d16b74/"},{"title":"留言板设计-PHP+MySQL入门程序","date":"2018-04-23T03:15:47.000Z","date_formatted":{"ll":"Apr 23, 2018","L":"04/23/2018","MM-DD":"04-23"},"updated":"2021-02-27T13:47:51.120Z","content":"\n程序结构图\n\n前端设计\n留言界面\n框架结构图\n\n代码：index.html\n12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;\t&lt;head&gt;\t\t&lt;meta charset=&quot;utf-8&quot; /&gt;\t\t&lt;title&gt;Leave a message to Patrick Jun&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;\t\t     .message&#123;\t\t         margin-top:0px;\t\t     &#125;\t\t     h1&#123;\t\t         margin-top:100px;\t\t     &#125;\t\t     #message&#123;\t\t     \theight: 100px;\t\t     \tfont-size: 24px;\t\t     &#125;\t\t     #author,#title&#123;\t\t     \tfont-size: 24px;\t\t     &#125;    \t&lt;/style&gt;\t&lt;/head&gt;\t&lt;body&gt;\t\t &lt;h1 align=&quot;center&quot;&gt;Leave a message to Patrick Jun&lt;/h1&gt;\t\t   &lt;div class=&quot;message&quot;&gt;\t\t       &lt;form name=&quot;addform&quot; id=&quot;addform&quot; method=&quot;post&quot; action=&quot;insert.php&quot;&gt;\t\t           &lt;table type=&quot;text&quot; align=&quot;center&quot;&gt;\t\t            &lt;tr&gt;\t\t                &lt;td&gt;What?&lt;/td&gt;\t\t                &lt;td&gt;&lt;textarea name=&quot;message&quot; id=&quot;message&quot; cols=&quot;30&quot; role=&quot;15&quot;&gt;&lt;/textarea&gt;&lt;/td&gt;\t\t            &lt;/tr&gt;\t\t            &lt;tr&gt;\t\t                &lt;td&gt;Name&lt;/td&gt;\t\t                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author&quot; id=&quot;author&quot;/&gt; &lt;/td&gt;\t\t            &lt;/tr&gt;\t\t            &lt;tr align=&quot;center&quot;&gt;\t\t                &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;sumbit&quot; value=&quot;Sumbit&quot;/&gt;\t\t                &lt;input type=&quot;reset&quot; name=&quot;reset&quot; value=&quot;Reset&quot;/&gt;&lt;/td&gt;\t\t            &lt;/tr&gt;\t\t           &lt;/table&gt;\t\t       &lt;/form&gt;\t\t   &lt;/div&gt;\t&lt;/body&gt;&lt;/html&gt;\n效果图\n\n留言展示界面\n框架结构图\n\n代码：show.php\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?phpheader(&quot;Content-Type: text/html; charset=UTF-8&quot;);$localhost=&#x27;localhost&#x27;;$user=&#x27;youruser&#x27;;//你的数据库用户名$password=&#x27;yourpassword&#x27;;//你的数据库密码$database=&#x27;test&#x27;;//数据库名$tablename=&#x27;messageboard&#x27;;//表名$con = mysqli_connect($localhost, $user, $password);//数据库连接if(!$con )&#123;    die(&quot;连接失败:&quot; . mysqli_error($con)) ;&#125;else echo &#x27;连接成功...&lt;br /&gt;&#x27;;mysqli_query($con,&quot;set names utf8&quot;);mysqli\\_select\\_db($con,$database);//选择数据库$sql=&quot;select id,author,message,time from $tablename&quot;;//从表中选择数据$retval=mysqli_query($con,$sql);if(!$retval)&#123;die(&#x27;读取数据失败：&#x27; . mysqli_error($con));&#125;?&gt;&lt;HTML&gt;&lt;Head&gt;    &lt;meta  http-equiv=&quot;CONTENT-TYPE&quot; content=&quot;text/html&quot;  ; charset=&quot;UTF-8&quot;&gt;\t\t&lt;title&gt;Leave a message to Patrick Jun&lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;\t\t     .message&#123;\t\t         margin-top:0px;\t\t     &#125;\t\t     h1&#123;\t\t         margin-top:100px;\t\t     &#125;\t\t     #message&#123;\t\t     \theight: 100px;\t\t     \tfont-size: 24px;\t\t     &#125;\t\t     #author,#title&#123;\t\t     \tfont-size: 24px;\t\t     &#125;\t\t.tdcenter&#123;\t\t\ttext-align:center;\t\t&#125;    \t&lt;/style&gt;&lt;/Head&gt;&lt;body&gt;\t&lt;h1 align=&quot;center&quot;&gt;Leave a message to Patrick Jun&lt;/h1&gt;\t\t   &lt;div class=&quot;message&quot;&gt;\t\t       &lt;form name=&quot;addform&quot; id=&quot;addform&quot; method=&quot;post&quot; action=&quot;insert.php&quot;&gt;\t\t           &lt;table type=&quot;text&quot; align=&quot;center&quot;&gt;\t\t               &lt;input type=&quot;hidden&quot; id=&quot;id&quot; name=&quot;id&quot; /&gt;\t\t            &lt;tr&gt;\t\t                &lt;td&gt;What?&lt;/td&gt;\t\t                &lt;td&gt;&lt;textarea name=&quot;message&quot; id=&quot;message&quot; cols=&quot;30&quot; role=&quot;15&quot;&gt;&lt;/textarea&gt;&lt;/td&gt;\t\t            &lt;/tr&gt;\t\t            &lt;tr&gt;\t\t                &lt;td&gt;Name&lt;/td&gt;\t\t                &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;author&quot; id=&quot;author&quot;/&gt; &lt;/td&gt;\t\t            &lt;/tr&gt;\t\t            &lt;tr align=&quot;center&quot;&gt;\t\t                &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;sumbit&quot; value=&quot;Sumbit&quot;/&gt;\t\t                \t&lt;input type=&quot;reset&quot; name=&quot;reset&quot; value=&quot;Reset&quot;/&gt;&lt;/td&gt;\t\t            &lt;/tr&gt;\t\t           &lt;/table&gt;\t\t       &lt;/form&gt;\t\t   &lt;/div&gt;\t\t  &lt;hr size=&quot;1&quot; style=&quot;border: dotted;&quot;&gt;\t&lt;div&gt;&lt;?phpif(empty($retval))&#123;echo &quot;还没有留言&quot;;&#125;?&gt;&lt;h2&gt;Message Record:&lt;h2&gt;\t&lt;center&gt; &lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;\t&lt;tr&gt;&lt;td width=&quot;30&quot; class=&quot;tdcenter&quot;&gt;&lt;b&gt;ID&lt;/b&gt;&lt;/td&gt;\t&lt;td width=&quot;150&quot; class=&quot;tdcenter&quot;&gt;&lt;b&gt;Name&lt;/b&gt;&lt;/td&gt;\t&lt;td width=&quot;70%&quot; class=&quot;tdcenter&quot;&gt;&lt;b&gt;Message&lt;/b&gt;&lt;/td&gt;\t&lt;td class=&quot;tdcenter&quot;&gt;&lt;b&gt;Time&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;\t&lt;?php while($row = mysqli\\_fetch\\_assoc($retval))&#123; ?&gt;//遍历输出数据\t\t&lt;tr&gt;&lt;td class=&#x27;tdcenter&#x27;&gt;&lt;?php echo &quot;$row\\[&#x27;id&#x27;\\]&quot;;?&gt;&lt;/td&gt;\t\t&lt;td class=&#x27;tdcenter&#x27;&gt;&lt;?php echo &quot;$row\\[&#x27;author&#x27;\\]&quot;;?&gt;&lt;/td&gt;\t\t&lt;td&gt;&lt;?php echo &quot;$row\\[&#x27;message&#x27;\\]&quot;;?&gt;&lt;/td&gt;\t\t&lt;td class=&#x27;tdcenter&#x27;&gt;&lt;?php echo &quot;$row\\[&#x27;time&#x27;\\]&quot;;?&gt;&lt;/td&gt;\t\t&lt;/tr&gt;        &lt;?php &#125; ?&gt;\t&lt;/table&gt;&lt;/center&gt;\t&lt;?php mysqli_close($con);?&gt;&lt;/div&gt;&lt;/Body&gt;&lt;/HTML&gt;\n后端设计设计\n数据写入数据库\n代码：insert.php\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpheader(&quot;CONTENT-TYPE:text/html;charset=UTF-8&quot;);function check\\_table\\_is\\_exist($con,$database,$find\\_table)//判断是否存在数据库和表&#123;    if(mysqli\\_select\\_db($con,$database))&#123;    \t$sql = &quot;show tables&quot;; // to show databases \t    $row = mysqli_query($con,$sql);\t    while ($result = mysqli\\_fetch\\_array($row,MYSQLI_NUM ))\t    &#123;\t        for( $i = 0 ; $i &lt; count($result); $i++)&#123;\t            if( $find_table ==  $result\\[$i\\]) &#123;\t                // echo &quot;found &quot; . $find_table . &#x27;&lt;br /&gt;&#x27;;\t                return true;   \t            &#125;\t        &#125;\t    &#125;\t    return false;    &#125;\t    else &#123;    \techo &quot;数据库不存在&quot;;    \treturn false;\t&#125;&#125;$localhost=&#x27;localhost&#x27;;$user=&#x27;youruser&#x27;;//你的数据库用户名$password=&#x27;yourpassword&#x27;;//你的数据库密码$database=&#x27;test&#x27;;//数据库名$tablename=&#x27;messageboard&#x27;;//表名$con = mysqli_connect($localhost, $user, $password);if(!$con )&#123;    die(&quot;连接失败:&quot; . mysqli_error($con)) ;&#125;else echo &#x27;连接成功...&lt;br /&gt;&#x27;;mysqli_query($con,&quot;set names utf8&quot;);$author=$_POST\\[&quot;author&quot;\\];//获取前端页面index.html传来的数据$message=$_POST\\[&quot;message&quot;\\];$time=date(&#x27;Y-m-d-h:m:s&#x27;);if(!mysqli\\_select\\_db($con,$database))&#123;//判断是否存在数据库，不存在就新创建一个数据库\t$sql=&quot;CREATE DATABASE $database&quot;;\tmysqli_query($con,$sql);\tmysqli\\_select\\_db($con,$database);&#125;if(!check\\_table\\_is_exist($con,$database,$tablename))&#123;//判断是否存在表，不存在就新创建一个表\t$sql=&quot;CREATE TABLE $tablename(\t\tid INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY,\t\tauthor VARCHAR(30),\t\tmessage VARCHAR(20),\t\ttime TIMESTAMP\t)&quot;;\tmysqli_query($con,$sql);&#125; $sql=&quot;INSERT INTO $tablename(author,message,time) VALUES(&#x27;$author&#x27;,&#x27;$message&#x27;,&#x27;$time&#x27;)&quot;;//向数据库中插入数据$result=mysqli_query($con,$sql);if($result)&#123;    echo &quot;&lt;script&gt;alert(&#x27;写入成功！&#x27;);window.location.href=&#x27;show.php&#x27;&lt;/script&gt;&quot;;&#125;else &#123;    echo &quot;&lt;script&gt;alert(&#x27;写入失败！&#x27;);window.location.href=&#x27;index.html&#x27;&lt;/script&gt;&quot;;&#125;?&gt;\n初学时，自己写的留言系统，很多东西可能都不够完善，但对于新手理解PHP+MySQL的程序设计应该够了。如果有PHP大佬路过，请帮忙指出该程序的不足之处，谢谢！\n","plink":"https://www.zzboy.cn/Learning/3c427628ca1d/"},{"title":"Java学习-值类型的变量和值及其运算","date":"2018-03-13T00:58:33.000Z","date_formatted":{"ll":"Mar 13, 2018","L":"03/13/2018","MM-DD":"03-13"},"updated":"2021-02-27T13:47:47.616Z","content":"值类型的变量和值及其运算\n数值\n\n数据(值)用于描述事物的具体状态. 例如某个人的身高的是1.73米, 这里的1.73米就是值. Java中数值有限精度的, 也就是有效数字的位数是固定的. 如果需要更长的整数, 使用BigInteger类型的对象. 如果需要更多位有效数字的浮点数数, 使用BigDecimal类型的对象.\n\n整数 [table id=java-int /]\n\n如果需要更长的整数, 使用BigInteger类型的对象.\n\n浮点数 [table id=java-float /]\n\n如果需要更多位有效数字的浮点数数, 使用BigDecimal类型的对象.\n\n运算 加减乘除\n\n\n数学上的整数， 有理数是具有无限多的。 计算机上能表示的数字， 数量是有限的。 有限的数字导致整数只能表达一个有限的范围。 有限的数字导致浮点数只能表达有限的进度和范围。\n\n\n数学运算面临的最大问题是溢出。 超出数字能够表达的范围， 上溢。超出数字能表达的精度， 狭隘。 浮点数通常是不能精确表达的， 因此， 不要与浮点数表达相等。 与浮点数比较， 相差一个非常小的范围， 视为相等。\n\n\n赋值 精度和溢出 常用数学函数 Math类 高精度计算\n","plink":"https://www.zzboy.cn/Learning/111a1ef59c51/"},{"title":"Java学习-自定义简单函数","date":"2018-03-11T07:17:06.000Z","date_formatted":{"ll":"Mar 11, 2018","L":"03/11/2018","MM-DD":"03-11"},"updated":"2021-02-27T13:47:34.425Z","content":"自定义简单函数\n\n学习编写静态(static)函数、函数的参数、返回值的使用, 函数的具体实现。\n\n123456/*输入双精度数字函数*/static double inputNumber()&#123;    Scanner scanner = new Scanner(System.in);    double number =  scanner.nextDouble();    return number;&#125;\n注：系统的输入，需要在主类前导入扫描类包，即在主类前添加一下代码：\n1import java.util.Scanner;\n笔记：\n\nstatic是定义静态函数的意思；\ninputNumber是函数名，前面的double指此函数的返回类型，还可以是其他的如：int,Int,Double,void等；\nscanner是实例化的扫描类；\n函数返回类型不是void的就要添加语句return进行值返回，此例返回输入的双精度变量number的值；\n\n1234567static Double Calculate(double x,char c,double y)&#123;    if(c==&#x27;+&#x27;)return x+y;    else if(c==&#x27;-&#x27;)return x-y;    else if(c==&#x27;*&#x27;)return x*y;    else if(c==&#x27;/&#x27;)return x/y;    else return null;&#125;\n笔记：\n\n函数后面需要添加一对小括号，用来接收参数供函数处理，可以接收多个参数，在里面定义的参数叫形参；\nif-else是选择语句,表示如果（条件是真的）就{执行代码}，否者执行{}；\n\n主函数调用自定义函数\n123456789101112131415161718public static void main(String\\[\\] args)&#123;    System.out.println(&quot;--------简单计算器-------&quot;);    Scanner scanner = new Scanner(System.in);    while(true)&#123;        System.out.print(&quot;请输入第一个数：&quot;);        double x = inputNumber();              //inputNumber函数调用        System.out.print(&quot;请输入运算符号：&quot;);        String cc = scanner.next();        char c = cc.charAt(0);        System.out.print(&quot;请输入第二个数：&quot;);        double y = inputNumber();        System.out.print(&quot;运算结果：&quot; + Calculate(x,c,y));    // Calculate函数调用        System.out.println(&quot;\\\\n-------\\\\n还需要继续吗？Y（yes）/N(no)：&quot;);        cc = scanner.next();        if(cc.equals(&quot;N&quot;)||cc.equals(&quot;n&quot;)||cc.equals(&quot;no&quot;)||cc.equals(&quot;NO&quot;)||cc.equals(&quot;No&quot;))break;     &#125;     System.out.println(&quot;---------------------\\\\nBye!&quot;);&#125;\n笔记：\n\n由于Java Scanner没有nextChar()的输入，但可以通过 String cc = scanner.next(); char c = cc.charAt(0); 接收到cc字符串，取cc其中一个为char c；\nwhile(true)执行死循环；\n||表示或者的意思。例子中输入N或n或no或NO或No就可以退出循环；\n\n","plink":"https://www.zzboy.cn/Learning/f5d5aa2ce3f4/"},{"title":"Java学习-Java基本输入输出","date":"2018-03-11T01:12:29.000Z","date_formatted":{"ll":"Mar 11, 2018","L":"03/11/2018","MM-DD":"03-11"},"updated":"2021-02-27T13:47:43.269Z","content":"Java基本输入输出\n输出各种类型的变量的值\n12345678910111213141516public class Main &#123;    public static void main(String\\[\\] args) &#123;        int number = 100;        System.out.println(number);        char c1 = &#x27;a&#x27;; //字符的要用单引号, 用于区分变量名和字符.        System.out.println(c1);        char c2 = &#x27;中&#x27;; //Java的char是Unicode的, 可以表示全世界的任何语言文字        System.out.println(c2);        byte b = 0b101; //二进制的0b101就是10进制的5        System.out.println(b);        double height = 1.72;        System.out.println(height);        boolean isOK = true;        System.out.println(isOK);    &#125;&#125;\n运行后输出:\n123456100a中51.72true\n从键盘输入字符串\n123456789import java.util.Scanner; //从路径java.util找到Scannerpublic class Main &#123;    public static void main(String\\[\\] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;Input Name:&quot;);        String name = scanner.next();        System.out.println(&quot;你好!&quot; + name);    &#125;&#125;\n运行程序, 控制台上显示”Input Name:”后等待从键盘输入.\n1Input Name:\n输入Patrick Jun后, 程序继续执行. 程序的完整的运行结果如下:\n123Input Name:Patrick Jun你好!Patrick Jun\n从键盘输入各种类型的数据\nScanner能够自动把从键盘输入的内容转换成指定类型的数据.\n12345678910111213141516171819import java.util.Scanner; //从路径java.util找到Scannerpublic class Main &#123;    public static void main(String\\[\\] args) &#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;Input Name:&quot;);        String name = scanner.next();        System.out.println(&quot;你好!&quot; + name);        System.out.println(&quot;Input age(整数)&quot;);        int age = scanner.nextInt();        System.out.println(&quot;Input 身高(小数)&quot;);        double height = scanner.nextDouble();        System.out.println(&quot;Input 否是是学生(是输入true, 不是输入false)&quot;);        boolean isStudent = scanner.nextBoolean();        System.out.println(&quot;华丽的分割线------------&quot;);        System.out.println(&quot;age=&quot; + age);        System.out.println(&quot;height=&quot; + height);        System.out.println(&quot;是学生吗?=&quot; + isStudent);    &#125;&#125;\n运行结果:\n12345678910111213Input Name:zhangsanfeng你好!zhangsanfengInput age(整数)120Input 身高(小数)1.72Input 否是是学生(是输入true, 不是输入false)false华丽的分割线------------age=120height=1.72是学生吗?=false","plink":"https://www.zzboy.cn/Learning/e622c9e836e9/"},{"title":"Java学习-HelloWorld!","date":"2018-03-11T00:20:25.000Z","date_formatted":{"ll":"Mar 11, 2018","L":"03/11/2018","MM-DD":"03-11"},"updated":"2021-02-27T13:47:38.633Z","content":"这学期学习Java，我就用博客记录一下我整个学习的内容吧。\nJava从main方法开始执行\n12345678public class DemoClass&#123;  public static void main(String\\[\\] args) &#123;    //Java程序从这里开始执行//表示本行是注释    System.out.println(&quot;Hello,World!&quot;);    System.out.println(&quot;世界,你好!&quot;);    System.out.println(&quot;大家好!&quot;);  &#125;&#125;\n执行上面的程序会输出:\n123Hello,World!世界,你好!大家好!\n\nJava文件的名字必须是public class 后面的名字(通常称为类名).java 例如上面的程序必须放在DemoClass.java文件中.\n英文字符大小写必须一致. Java认为大写和小写的字符不是同一个字符.\nJava语言中用{}表示范围.\n\n类名后面的一对{}表示这个类的包含的范围. void main(String[] args)后面的一对{}表示这个方法的包含的范围.\n方法名字后面的一对()是方法要处理的变量.\n\n\n分号表示一条语句的结尾. 双引号”“表示字符串的开始和结尾.\n英文的句号(.)可以读作”的”, 用于限定范围. 例如语句System.out.println(“Hello,World!”);其真实含义是计算机系统(System)的标准输出(out,显示器)的输出一行方法(println)负责处理字符串”Hello,World!”, 也就是在计算机的显示器上打印(显示)一行文字Hello,World!.\nJava的源程序文件通常用包(package)组织起来， 包名就是目录名。\n\n","plink":"https://www.zzboy.cn/Learning/a0fc4dd9990c/"},{"title":"修改WordPress主题字体，使用自定义TTF字体","date":"2018-02-05T05:43:46.000Z","date_formatted":{"ll":"Feb 5, 2018","L":"02/05/2018","MM-DD":"02-05"},"updated":"2021-02-27T13:47:23.703Z","content":"在美化WordPress主题时，字体是其中一个重要元素。 在搭建博客的时候，我也用到了美化博客字体。 因为有些自带字体真的无法体现出自己的特色，所以，自己参照很多，不断地优化，自己总结了一套完整的教程，希望对大家有帮助。\n第一步：确定目标位置\n比如我要更改我博客的“开源精神，乐于分享”的博客签名；\n\n在浏览器上打开博客，按F12进入查看器，找到此博客签名的代码，点击一下，并可以在下面看到此元素的class类名中那个包含了font-family属性，记住这个类名以及右侧的文件名，比如，我这个博客签名的类名是site-description，右侧显示的该样式控制在style.css文件内； \n第二步：修改主题样式表\n进入博客后台，进入外观-编辑，右边选择你所对应的博客，选择样式表style.css；\n\n然后在左侧代码区，通过搜索命名Ctrl+f，搜索类名site-description，修改字体即可；\n\n但是，还有一个问题是，就是这个在你本人的电脑上能正确显示，因为你本人电脑上有安装这个字体，但别人的电脑上就无法显示出这个字体样式，所以，我们还得进行第三步，上传字体文件。\n第三步：上传字体文件并引入主题\n使用FTP登录服务器或者虚拟主机，上传你需要的字体到WordPress文件目录/wp-includes/fonts/\n\n然后再次进入WordPress后台-外观-编辑-style.css，就在文件前面添加一下的代码即可：\n12@font-face &#123; font-family: &quot;钟齐安景臣硬笔行书&quot;; src: url(http://www.abc.com/wp-includes/fonts/钟齐安景臣硬笔行书.ttf) format(&quot;truetype&quot;); &#125; \n\n\n其中font-family是字体名，这个可以自己取，但必需和第二步在site-description中font.family设置的名称一致；下面的 www.abc.com 以及后面的ttf文件路径，修改为自己的博客地址对应的就是了。 这样，别人访问你的博客就可以看见这样的字体，包括移动端。\n\n但还有一个问题就是，这样字体加载很慢，一般字体文件大小都有好几兆，中文字体一般都得上10兆了，所以，我们还可以把字体文件ttf给裁剪一下。\n第四步：字体文件裁剪\n下面就需要一个工具了，当初我也是在网上找了大半天，最后终于找到了一个不错的工具，这里就免费提供给大家了，工具下载。\n这个工具使用很简单，选择你要裁剪的字体，输入你要得保存的那些字，选择输出路径即可，切记输出路径千万别和你原来的字体选择同一路径，因为这个工具它没有提示，会字体给原来字体替换掉，当然如果觉得原来的字体没什么用也就没什么关系了。\n\n","plink":"https://www.zzboy.cn/Learning/f0c1e4e6fd81/"},{"title":"在Ubuntu（Linux）下 使用Let's Encrypt免费SSL证书，实现全站HTTPS","date":"2018-02-05T04:30:18.000Z","date_formatted":{"ll":"Feb 5, 2018","L":"02/05/2018","MM-DD":"02-05"},"updated":"2021-02-27T13:47:30.058Z","content":"Let’s Encrypt免费SSL证书，实现全站HTTPS\n第一步：安装git\n执行以下命令：\n1apt-get install git\n第二步：获取Let’s Encrypt免费SSL证书(会自动配置环境)\n执行以下命令：\n123git clone https://github.com/letsencrypt/letsencryptcd letsencrypt./letsencrypt-auto\n期间会提示输入你的邮箱，然后一路a(agree),y(yes)。 站点选择的时候， 开通对应站点前的数字即可，如果空着的话，就代表主机上的站点全部开通。\n","plink":"https://www.zzboy.cn/Learning/ef95baa65b1c/"},{"title":"Dream","date":"2017-05-01T10:38:53.000Z","date_formatted":{"ll":"May 1, 2017","L":"05/01/2017","MM-DD":"05-01"},"updated":"2021-02-27T13:47:17.940Z","content":"  Hello, everyone! My name is Patrick Jun. I come from the network engineering class 162. I am honored to be here to give a speech. The theme today(or tonigt) I want to address is “Dream”.\n  First of all, I would like to ask you three questions: the first one is whether you have a dream or whether you have a dream ever. And second, what is your dream. Third, for this dream, how will you do?\n  Once I talked about the dream with a graduated senior who has worked, he said: “What is a dream, how far the word is. The thing only belongs to these hot-blooded young people. Now, I do not have any dream, and just want to lead a realistic life”. I chose silence at that time. I was thinking, what kind of heavy reality can make a person even forget his dreams.\n  Then, thinking about yourselves what is your dream? Some people would say, my dream is to be a doctor, a teacher and so on. Even there would be some persons say, my dream is that every day is holiday. Of course, such a dream can only dream in your mind. I think, as long as your dream can give you support to keep going when you feel chagrined or frustrated, thinking of your dream which can make you spirited, it is already half of the battle.\n  In fact, each of us has dreams, but with the time goes by, a variety of brutal realities, would kill our will, so we have to believe that it’s impossible to complete the dream. As a result, the action was pushed infinitely by one after another “but”. Gradually, we give up our dreams, and like most people, choosing the plain.\n  Before I go to the college, I thought “admitted to the University” is the dream of each of us. However, think about now what we are doing. Isn’t you want to have a slightly helpless smile? So, in order to live wonderfully, we need dreams.\n  We all should have our own dreams, not a heart will be hurt because of the pursuit of dreams.\n  In the eyes of The Little Match Girl, the dream is fragrant roast geese, grandmother’s warm arms.\n  In the eyes of Helen Keller, the dream is three days of light.\n  In the eyes of Martin Luther King, Jr. the dream is that blacks get equal treatment.\n  Dreams is like sunshine, it makes people from impetuous to practical, from a loss to the firm, and to success.\n  Dream is powerful, which is the source of driving force of life. Lofty dreams can inspire a person all potentail. God did not give us wings, but gave us a flying heart, a dreaming brain.\n  We have youth, the most precious wealth in the world. Jay Chou said: “I want to climb up step by step, a small day also has a big dream”.\n  I also have a little dream. Although I have poor writing English and poor spoken English. I like English. My dream is that I can have a wonderful English speech. Obviously, I stand here, I have now achieved it! I pursued this dream so I spent the whole winter vacation to prepare. During the period, I corrected numerous grammatical mistakes and revised the manuscript countless times, practicing the word’s pronunciation every day. I have nerver recited more than 200 words of English articles, but this time I probably recited about 600 words of speech draft! Then I will fight for my next dream!\n  Finally, I want to send you all a word: Let us believe that the power of dreams.\n  Thanks!\n","plink":"https://www.zzboy.cn/Learning/b59c9330cdff/"},{"title":"🐣 Who am I ?","date":"2021-02-27T14:02:53.416Z","date_formatted":{"ll":"Feb 27, 2021","L":"02/27/2021","MM-DD":"02-27"},"updated":"2021-02-27T14:02:53.416Z","content":"About Me\n12345678910111213141516171819202122232425262728293031&#123;  name: &#x27;Patrick Jun&#x27;  age: 25,  gender: &#x27;男&#x27;,  profession: &#x27;FE Developer&#x27;,  experience: &#x27;2年&#x27;,  address: &#x27;四川省成都市&#x27;,  education: &#x27;本科&#x27;,  github: &#x27;https://github.com/Patrick-Jun&#x27;,  blog: &#x27;http://zzboy.cn&#x27;,  email: &#x27;nunet@qq.com&#x27;,  hobbies: [&#x27;马拉松&#x27;, &#x27;钓鱼&#x27;, &#x27;OSU!&#x27;],  description: &#x27;喜欢think，有很多idea，乐于用代码去实现&#x27;,  skills: [    [&#x27;Html&#x27;, &#x27;Javascript&#x27;, &#x27;jQuery&#x27;, &#x27;CSS&#x27;, &#x27;ES6+&#x27;, &#x27;Node&#x27;],    [&#x27;Webpack&#x27;, &#x27;Gulp&#x27;],    [&#x27;Less&#x27;,&#x27;Sass&#x27;, &#x27;Scss&#x27;],    [&#x27;Angular&#x27;, &#x27;Vue3&#x27;, &#x27;Nest&#x27;],    [&#x27;Git&#x27;, &#x27;SVN&#x27;],    [&#x27;ECharts&#x27;, &#x27;Wechat app&#x27;],  ],  devTools: [    [&#x27;Visual Studio Code&#x27;, &#x27;Android Studio&#x27;, &#x27;Vim&#x27;],    [&#x27;Chrome DevTools&#x27;, &#x27;Cocos&#x27;],    [&#x27;Typora&#x27;, &#x27;XMind&#x27;, &#x27;Photoshops&#x27;],    [&#x27;Postman&#x27;, &#x27;Charles&#x27;],    [&#x27;Navicat&#x27;, &#x27;Permute&#x27;, &#x27;RDM&#x27;],  ]  &#125;\nAbout Blog\n此博客，是我在一些学习过程中遇到了一些问题、总结的笔记，下次忘记了就重新来看看。\n也有些是总结的模板，可以直接Ctrl CV\n当然如果我的记录能帮到大家，我也很开心\nShare together and make progress together.","plink":"https://www.zzboy.cn/about/"},{"title":"书单","date":"2021-02-18T00:00:00.000Z","date_formatted":{"ll":"Feb 18, 2021","L":"02/18/2021","MM-DD":"02-18"},"updated":"2021-02-27T14:22:29.427Z","content":"\n\n书名\n开始时间\n完成时间\n笔记\n\n\n\n\n《JavaScript高级程序设计》\n2019-07-10\n\nJavaScript-函数问题JavaScript-数据操作JavaScript-对象创建 JavaScript-获取URL参数 JavaScript-事件\n\n\n《极客与团队》\n2020-08-22\n2020-09-13\n-\n\n\n","plink":"https://www.zzboy.cn/booklist/"},{"title":"Links","date":"2021-02-27T09:59:21.760Z","date_formatted":{"ll":"Feb 27, 2021","L":"02/27/2021","MM-DD":"02-27"},"updated":"2021-02-27T09:59:21.760Z","content":"友情链接\n这里是友情链接，联系可以互换哦\n\n\nIk’s blog :  https://qiyanan.com/\n\n\nxt:  http://xtzero.me/\n\n\n学习链接\n这些是我正在或者曾经学习的网上资源\n\n可可英语：www.kekenet.com\nHCNA华为认证网络工程师培训 V2.2 - 华为培训认证\n[计蒜客](https://www.jisuanke.com/plan?object=参加算法与程序设计竞赛&amp;subobject=信息学竞赛 NOIP/NOI)\n牛客网（就业）： https://www.nowcoder.com/\n英语听力学习：https://www.youzack.com/\n洛谷（算法）：https://www.luogu.org/\nLaravel：https://qianjinyike.com/category/laravel/\nnode.js：https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040\n\n工具链接\n这些工具链接，先备在这里吧，以免找不到\n\n在线正则校验：http://reg.1zdz.cn/\n在线JSON校验：https://www.json.cn/\n在线Markdown: https://www.mdeditor.com/\nPDF工具：https://pdf.io/\n在线剪辑音频：https://mp3cut.net/\nTinyPNG – 压缩图片\n工具资源操作系统等下载：MSDN, 我告诉你\nColor Themes：http://color-themes.com/?view=index\nColor Hunt：https://colorhunt.co/\n谷歌插件下载： https://chrome-extension-downloader.com/\n\n资料链接\n\nCSS参考手册： http://css.doyoe.com/\nBuefy UI ：https://buefy.org/documentation/customization\nAll Standards and Drafts - W3C：https://www.w3.org/TR/\nsymfony： https://symfony.com/doc/current/index.html#gsc.tab=0\n\n作品链接\n\nSTS学习资讯平台：http://www.stsedu.cn/\n智能语音识别记账本：https://github.com/Patrick-Jun/AiBook-backEnd\n工大教务处：https://github.com/Patrick-Jun/miniDLPU-WechatProgram\n安递物流：https://github.com/Patrick-Jun/andiExpress-WechatProgram\n跑鸭（毕设）：https://github.com/Patrick-Jun/poprun\n跑鸭（后端）：https://github.com/Patrick-Jun/poprun-b\n\n","plink":"https://www.zzboy.cn/links/"},{"title":"愿望清单","date":"2018-11-28T00:21:25.000Z","date_formatted":{"ll":"Nov 28, 2018","L":"11/28/2018","MM-DD":"11-28"},"updated":"2021-02-27T15:18:18.983Z","content":"个人小目标，努力努力再努力！\n\n\n愿望s\n许愿日期\n实现日期\n备注\n\n\n\n\n长10斤肉\n2018-11-28\n2019-04-08\n不知不觉长到124.3，开心\n\n\n跑一次全马\n2018-12-05\n2019-05-26\n鲅鱼圈全程马拉松5时21分完赛\n\n\n仿写一个游戏\n2019-03-11\n2021-02-03\n合成大西瓜，cocos\n\n\n卡片机SONY RX100 M6\n2019-05-29\n-\n-\n\n\n制作邻水三五反扑克牌游戏\n2020-01-26\n-\n-\n\n\n2020年参加大连或者成都马拉松\n2020-01-29\n-\n疫情影响\n\n\n学会一个人去看电影\n2020-02-06\n2020-07-26\n《多力特的奇幻冒险》\n\n\n学会一个人去吃自助\n2020-02-06\n2020-05-05\n为什么单人要加收10块钱？\n\n\n买一辆小摩托\n2020-03-28\n-\n-\n\n\n写2篇高质量原创（翻译）文章\n2021-01-10\n\n\n\n\n2021户外跑步600公里\n2021-01-10\n\n\n\n\n","plink":"https://www.zzboy.cn/wishlist/"}]